##################
# Chapter 6 - Solutions to negative predictions in PPOMs.
##################
# January 2019
##################
######################################################################################################
#########################################
# Figure 6.1 - code adapted from https://stats.stackexchange.com/questions/31597/graphing-a-probability-curve-for-a-logit-model-with-multiple-predictors
#########################################
##############
# (a)
##############
par(mar=c(5,5,2,2))
par(mfrow=c(2,2))
BID = seq(from=0, to=700, by=10)

logOdds.F.young = -3.92 + .014*BID-.45*1
logOdds.M.young = -3.92 + .014*BID -.15*1
logOdds.F.old   = -3.92 + .014*BID + .50*1
logOdds.M.old   = -3.92 + .014*BID + 0.75*1

pY.F.young = exp(logOdds.F.young)/(1+ exp(logOdds.F.young))
pY.M.young = exp(logOdds.M.young)/(1+ exp(logOdds.M.young))
pY.F.old   = exp(logOdds.F.old)  /(1+ exp(logOdds.F.old))
pY.M.old   = exp(logOdds.M.old)  /(1+ exp(logOdds.M.old))

#par(mfrow=c(1,2))
#last curve
plot(x=BID, y=pY.F.young, type="l",lwd=2, ylab=expression(P(Y<=j)), main="(a)",xlab="x",lty="dotted",cex=1.1,cex.lab=1.1,cex.axis=1.1)
lines(x=BID, y=pY.M.young,lwd=2,lty="dotdash")
lines(x=BID, y=pY.F.old,lwd=2,lty="dashed")
lines(x=BID, y=pY.M.old,lwd=2,lty="solid")
legend_texts=expression(P(Y<=4),P(Y<=3),P(Y<=2),P(Y<=1))
legend("bottomright", legend=legend_texts, lty=c("solid", "dashed", "dotdash", "dotted"), lwd=c(2,2,2,2))

##############
# (b)
##############

BID = seq(from=0, to=700, by=10)

logOdds.F.young = -3.92 + .014*BID-.25*1
logOdds.M.young = -3.92 + .0115*BID -.21*1
logOdds.F.old   = -3.92 + .014*BID + .50*1
logOdds.M.old   = -3.92 + .014*BID + 0.75*1


pY.F.young = exp(logOdds.F.young)/(1+ exp(logOdds.F.young))
pY.M.young = exp(logOdds.M.young)/(1+ exp(logOdds.M.young))
pY.F.old   = exp(logOdds.F.old)  /(1+ exp(logOdds.F.old))
pY.M.old   = exp(logOdds.M.old)  /(1+ exp(logOdds.M.old))


plot(x=BID, y=pY.F.young, type="l",lwd=2, ylab=expression(P(Y<=j)), main="(b)",xlab="x",lty="dotted",cex=1.1,cex.lab=1.1,cex.axis=1.1)
lines(x=BID, y=pY.M.young,lwd=2,lty="dotdash")
lines(x=BID, y=pY.F.old,lwd=2,lty="dashed")
lines(x=BID, y=pY.M.old,lwd=2,lty="solid")
legend_texts=expression(P(Y<=4),P(Y<=3),P(Y<=2),P(Y<=1))
legend("bottomright", legend=legend_texts, lty=c("solid", "dashed", "dotdash", "dotted"), lwd=c(2,2,2,2))

##############
# (c)
##############

BID = seq(from=0, to=700, by=10)

logOdds.F.young = -3.92 + .014*BID-.45*1
logOdds.M.young = -3.92 + .014*BID -.15*1
logOdds.F.old   = -3.92 + .014*BID + .50*1
logOdds.M.old   = -3.92 + .014*BID + 0.75*1

pY.F.young = exp(logOdds.F.young)/(1+ exp(logOdds.F.young))
pY.M.young = exp(logOdds.M.young)/(1+ exp(logOdds.M.young))
pY.F.old   = exp(logOdds.F.old)  /(1+ exp(logOdds.F.old))
pY.M.old   = exp(logOdds.M.old)  /(1+ exp(logOdds.M.old))

#last curve
plot(x=BID, y=logOdds.F.young, type="l",lwd=2, ylab=expression(logit(P(Y<=j))), main="(c)",xlab="x",lty="dotted",cex=1.1,cex.lab=1.1,cex.axis=1.1)
lines(x=BID, y=logOdds.M.young,lwd=2,lty="dotdash")
lines(x=BID, y=logOdds.F.old,lwd=2,lty="dashed")
lines(x=BID, y=logOdds.M.old, lwd=2,lty="solid")
legend_texts=expression(logit(P(Y<=4)),logit(P(Y<=3)),logit(P(Y<=2)),logit(P(Y<=1)))
legend("bottomright", legend=legend_texts, lty=c("solid", "dashed", "dotdash", "dotted"), lwd=c(2,2,2,2))

##############
# (d)
##############

BID = seq(from=0, to=700, by=10)

logOdds.F.young = -3.92 + .014*BID-.25*1
logOdds.M.young = -3.92 + .0115*BID -.21*1
logOdds.F.old   = -3.92 + .014*BID + .50*1
logOdds.M.old   = -3.92 + .014*BID + 0.75*1


pY.F.young = exp(logOdds.F.young)/(1+ exp(logOdds.F.young))
pY.M.young = exp(logOdds.M.young)/(1+ exp(logOdds.M.young))
pY.F.old   = exp(logOdds.F.old)  /(1+ exp(logOdds.F.old))
pY.M.old   = exp(logOdds.M.old)  /(1+ exp(logOdds.M.old))


plot(x=BID, y=logOdds.F.young, type="l",lwd=2, ylab=expression(logit(P(Y<=j))), main="(d)",xlab="x",lty="dotted",cex=1.1,cex.lab=1.1,cex.axis=1.1)
lines(x=BID, y=logOdds.M.young,lwd=2,lty="dotdash")
lines(x=BID, y=logOdds.F.old,lwd=2,lty="dashed")
lines(x=BID, y=logOdds.M.old, lwd=2,lty="solid")
legend_texts=expression(logit(P(Y<=4)),logit(P(Y<=3)),logit(P(Y<=2)),logit(P(Y<=1)))
legend("bottomright", legend=legend_texts, lty=c("solid", "dashed", "dotdash", "dotted"), lwd=c(2,2,2,2))

#########################################
# Figure 6.2
#########################################
set.seed(1839)
n <- 1000
x1 <- rnorm(n)
#x2 <- runif(n)

b01 <- -0.8
b02 <- -0.7
b03<--0.6 
b1 <- 0.1
b2<-0.13
b3<-0.16  

logitpp1<-b01 -b1 * x1 
logitpp2<-b02 -b2 * x1 
logitpp3<-b03 -b3 * x1 

#Parallel logits of original POM
par(mfrow=c(1,2))
plot(as.ordered(y),ylim=c(0,500),xlab="Y categories",ylab="counts",cex=1.2,cex.lab=1.2,cex.axis=1.2)
#Ordinal variable with 4categories
#Quasi-separation - category 2 very sparse 

plot(x1,logitpp1,col="black",type="l",lwd=5,cex=1.2,cex.lab=1.2,cex.axis=1.2,ylim=c(-2,2),xlab="x",ylab=expression("Original PPOM:"~logit(P(Y<=j))))
lines(x1,logitpp2,col="#E69F00",lwd=5)
lines(x1,logitpp3,col="#56B4E9",lwd=5)
legend_texts=expression(logit(P(Y<=3))~"  ",logit(P(Y<=2))~"  ",logit(P(Y<=1))~"  ")
legend(-1,1.9, legend=legend_texts, col=c("#56B4E9", "#E69F00", "black"), lwd=c(5,5,5))

#########################################
# Figure 6.3
#########################################
par(mfrow=c(1,1))
x<-c(-1,0,1,2,3,4,5)
y<-c(0,1,2,3,4,5,6)
plot(y~x,xlim=c(0,4),ylim=c(0,10),type="l",ylab=expression(logit(P(Y<=j))),xlab="z",axt="n",tick=FALSE,labels = FALSE,lwd=2,cex.lab=1.5)
axis(1,at=0.6,labels=expression(z[min]),cex.axis=1.5)
axis(1,at=1.8,labels=expression(z[max]),cex.axis=1.5)
#abline(1,0,lty=2,lwd=2)
abline(-1,2,lty=3,lwd=2)
abline(v=0.6,col="blue")
abline(v=1.8,col="red")

#########################################
# Figure 6.4
#########################################

#########################################
# Figure 6.16
#########################################
#PPOPO two covariates
#4 categories response 
#################
library(VGAM)
set.seed(1839)
n <- 100
x1 <-rnorm(n)
x2<-rnorm(n,0.1,0.1)


b01 <- -1.9
b02 <- -1.8
b03<--0.6
#BETA_J
b1 <- 0.1
b2<-0.13
b3<-0.16
#Gamma_{i} (n)
# g1<--2
# g2<-2.08
# g3<-2.495
#g1<- -2.1
g1<-0.1
g2<-0.03
g3<-0.26

logitpp1<-b01 -b1*x1 -g1*x2
logitpp2<-b02 -b2*x1 -g2*x2
logitpp3<-b03 -b3*x1 -g3*x2

inv_logit <- function(logit) exp(logit) / (1 + exp(logit))
cump1<-inv_logit(logitpp1)
cump2<-inv_logit(logitpp2)
cump3<-inv_logit(logitpp3)

prob_pp_1<-cump1
prob_pp_2<-cump2-prob_pp_1
prob_pp_3<-cump3-prob_pp_2
prob_pp_4<-1-prob_pp_1-prob_pp_2-prob_pp_3

table(c(prob_pp_1,prob_pp_2,prob_pp_3,prob_pp_4) > 0)

y<-c(n)
for (i in 1:n) {
  y[i] <- sample(
    x = c(1:4), 
    size = 1, 
    prob = c(prob_pp_1[i], prob_pp_2[i],prob_pp_3[i], prob_pp_4[i])
  )
}
dat <- data.frame(x1,x2, y)
#LINEAR CONSTRAINTS
#FIX PPOM1,PPOM2,PPOM10,PPOM17
fitPPOPO<-vglm(as.ordered(y) ~ x1+x2, data = dat,family=cumulative(parallel=TRUE~x1+x2))
fitPPOPPO<-vglm(as.ordered(y) ~ x1+x2, data = dat,family=cumulative(parallel=FALSE~x1+x2))
invlogit<-function(x){1/(1+exp(-x))}

#Standardise covariates
x1.min <- -3
x1.max <- 3
x2.min <- -3
x2.max <- 3
dat$x1.sc <- (dat$x1-x1.min)/(x1.max-x1.min)
dat$x2.sc <- (dat$x2-x2.min)/(x2.max-x2.min)
#Reparameterisation
#LL3 <- function(par,z.min,z.max,data)
LL3 <- function(par,data)
{
  Y <- as.ordered(data[,3])
  X <- cbind(data[,4],data[,5])
  n <- length(Y)
  C1 <- nlevels(as.ordered(Y))
  
  #Indicator matrix 
  I1 <- matrix(rep(0,n*C1),n,C1)
  I1[cbind(1:n,Y)] <- 1
  
  #Calculate cumulative probabilities P(Y<=1), P(Y <= 2), P(Y <= 3)
  lpar1 <- par[1]
  lpar2 <- par[2]
  lpar3 <- par[3]
  gamma1 <- par[4]
  gamma2 <- par[5]
  gamma3 <- par[6]
  zeta1 <- par[7]
  zeta2 <- par[8]
  zeta3 <- par[9]
  logit1 <- lpar1 + gamma1*X[,1]+zeta1*X[,2]
  logit2 <- lpar2 + gamma2*X[,1]+zeta2*X[,2]
  logit3 <- lpar3 + gamma3*X[,1]+zeta3*X[,2]
  Logit<-cbind(logit1,logit2,logit3)   
  P<-invlogit(Logit)
  
  #Set Initial response probabilities to 0
  Pi<-matrix(rep(0,n*C1),n,C1) 
  
  #j=1 and j=C always same expression
  Pi[,1]<-P[,1]
  Pi[,C1]<-1-P[,C1-1]
  for(j in 2:(C1-1)){
    Pi[,j]<-P[,j]-P[,j-1] 
  }
  
  #Log-likelihood:element-wise multiplication
  LL<--sum(I1*log(Pi))
  return(LL)
}
#Constraint matrix
#ui<-cbind(c(-1,0,-1,0),c(1,-1,1,-1),c(0,1,0,1),c(0,0,-1,0),c(0,0,1,-1),c(0,0,0,1),0,c(0,0,0,-1),c(0,0,0,1))
#ui<-cbind(c(-1,0,-1,1),c(1,-1,1,-1),c(0,1,0,0),c(0,0,-1,-1),c(0,0,1,1),c(0,0,0,0),c(0,0,0,-1),c(0,0,0,1),c(0,0,0,0))

ui<-cbind(rep(c(-1,0),4),rep(c(1,-1),4),rep(c(0,1),4),rep(c(0,0,-1,0),2),rep(c(0,0,1,-1),2),
	c(0,0,0,1,0,0,0,1),c(0,0,0,0,-1,0,-1,0),c(0,0,0,0,1,-1,1,-1),c(0,0,0,0,0,1,0,1))

#Constraint vector
ci<-rep(0,4)
#Starting values
# start<-c(fitPPOPO@coefficients,0,0,0,0,0,0)
start<-c(0.06542818,0.15733674,0.25843335,0.10246816,0.28520106,0.20,0.10,0.10,0.10)

#Check that they satisfy the constraints (all positive)
ui%*%start

#Optimisation
optimPPO1<-constrOptim(theta=start,f=LL3,ui=ui,ci=ci,data=dat,method="Nelder-Mead")
optimPPO1$value
#[1] 105.2631
LL3(par=start,data=dat)

pars <- optimPPO1$par

pred.sbp1 <- pars[1]+pars[4]*dat$x1.sc+pars[7]*dat$x2.sc
pred.sbp2 <- pars[2]+pars[5]*dat$x1.sc+pars[8]*dat$x2.sc
pred.sbp3 <- pars[3]+pars[6]*dat$x1.sc+pars[9]*dat$x2.sc

summary(dat$x1.sc)
summary(dat$x2.sc)

logit2prob <- function(logit){
  odds <- exp(logit)
  prob <- odds / (1 + odds)
  return(prob)
}

par(mfrow=c(1,2))
plot(sort(logit2prob(pred.sbp1),decreasing=FALSE)~sort(x1.sc,decreasing=TRUE),ylab=expression("PPOM-Repar:"~P(Y<=j)),ylim=c(0,1),cex.lab=2,xlab=expression(x[1]),cex.axis=2,pch=19,data=dat,type="l",lwd=5)
lines(sort(logit2prob(pred.sbp2),decreasing=FALSE)~sort(x1.sc,decreasing=TRUE),col="#E69F00",data=dat,pch=19,lwd=5)
lines(sort(logit2prob(pred.sbp3),decreasing=FALSE)~sort(x1.sc,decreasing=TRUE),col="#56B4E9",data=dat,pch=19,lwd=5)
abline(v=0.1527,lty=2,lwd=1)
abline(v=0.8573,lty=2,lwd=1)
legend(150,1.02, legend=c("P(Y<=3)","P(Y<=2)", "P(Y<=1)"),col=c("#56B4E9","#E69F00", "black"), lty=1, lwd=4, cex=1.2)

plot(sort(logit2prob(pred.sbp1),decreasing=FALSE)~sort(x2.sc,decreasing=TRUE),ylab=expression("PPOM-Repar:"~P(Y<=j)),ylim=c(0,1),cex.lab=2,xlab=expression(x[2]),cex.axis=2,pch=19,data=dat,type="l",lwd=5)
lines(sort(logit2prob(pred.sbp2),decreasing=FALSE)~sort(x2.sc,decreasing=TRUE),col="#E69F00",data=dat,pch=19,lwd=5)
lines(sort(logit2prob(pred.sbp3),decreasing=FALSE)~sort(x2.sc,decreasing=TRUE),col="#56B4E9",data=dat,pch=19,lwd=5)
abline(v=0.4732,lty=2,lwd=1)
abline(v=0.5584,lty=2,lwd=1)
legend(150,1.02, legend=c("P(Y<=3)","P(Y<=2)", "P(Y<=1)"),col=c("#56B4E9","#E69F00", "black"), lty=1, lwd=4, cex=1.2)

######################################################################################################
# Model selection using constrained log-likelihood approach
######################################################################################################
### The goal of this analysis is to: 
### determine the best PO/PPO fit for our data.
######################################################################################################
#Connectedness to nature example
#Rating of experience: 7 categories response 
############################################################################################
#List of models under comparison: (*:PPO)
# 1+CNS*+Cat* (done)
# 1+CNS*+Cat (done)
# 1+CNS*
# 1+CNS+Cat* (done)
# 1+Cat*
# 1+CNS+Cat
# 1+CNS
# 1+Cat
# 1
############################################################################################
#################
# 1+CNS*+Cat* 
#################
#Data available at: https://www.dropbox.com/s/t52nyhj68rryqqs/melteddata.csv?dl=0
#Read data
melt_select_data<-read.csv(file="melteddata.csv", header=TRUE, sep=",")
#Define variable levels
melt_select_data$id<-as.factor(melt_select_data$id)
levels(melt_select_data$Category)<-c("Nature","Shopping")
levels(melt_select_data$CNS)<-c("low","medium","high")
melt_select_data$CNS<-as.factor(melt_select_data$CNS)

#Libraries
library(VGAM)

#Models
fitPO<-vglm(as.ordered(value) ~ CNS+Category, data= melt_select_data,family=cumulative(parallel=TRUE~CNS+Category))
fitPPO<-vglm(as.ordered(value) ~ CNS+Category, data= melt_select_data,family=cumulative(parallel=FALSE~CNS+Category))

#Function to determine cumulative probabilities
invlogit<-function(x){1/(1+exp(-x))}

#Standardise covariates
CNS.min <- 1
CNS.max <- 3
Category.min <- 1
Category.max <- 2
melt_select_data$CNS.sc <- (melt_select_data$CNS-CNS.min)/(CNS.max-CNS.min)
melt_select_data$cCategory.sc <- (melt_select_data$Category-Category.min)/(Category.max-Category.min)

# Calculate the model's Log-likelihood
LL3 <- function(par,data)
{
  Y <- as.ordered(data[,4])
  X <- cbind(data[,2],data[,3])
  n <- length(Y)
  C1 <- nlevels(as.ordered(Y))
  
  #Indicator matrix 
  I1 <- matrix(rep(0,n*C1),n,C1)
  I1[cbind(1:n,Y)] <- 1
  
  #Calculate cumulative probabilities P(Y<=1), P(Y <= 2), P(Y <= 3), P(Y <= 4), P(Y <= 5), P(Y <= 6)
  lpar1 <- par[1]
  lpar2 <- par[2]
  lpar3 <- par[3]
  lpar4 <- par[4]
  lpar5 <- par[5]
  lpar6 <- par[6]
  gamma1 <- par[7]
  gamma2 <- par[8]
  gamma3 <- par[9]
  gamma4 <- par[10]
  gamma5 <- par[11]
  gamma6 <- par[12]
  zeta1 <- par[13]
  zeta2 <- par[14]
  zeta3 <- par[15]
  zeta4 <- par[16]
  zeta5 <- par[17]
  zeta6 <- par[18]
  logit1 <- lpar1 + gamma1*X[,1]+zeta1*X[,2]
  logit2 <- lpar2 + gamma2*X[,1]+zeta2*X[,2]
  logit3 <- lpar3 + gamma3*X[,1]+zeta3*X[,2]
  logit4 <- lpar4 + gamma4*X[,1]+zeta4*X[,2]
  logit5 <- lpar5 + gamma5*X[,1]+zeta5*X[,2]
  logit6 <- lpar6 + gamma6*X[,1]+zeta6*X[,2]
  Logit<-cbind(logit1,logit2,logit3,logit4,logit5,logit6)   
  P<-invlogit(Logit)
  
  #Set Initial response probabilities to 0
  Pi<-matrix(rep(0,n*C1),n,C1) 
  
  #j=1 and j=C always same expression
  Pi[,1]<-P[,1]
  Pi[,C1]<-1-P[,C1-1]
  for(j in 2:(C1-1)){
    Pi[,j]<-P[,j]-P[,j-1] 
  }
  
  #Log-likelihood:element-wise multiplication
  LL<--sum(I1*log(Pi))
  return(LL)
}

#Linear constraints
#Constraint matrix size 20x18
ui<-cbind(rep(c(-1,0,0,0,0),4),rep(c(1,-1,0,0,0),4),rep(c(0,1,-1,0,0),4),rep(c(0,0,1,-1,0),4),
rep(c(0,0,0,1,-1),4),rep(c(0,0,0,0,1),4),
c(0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,-1,0,0,0,0),
c(0,0,0,0,0,1,-1,0,0,0,0,0,0,0,0,1,-1,0,0,0),
c(0,0,0,0,0,0,1,-1,0,0,0,0,0,0,0,0,1,-1,0,0),
c(0,0,0,0,0,0,0,1,-1,0,0,0,0,0,0,0,0,1,-1,0),
c(0,0,0,0,0,0,0,0,1,-1,0,0,0,0,0,0,0,0,1,-1),
c(0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1),
c(0,0,0,0,0,0,0,0,0,0,-1,0,0,0,0,-1,0,0,0,0),
c(0,0,0,0,0,0,0,0,0,0,1,-1,0,0,0,1,-1,0,0,0),
c(0,0,0,0,0,0,0,0,0,0,0,1,-1,0,0,0,1,-1,0,0),
c(0,0,0,0,0,0,0,0,0,0,0,0,1,-1,0,0,0,1,-1,0),
c(0,0,0,0,0,0,0,0,0,0,0,0,0,1,-1,0,0,0,1,-1),
c(0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1))

#Constraint vector size 20
ci<-rep(0,20) 
#Starting values size 18
start<-c(0.1,0.2,0.3,0.4,0.5,0.6,0.3,0.8,0.9,1.0,1.1,1.2,0.3,1.4,1.5,1.6,1.7,1.8) 

#Check that they satisfy the constraints (all positive)
ui%*%start

#Optimisation using constrOptim
#theta:numeric (vector) starting value (of length p): must be in the feasible region.
#ui:constraint matrix (k x p), see below.
#ci:constraint vector of length k
optimPPO1<-constrOptim(theta=start,f=LL3,ui=ui,ci=ci,data=melt_select_data,method="Nelder-Mead")
#Assess whether it is a global optimal value
optimPPO2<-constrOptim(theta=optimPPO1$par,f=LL3,ui=ui,ci=ci,data=melt_select_data,method="Nelder-Mead")
optimPPO3<-constrOptim(theta=optimPPO2$par,f=LL3,ui=ui,ci=ci,data=melt_select_data,method="Nelder-Mead")
optimPPO4<-constrOptim(theta=optimPPO3$par,f=LL3,ui=ui,ci=ci,data=melt_select_data,method="Nelder-Mead")
optimPPO5<-constrOptim(theta=optimPPO4$par,f=LL3,ui=ui,ci=ci,data=melt_select_data,method="Nelder-Mead")
optimPPO6<-constrOptim(theta=optimPPO5$par,f=LL3,ui=ui,ci=ci,data=melt_select_data,method="Nelder-Mead")
optimPPO7<-constrOptim(theta=optimPPO6$par,f=LL3,ui=ui,ci=ci,data=melt_select_data,method="Nelder-Mead")
optimPPO8<-constrOptim(theta=optimPPO7$par,f=LL3,ui=ui,ci=ci,data=melt_select_data,method="Nelder-Mead")
optimPPO9<-constrOptim(theta=optimPPO8$par,f=LL3,ui=ui,ci=ci,data=melt_select_data,method="Nelder-Mead")
optimPPO10<-constrOptim(theta=optimPPO9$par,f=LL3,ui=ui,ci=ci,data=melt_select_data,method="Nelder-Mead")
optimPPO11<-constrOptim(theta=optimPPO10$par,f=LL3,ui=ui,ci=ci,data=melt_select_data,method="Nelder-Mead")
optimPPO12<-constrOptim(theta=optimPPO11$par,f=LL3,ui=ui,ci=ci,data=melt_select_data,method="Nelder-Mead")
optimPPO13<-constrOptim(theta=optimPPO12$par,f=LL3,ui=ui,ci=ci,data=melt_select_data,method="Nelder-Mead")
optimPPO14<-constrOptim(theta=optimPPO13$par,f=LL3,ui=ui,ci=ci,data=melt_select_data,method="Nelder-Mead")
optimPPO15<-constrOptim(theta=optimPPO14$par,f=LL3,ui=ui,ci=ci,data=melt_select_data,method="Nelder-Mead")
optimPPO16<-constrOptim(theta=optimPPO15$par,f=LL3,ui=ui,ci=ci,data=melt_select_data,method="Nelder-Mead")
optimPPO17<-constrOptim(theta=optimPPO16$par,f=LL3,ui=ui,ci=ci,data=melt_select_data,method="Nelder-Mead")
optimPPO18<-constrOptim(theta=optimPPO17$par,f=LL3,ui=ui,ci=ci,data=melt_select_data,method="Nelder-Mead")
optimPPO19<-constrOptim(theta=optimPPO18$par,f=LL3,ui=ui,ci=ci,data=melt_select_data,method="Nelder-Mead")
optimPPO20<-constrOptim(theta=optimPPO19$par,f=LL3,ui=ui,ci=ci,data=melt_select_data,method="Nelder-Mead")
optimPPO21<-constrOptim(theta=optimPPO20$par,f=LL3,ui=ui,ci=ci,data=melt_select_data,method="Nelder-Mead")
optimPPO22<-constrOptim(theta=optimPPO21$par,f=LL3,ui=ui,ci=ci,data=melt_select_data,method="Nelder-Mead")
optimPPO23<-constrOptim(theta=optimPPO22$par,f=LL3,ui=ui,ci=ci,data=melt_select_data,method="Nelder-Mead")

optim_PPO_final<-c(optimPPO1$value,optimPPO2$value,optimPPO3$value,optimPPO4$value,optimPPO5$value,optimPPO6$value,optimPPO7$value,optimPPO8$value,optimPPO9$value,optimPPO10$value,optimPPO11$value,optimPPO12$value,optimPPO13$value,optimPPO14$value,optimPPO15$value,optimPPO16$value,optimPPO17$value,optimPPO18$value,optimPPO19$value,optimPPO20$value,optimPPO21$value,optimPPO22$value,optimPPO23$value)
plot(optim_PPO_final)

LL3(par=start,data=melt_select_data)

#AIC=2p-2logLik
2*length(fitPO@coefficients)+2*optimPPO23$value

############################################################################################
#################
# 1+CNS*+Cat
#################

fitPO<-vglm(as.ordered(value) ~ CNS+Category, data= melt_select_data,family=cumulative(parallel=TRUE~CNS+Category))
fitPPOCNS<-vglm(as.ordered(value) ~ CNS+Category, data= melt_select_data,family=cumulative(parallel=FALSE~CNS))
invlogit<-function(x){1/(1+exp(-x))}

#Standardise covariates
CNS.min <- 1
CNS.max <- 3
Category.min <- 1
Category.max <- 2
melt_select_data$CNS.sc <- (melt_select_data$CNS-CNS.min)/(CNS.max-CNS.min)
melt_select_data$Category.sc <- (dat$Category-Category.min)/(Category.max-Category.min)
#Reparameterisation
LL3 <- function(par,data)
{
  Y <- as.ordered(data[,4])
  X <- cbind(data[,2],data[,3])
  n <- length(Y)
  C1 <- nlevels(as.ordered(Y))
  
  #Indicator matrix 
  I1 <- matrix(rep(0,n*C1),n,C1)
  I1[cbind(1:n,Y)] <- 1
  
  #Calculate cumulative probabilities P(Y<=1), P(Y <= 2), P(Y <= 3), P(Y <= 4), P(Y <= 5), P(Y <= 6)
  lpar1 <- par[1]
  lpar2 <- par[2]
  lpar3 <- par[3]
  lpar4 <- par[4]
  lpar5 <- par[5]
  lpar6 <- par[6]
  gamma1 <- par[7]
  gamma2 <- par[8]
  gamma3 <- par[9]
  gamma4 <- par[10]
  gamma5 <- par[11]
  gamma6 <- par[12]
  zeta1 <- par[13]
  logit1 <- lpar1 + gamma1*X[,1]+zeta1*X[,2]
  logit2 <- lpar2 + gamma2*X[,1]+zeta1*X[,2]
  logit3 <- lpar3 + gamma3*X[,1]+zeta1*X[,2]
  logit4 <- lpar4 + gamma4*X[,1]+zeta1*X[,2]
  logit5 <- lpar5 + gamma5*X[,1]+zeta1*X[,2]
  logit6 <- lpar6 + gamma6*X[,1]+zeta1*X[,2]
  Logit<-cbind(logit1,logit2,logit3,logit4,logit5,logit6)   
  P<-invlogit(Logit)
  
  #Set Initial response probabilities to 0
  Pi<-matrix(rep(0,n*C1),n,C1) 
  
  #j=1 and j=C always same expression
  Pi[,1]<-P[,1]
  Pi[,C1]<-1-P[,C1-1]
  for(j in 2:(C1-1)){
    Pi[,j]<-P[,j]-P[,j-1] 
  }
  
  #Log-likelihood:element-wise multiplication
  LL<--sum(I1*log(Pi))
  return(LL)
}
#Constraint matrix
ui<-cbind(rep(c(-1,0,0,0,0),2),rep(c(1,-1,0,0,0),2),rep(c(0,1,-1,0,0),2),rep(c(0,0,1,-1,0),2),
rep(c(0,0,0,1,-1),2),rep(c(0,0,0,0,1),2),c(0,0,0,0,0,-1,0,0,0,0),c(0,0,0,0,0,1,-1,0,0,0),
c(0,0,0,0,0,0,1,-1,0,0),c(0,0,0,0,0,0,0,1,-1,0),c(0,0,0,0,0,0,0,0,1,-1),c(0,0,0,0,0,0,0,0,0,1),
rep(0,10))

#Constraint vector
ci<-rep(0,7)
#Starting values
# start<-c(fitPPOPO@coefficients,0,0,0,0,0,0)
start<-c(0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.10,1.11,1.12,0.13) #13 

#Check that they satisfy the constraints (all positive)
ui%*%start

#Optimisation
optimPPO1<-constrOptim(theta=start,f=LL3,ui=ui,ci=ci,data=melt_select_data,method="Nelder-Mead")
optimPPO1$value
LL3(par=start,data=melt_select_data)
#AIC=2p-2logLik
2*length(fitPO@coefficients)+2*optimPPO1$value

############################################################################################
#################
# 1+Cat*
#################

#Data available at: https://www.dropbox.com/s/t52nyhj68rryqqs/melteddata.csv?dl=0
setwd("C:/Users/al41543/Dropbox")
melt_select_data<-read.csv(file="melteddata.csv", header=TRUE, sep=",")
melt_select_data$id<-as.factor(melt_select_data$id)
levels(melt_select_data$Category)<-c("Nature","Shopping")
levels(melt_select_data$CNS)<-c("low","medium","high")
melt_select_data$CNS<-as.factor(melt_select_data$CNS)

#Models
fitPO<-vglm(as.ordered(value) ~ Category, data= melt_select_data,family=cumulative(parallel=TRUE~Category))
fitPPO<-vglm(as.ordered(value) ~ Category, data= melt_select_data,family=cumulative(parallel=FALSE~Category))
invlogit<-function(x){1/(1+exp(-x))}

#Standardise covariates
CNS.min <- 1
CNS.max <- 3
Category.min <- 1
Category.max <- 2
melt_select_data$CNS.sc <- (melt_select_data$CNS-CNS.min)/(CNS.max-CNS.min)
melt_select_data$cCategory.sc <- (melt_select_data$Category-Category.min)/(Category.max-Category.min)
#Reparameterisation
#LL3 <- function(par,z.min,z.max,data)
LL3 <- function(par,data)
{
  Y <- as.ordered(data[,4])
  X <- cbind(data[,2],data[,3])
  n <- length(Y)
  C1 <- nlevels(as.ordered(Y))
  
  #Indicator matrix 
  I1 <- matrix(rep(0,n*C1),n,C1)
  I1[cbind(1:n,Y)] <- 1
  
  #Calculate cumulative probabilities P(Y<=1), P(Y <= 2), P(Y <= 3), P(Y <= 4), P(Y <= 5), P(Y <= 6)
  lpar1 <- par[1]
  lpar2 <- par[2]
  lpar3 <- par[3]
  lpar4 <- par[4]
  lpar5 <- par[5]
  lpar6 <- par[6]
  gamma1 <- par[7]
  gamma2 <- par[8]
  gamma3 <- par[9]
  gamma4 <- par[10]
  gamma5 <- par[11]
  gamma6 <- par[12]
  logit1 <- lpar1 + gamma1*X[,2]
  logit2 <- lpar2 + gamma2*X[,2]
  logit3 <- lpar3 + gamma3*X[,2]
  logit4 <- lpar4 + gamma4*X[,2]
  logit5 <- lpar5 + gamma5*X[,2]
  logit6 <- lpar6 + gamma6*X[,2]
  Logit<-cbind(logit1,logit2,logit3,logit4,logit5,logit6)   
  P<-invlogit(Logit)
  
  #Set Initial response probabilities to 0
  Pi<-matrix(rep(0,n*C1),n,C1) 
  
  #j=1 and j=C always same expression
  Pi[,1]<-P[,1]
  Pi[,C1]<-1-P[,C1-1]
  for(j in 2:(C1-1)){
    Pi[,j]<-P[,j]-P[,j-1] 
  }
  
  #Log-likelihood:element-wise multiplication
  LL<--sum(I1*log(Pi))
  return(LL)
}
#Constraint matrix
ui<-cbind(rep(c(-1,0,0,0,0),2),rep(c(1,-1,0,0,0),2),rep(c(0,1,-1,0,0),2),rep(c(0,0,1,-1,0),2),
rep(c(0,0,0,1,-1),2),rep(c(0,0,0,0,1),2),c(0,0,0,0,0,-1,0,0,0,0),c(0,0,0,0,0,1,-1,0,0,0),
c(0,0,0,0,0,0,1,-1,0,0),c(0,0,0,0,0,0,0,1,-1,0),c(0,0,0,0,0,0,0,0,1,-1),
c(0,0,0,0,0,0,0,0,0,1))

#Constraint vector
ci<-rep(0,10)
#Starting values
start<-c(0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.10,1.11,1.12) #12 

#Check that they satisfy the constraints (all positive)
ui%*%start

#Optimisation
optimPPO1<-constrOptim(theta=start,f=LL3,ui=ui,ci=ci,data=melt_select_data,method="Nelder-Mead") #It works, $value[1]1260.364
#Do I  need to run it next with $par as start, and subsequently until we  reach a stable value?

LL3(par=start,data=melt_select_data)
#-logLik(fitPPO) is not the same value!

optimPPO1$value
LL3(par=start,data=melt_select_data)
#AIC=2p-2logLik
2*length(fitPO@coefficients)+2*optimPPO1$value

#################
# 1+CNS*
#################

#Models
fitPO<-vglm(as.ordered(value) ~ CNS, data= melt_select_data,family=cumulative(parallel=TRUE~CNS))
fitPPO<-vglm(as.ordered(value) ~ CNS, data= melt_select_data,family=cumulative(parallel=FALSE~CNS))
invlogit<-function(x){1/(1+exp(-x))}

#Standardise covariates
CNS.min <- 1
CNS.max <- 3
Category.min <- 1
Category.max <- 2
melt_select_data$CNS.sc <- (melt_select_data$CNS-CNS.min)/(CNS.max-CNS.min)
melt_select_data$cCategory.sc <- (melt_select_data$Category-Category.min)/(Category.max-Category.min)
# Log-likelihood
LL3 <- function(par,data)
{
  Y <- as.ordered(data[,4])
  X <- cbind(data[,2],data[,3])
  n <- length(Y)
  C1 <- nlevels(as.ordered(Y))
  
  #Indicator matrix 
  I1 <- matrix(rep(0,n*C1),n,C1)
  I1[cbind(1:n,Y)] <- 1
  
  #Calculate cumulative probabilities P(Y<=1), P(Y <= 2), P(Y <= 3), P(Y <= 4), P(Y <= 5), P(Y <= 6)
  lpar1 <- par[1]
  lpar2 <- par[2]
  lpar3 <- par[3]
  lpar4 <- par[4]
  lpar5 <- par[5]
  lpar6 <- par[6]
  gamma1 <- par[7]
  gamma2 <- par[8]
  gamma3 <- par[9]
  gamma4 <- par[10]
  gamma5 <- par[11]
  gamma6 <- par[12]
  logit1 <- lpar1 + gamma1*X[,1]
  logit2 <- lpar2 + gamma2*X[,1]
  logit3 <- lpar3 + gamma3*X[,1]
  logit4 <- lpar4 + gamma4*X[,1]
  logit5 <- lpar5 + gamma5*X[,1]
  logit6 <- lpar6 + gamma6*X[,1]
  Logit<-cbind(logit1,logit2,logit3,logit4,logit5,logit6)   
  P<-invlogit(Logit)
  
  #Set Initial response probabilities to 0
  Pi<-matrix(rep(0,n*C1),n,C1) 
  
  #j=1 and j=C always same expression
  Pi[,1]<-P[,1]
  Pi[,C1]<-1-P[,C1-1]
  for(j in 2:(C1-1)){
    Pi[,j]<-P[,j]-P[,j-1] 
  }
  
  #Log-likelihood:element-wise multiplication
  LL<--sum(I1*log(Pi))
  return(LL)
}
#Constraint matrix
ui<-cbind(rep(c(-1,0,0,0,0),2),rep(c(1,-1,0,0,0),2),rep(c(0,1,-1,0,0),2),rep(c(0,0,1,-1,0),2),
rep(c(0,0,0,1,-1),2),rep(c(0,0,0,0,1),2),c(0,0,0,0,0,-1,0,0,0,0),c(0,0,0,0,0,1,-1,0,0,0),
c(0,0,0,0,0,0,1,-1,0,0),c(0,0,0,0,0,0,0,1,-1,0),c(0,0,0,0,0,0,0,0,1,-1),
c(0,0,0,0,0,0,0,0,0,1))

#Constraint vector
ci<-rep(0,10)
#Starting values
start<-c(0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.10,1.11,1.12) #12 

#Check that they satisfy the constraints (all positive)
ui%*%start

#Optimisation
optimPPO1<-constrOptim(theta=start,f=LL3,ui=ui,ci=ci,data=melt_select_data,method="Nelder-Mead") #It works, $value[1] 1179.763
#Do I  need to run it next with $par as start, and subsequently until we  reach a stable value?

LL3(par=start,data=melt_select_data)

#AIC=2p-2logLik

2*length(fitPO@coefficients)+2*optimPPO1$value

#################
# 1+CNS+Cat*
#################
#Standardise covariates
CNS.min <- 1
CNS.max <- 3
Category.min <- 1
Category.max <- 2
melt_select_data$x1.sc <- (melt_select_data$x1-x1.min)/(x1.max-x1.min)
melt_select_data$x2.sc <- (melt_select_data$x2-x2.min)/(x2.max-x2.min)
#Reparameterisation
#LL3 <- function(par,z.min,z.max,data)
LL3 <- function(par,data)
{
  Y <- as.ordered(data[,4])
  X <- cbind(data[,2],data[,3])
  n <- length(Y)
  C1 <- nlevels(as.ordered(Y))
  
  #Indicator matrix 
  I1 <- matrix(rep(0,n*C1),n,C1)
  I1[cbind(1:n,Y)] <- 1
  
  #Calculate cumulative probabilities P(Y<=1), P(Y <= 2), P(Y <= 3), P(Y <= 4), P(Y <= 5), P(Y <= 6)
  lpar1 <- par[1]
  lpar2 <- par[2]
  lpar3 <- par[3]
  lpar4 <- par[4]
  lpar5 <- par[5]
  lpar6 <- par[6]
  gamma1 <- par[7]
  zeta1 <- par[8]
  zeta2 <- par[9]
  zeta3 <- par[10]
  zeta4 <- par[11]
  zeta5 <- par[12]
  zeta6 <- par[13]
  logit1 <- lpar1 + gamma1*X[,1]+zeta1*X[,2]
  logit2 <- lpar2 + gamma1*X[,1]+zeta2*X[,2]
  logit3 <- lpar3 + gamma1*X[,1]+zeta3*X[,2]
  logit4 <- lpar4 + gamma1*X[,1]+zeta4*X[,2]
  logit5 <- lpar5 + gamma1*X[,1]+zeta5*X[,2]
  logit6 <- lpar6 + gamma1*X[,1]+zeta6*X[,2]
  Logit<-cbind(logit1,logit2,logit3,logit4,logit5,logit6)   
  P<-invlogit(Logit)
  
  #Set Initial response probabilities to 0
  Pi<-matrix(rep(0,n*C1),n,C1) 
  
  #j=1 and j=C always same expression
  Pi[,1]<-P[,1]
  Pi[,C1]<-1-P[,C1-1]
  for(j in 2:(C1-1)){
    Pi[,j]<-P[,j]-P[,j-1] 
  }
  
  #Log-likelihood:element-wise multiplication
  LL<--sum(I1*log(Pi))
  return(LL)
}
#Constraint matrix
ui<-cbind(rep(c(-1,0,0,0,0),2),rep(c(1,-1,0,0,0),2),rep(c(0,1,-1,0,0),2),rep(c(0,0,1,-1,0),2),
rep(c(0,0,0,1,-1),2),rep(c(0,0,0,0,1),2),rep(0,10),c(0,0,0,0,0,-1,0,0,0,0),c(0,0,0,0,0,1,-1,0,0,0),
c(0,0,0,0,0,0,1,-1,0,0),c(0,0,0,0,0,0,0,1,-1,0),c(0,0,0,0,0,0,0,0,1,-1),c(0,0,0,0,0,0,0,0,0,1))

#Constraint vector
ci<-rep(0,7)
#Starting values 13
start<-c(0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0,1.1,1.2,1.3)  

#Check that they satisfy the constraints (all positive)
ui%*%start

#Optimisation
optimPPO1<-constrOptim(theta=start,f=LL3,ui=ui,ci=ci,data=melt_select_data,method="Nelder-Mead")
optimPPO1$value
LL3(par=start,data=melt_select_data)
#AIC=2p-2logLik
2*length(fitPO@coefficients)+2*optimPPO1$value

############################################################################################

#############
# 1+CNS+Cat
#############
#Models
fitPO<-vglm(as.ordered(value) ~ CNS+Category, data= melt_select_data,family=cumulative(parallel=TRUE~CNS+Category))
#CROSSING!!!
invlogit<-function(x){1/(1+exp(-x))}

#Standardise covariates
CNS.min <- 1
CNS.max <- 3
Category.min <- 1
Category.max <- 2
melt_select_data$CNS.sc <- (melt_select_data$CNS-CNS.min)/(CNS.max-CNS.min)
melt_select_data$cCategory.sc <- (melt_select_data$Category-Category.min)/(Category.max-Category.min)
#Reparameterisation
#LL3 <- function(par,z.min,z.max,data)
LL3 <- function(par,data)
{
  Y <- as.ordered(data[,4])
  X <- cbind(data[,2],data[,3])
  n <- length(Y)
  C1 <- nlevels(as.ordered(Y))
  
  #Indicator matrix 
  I1 <- matrix(rep(0,n*C1),n,C1)
  I1[cbind(1:n,Y)] <- 1
  
  #Calculate cumulative probabilities P(Y<=1), P(Y <= 2), P(Y <= 3), P(Y <= 4), P(Y <= 5), P(Y <= 6)
  lpar1 <- par[1]
  lpar2 <- par[2]
  lpar3 <- par[3]
  lpar4 <- par[4]
  lpar5 <- par[5]
  lpar6 <- par[6]
  gamma1 <- par[7]
  zeta1<-par[8]
  logit1 <- lpar1 + gamma1*X[,1]+ zeta1*X[,2]
  logit2 <- lpar2 + gamma1*X[,1]+ zeta1*X[,2]
  logit3 <- lpar3 + gamma1*X[,1]+ zeta1*X[,2]
  logit4 <- lpar4 + gamma1*X[,1]+ zeta1*X[,2]
  logit5 <- lpar5 + gamma1*X[,1]+ zeta1*X[,2]
  logit6 <- lpar6 + gamma1*X[,1]+ zeta1*X[,2]
  Logit<-cbind(logit1,logit2,logit3,logit4,logit5,logit6)   
  P<-invlogit(Logit)
  
  #Set Initial response probabilities to 0
  Pi<-matrix(rep(0,n*C1),n,C1) 
  
  #j=1 and j=C always same expression
  Pi[,1]<-P[,1]
  Pi[,C1]<-1-P[,C1-1]
  for(j in 2:(C1-1)){
    Pi[,j]<-P[,j]-P[,j-1] 
  }
  
  #Log-likelihood:element-wise multiplication
  LL<--sum(I1*log(Pi))
  return(LL)
}
#Constraint matrix
ui<-cbind(c(-1,0,0,0,0),c(1,-1,0,0,0),c(0,1,-1,0,0),c(0,0,1,-1,0),c(0,0,0,1,-1),c(0,0,0,0,1),rep(0,5),rep(0,5))

#Constraint vector
ci<-rep(0,5)
#Starting values
start<-c(0.1,0.2,0.3,0.4,0.5,0.6,0,0) 

#Check that they satisfy the constraints (all positive)
ui%*%start

optimPPO1<-constrOptim(theta=start,f=LL3,ui=ui,ci=ci,data=melt_select_data,method="Nelder-Mead")
#$value
#[1] 1047.021

LL3(par=start,data=melt_select_data)
#Log-likelihood
logLik(fitPO)
AIC(fitPO)
optimPPO1$value
LL3(par=start,data=melt_select_data)
#AIC=2p-2logLik
2*length(fitPO@coefficients)+2*optimPPO1$value

################################################################################################

################
# 1+CNS
################
#Models
fitPO<-vglm(as.ordered(value) ~ CNS, data= melt_select_data,family=cumulative(parallel=TRUE~CNS))
#CROSSING!!!
invlogit<-function(x){1/(1+exp(-x))}

#Standardise covariates
CNS.min <- 1
CNS.max <- 3
Category.min <- 1
Category.max <- 2
melt_select_data$CNS.sc <- (melt_select_data$CNS-CNS.min)/(CNS.max-CNS.min)
melt_select_data$cCategory.sc <- (melt_select_data$Category-Category.min)/(Category.max-Category.min)
#Reparameterisation
#LL3 <- function(par,z.min,z.max,data)
LL3 <- function(par,data)
{
  Y <- as.ordered(data[,4])
  X <- cbind(data[,2],data[,3])
  n <- length(Y)
  C1 <- nlevels(as.ordered(Y))
  
  #Indicator matrix 
  I1 <- matrix(rep(0,n*C1),n,C1)
  I1[cbind(1:n,Y)] <- 1
  
  #Calculate cumulative probabilities P(Y<=1), P(Y <= 2), P(Y <= 3), P(Y <= 4), P(Y <= 5), P(Y <= 6)
  lpar1 <- par[1]
  lpar2 <- par[2]
  lpar3 <- par[3]
  lpar4 <- par[4]
  lpar5 <- par[5]
  lpar6 <- par[6]
  gamma1 <- par[7]
  logit1 <- lpar1 + gamma1*X[,1]
  logit2 <- lpar2 + gamma1*X[,1]
  logit3 <- lpar3 + gamma1*X[,1]
  logit4 <- lpar4 + gamma1*X[,1]
  logit5 <- lpar5 + gamma1*X[,1]
  logit6 <- lpar6 + gamma1*X[,1]
  Logit<-cbind(logit1,logit2,logit3,logit4,logit5,logit6)   
  P<-invlogit(Logit)
  
  #Set Initial response probabilities to 0
  Pi<-matrix(rep(0,n*C1),n,C1) 
  
  #j=1 and j=C always same expression
  Pi[,1]<-P[,1]
  Pi[,C1]<-1-P[,C1-1]
  for(j in 2:(C1-1)){
    Pi[,j]<-P[,j]-P[,j-1] 
  }
  
  #Log-likelihood:element-wise multiplication
  LL<--sum(I1*log(Pi))
  return(LL)
}
#Constraint matrix
ui<-cbind(c(-1,0,0,0,0),c(1,-1,0,0,0),c(0,1,-1,0,0),c(0,0,1,-1,0),c(0,0,0,1,-1),c(0,0,0,0,1),rep(0,5))

#Constraint vector
ci<-rep(0,5)
#Starting values
start<-c(0.1,0.2,0.3,0.4,0.5,0.6,0) 

#Check that they satisfy the constraints (all positive)
ui%*%start

optimPPO1<-constrOptim(theta=start,f=LL3,ui=ui,ci=ci,data=melt_select_data,method="Nelder-Mead")
#$value
#[1] 1192.739


LL3(par=start,data=melt_select_data)
#Log-likelihood
logLik(fitPO)
optimPPO1$value
LL3(par=start,data=melt_select_data)
#AIC=2p-2logLik
2*length(fitPO@coefficients)+2*optimPPO1$value

############################################################################################
#########
# 1+Cat
#########
#Models
fitPO<-vglm(as.ordered(value) ~ Category, data= melt_select_data,family=cumulative(parallel=TRUE~Category))
#CROSSING!!!
invlogit<-function(x){1/(1+exp(-x))}

#Standardise covariates
CNS.min <- 1
CNS.max <- 3
Category.min <- 1
Category.max <- 2
melt_select_data$CNS.sc <- (melt_select_data$CNS-CNS.min)/(CNS.max-CNS.min)
melt_select_data$cCategory.sc <- (melt_select_data$Category-Category.min)/(Category.max-Category.min)
#Reparameterisation
#LL3 <- function(par,z.min,z.max,data)
LL3 <- function(par,data)
{
  Y <- as.ordered(data[,4])
  X <- cbind(data[,2],data[,3])
  n <- length(Y)
  C1 <- nlevels(as.ordered(Y))
  
  #Indicator matrix 
  I1 <- matrix(rep(0,n*C1),n,C1)
  I1[cbind(1:n,Y)] <- 1
  
  #Calculate cumulative probabilities P(Y<=1), P(Y <= 2), P(Y <= 3), P(Y <= 4), P(Y <= 5), P(Y <= 6)
  lpar1 <- par[1]
  lpar2 <- par[2]
  lpar3 <- par[3]
  lpar4 <- par[4]
  lpar5 <- par[5]
  lpar6 <- par[6]
  gamma1 <- par[7]
  logit1 <- lpar1 + gamma1*X[,2]
  logit2 <- lpar2 + gamma1*X[,2]
  logit3 <- lpar3 + gamma1*X[,2]
  logit4 <- lpar4 + gamma1*X[,2]
  logit5 <- lpar5 + gamma1*X[,2]
  logit6 <- lpar6 + gamma1*X[,2]
  Logit<-cbind(logit1,logit2,logit3,logit4,logit5,logit6)   
  P<-invlogit(Logit)
  
  #Set Initial response probabilities to 0
  Pi<-matrix(rep(0,n*C1),n,C1) 
  
  #j=1 and j=C always same expression
  Pi[,1]<-P[,1]
  Pi[,C1]<-1-P[,C1-1]
  for(j in 2:(C1-1)){
    Pi[,j]<-P[,j]-P[,j-1] 
  }
  
  #Log-likelihood:element-wise multiplication
  LL<--sum(I1*log(Pi))
  return(LL)
}
#Constraint matrix
ui<-cbind(c(-1,0,0,0,0),c(1,-1,0,0,0),c(0,1,-1,0,0),c(0,0,1,-1,0),c(0,0,0,1,-1),c(0,0,0,0,1),rep(0,5))

#Constraint vector
ci<-rep(0,5)
#Starting values
start<-c(0.1,0.2,0.3,0.4,0.5,0.6,0) 

#Check that they satisfy the constraints (all positive)
ui%*%start

optimPPO1<-constrOptim(theta=start,f=LL3,ui=ui,ci=ci,data=melt_select_data,method="Nelder-Mead")
#$value
#[1] 1047.037
#Stable value with other starting values and subsequentparameters used

LL3(par=start,data=melt_select_data)
#Log-likelihood
logLik(fitPO)

optimPPO1$value
LL3(par=start,data=melt_select_data)
#AIC=2p-2logLik
2*length(fitPO@coefficients)+2*optimPPO1$value

############################################################################################
#############
# 1
#############
#Models
fitPO<-vglm(as.ordered(value) ~ 1, data= melt_select_data,family=cumulative(parallel=TRUE))
#CROSSING!!!
invlogit<-function(x){1/(1+exp(-x))}

#Standardise covariates
CNS.min <- 1
CNS.max <- 3
Category.min <- 1
Category.max <- 2
melt_select_data$CNS.sc <- (melt_select_data$CNS-CNS.min)/(CNS.max-CNS.min)
melt_select_data$cCategory.sc <- (melt_select_data$Category-Category.min)/(Category.max-Category.min)
#Reparameterisation
#LL3 <- function(par,z.min,z.max,data)
LL3 <- function(par,data)
{
  Y <- as.ordered(data[,4])
  X <- cbind(data[,2],data[,3])
  n <- length(Y)
  C1 <- nlevels(as.ordered(Y))
  
  #Indicator matrix 
  I1 <- matrix(rep(0,n*C1),n,C1)
  I1[cbind(1:n,Y)] <- 1
  
  #Calculate cumulative probabilities P(Y<=1), P(Y <= 2), P(Y <= 3), P(Y <= 4), P(Y <= 5), P(Y <= 6)
  lpar1 <- par[1]
  lpar2 <- par[2]
  lpar3 <- par[3]
  lpar4 <- par[4]
  lpar5 <- par[5]
  lpar6 <- par[6]
  logit1 <- lpar1 
  logit2 <- lpar2 
  logit3 <- lpar3 
  logit4 <- lpar4 
  logit5 <- lpar5 
  logit6 <- lpar6 
  Logit<-cbind(logit1,logit2,logit3,logit4,logit5,logit6)   
  P<-invlogit(Logit)
  
  #Set Initial response probabilities to 0
  Pi<-matrix(rep(0,n*C1),n,C1) 
  
  #j=1 and j=C always same expression
  Pi[,1]<-P[,1]
  Pi[,C1]<-1-P[,C1-1]
  for(j in 2:(C1-1)){
    Pi[,j]<-P[,j]-P[,j-1] 
  }
  
  #Log-likelihood:element-wise multiplication
  LL<--sum(I1*log(Pi))
  return(LL)
}
#Constraint matrix
ui<-cbind(c(-1,0,0,0,0),c(1,-1,0,0,0),c(0,1,-1,0,0),c(0,0,1,-1,0),c(0,0,0,1,-1),c(0,0,0,0,1))

#Constraint vector
ci<-rep(0,5)
#Starting values
start<-c(0.1,0.2,0.3,0.4,0.5,0.6) 

#Check that they satisfy the constraints (all positive)
ui%*%start

optimPPO1<-constrOptim(theta=start,f=LL3,ui=ui,ci=ci,data=melt_select_data,method="Nelder-Mead")
#$value
#[1] 1192.756

LL3(par=start,data=melt_select_data)
#Log-likelihood
logLik(fitPO)

optimPPO1$value
LL3(par=start,data=melt_select_data)
#AIC=2p-2logLik
2*length(fitPO@coefficients)+2*optimPPO1$value
#############################################################################################
