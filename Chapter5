##################
# Chapter5 - Goodness of fit and residual diagnostics.
##################
# Last update: January 2019
############################
#Residuals properties 
############################
library("tmvtnorm")
library("VGAM")
library("ordinal")
library("rms")
set.seed(977)
######################################################## Function and L-S and D-S residuals definitions are adapted from Liu & Zhang 
# (2018)
### The function used to ordinalize a continous variable
### Ordinal value: 1,2,3...
### Inputs: 
### 1. "z" is a vector to be ordinalized; 
### 2. "threshold" is a vector specifying the cut-off points
### Output: the returned value is also a vector
###############################################################
ordinalize<-function(z,threshold){ 
  oo<-function(zz){
    ordinal.value<-1;index<-1
    while(index<=length(threshold) && zz>threshold[index]) {ordinal.value<-ordinal.value+1;index<-index+1}
    return(ordinal.value)
  }
  return(sapply(z,oo))
}
#########################################################################
### Simulate latent variable Z from a quadratic function of X plus noise
### The ordinal outcome W is obtained by discretizing Z
########################################################################
n<-2000

alpha<-16;beta_1<--8;beta_2<-1
thrd<-c(0,4,8)

X<-rnorm(n,mean=3,sd=2)
#X<-runif(n,1,7)
RES<-rnorm(n)
Z<-alpha+beta_1*X+RES
W<-ordinalize(Z,thrd)
table(W)

#par(mfrow=c(1,2),oma = c(0,0,3,0))
#par(mfrow=c(1,2))
#plot(X,Z,main="(a) Latent variable Z")

################################################################
### Model diagnosis when the model is specified correctly
###############################################################
X_1<-X
model<-vglm(formula=W~X_1,family = cumulative(link =logit,parallel = TRUE))
response<-as.ordered(W)
model_c<-clm(response~X_1,link="logit")
model_l<-orm(response~X_1,x=TRUE,y=TRUE)
model_l2<-orm(response~X_1,x=TRUE,y=TRUE)
#as.numeric(coef(summary(model))[,4][4]) p-value X1
#as.numeric(coef(summary(model))[,4][5]) p-value X2
alpha.hat<--coef(model)[1];beta_1.hat<--coef(model)[3];
thrd.hat<-c(0,coef(model)[2]-coef(model)[1],coef(model)[3]-coef(model)[1])


#Deviance
model<-orm(response~as.numeric(X_1),x=TRUE,y=TRUE)
hist(resid(model, type="deviance"))
#Warning message:
#In residuals.lrm(object = list(freq = c(1407L, 147L, 119L, 327L),  :
#using first intercept and y>=2 to compute residuals or test GOF
#####################################################################################
#####################################################################################
#L-S
#####################################################################################
#####################################################################################

##### Li-Shepherd residual
width<-0.45

model<-vglm(formula=W~X,family = cumulative(link = logit,parallel = TRUE))
alpha.hat<--coef(model)[1];
beta_1.hat<--coef(model)[3];
thrd.hat<-c(0,coef(model)[2]-coef(model)[1],coef(model)[3]-coef(model)[1])


residual.LS<-function(w,x){
cc<-c(-Inf,thrd.hat,Inf)
res<-pnorm(cc[w+1]-(alpha.hat+beta_1.hat*x)+pnorm(cc[w]-(alpha.hat+beta_1.hat*x)))-1
return(res)
}


par(mfrow=c(1,2))
#PO
#model<-orm(response~X_1,x=TRUE,y=TRUE)
#hist(resid(model, type="li.shepherd"),main="",xlab="POM L-S residuals",xlim=c(-1,1))
#abline(v=0,col="red")
#or:
#library(MASS)
#library(PResiduals)
#mod<-polr(response~X_1,method="logistic")
#hist(presid(mod))
#PPO



model<-vglm(formula=W~X,family = cumulative(link = logit,parallel = TRUE))



alpha.hat<--coef(model)[1];beta.hat<--coef(model)[4]
thrd.hat<-c(0,coef(model)[2]-coef(model)[1],coef(model)[3]-coef(model)[1])

residual.LS<-function(w,x){
  cc<-c(-Inf,thrd.hat,Inf)
  res<-pnorm(cc[w+1]-(alpha.hat+beta.hat*x))+pnorm(cc[w]-(alpha.hat+beta.hat*x))-1
  return(res)
}

res.LS<-residual.LS(W,X)
hist(res.LS,main="",xlab="POM L-S residuals",xlim=c(-1,1),ylim=c(0,1500),breaks=c(-1,-0.90,-0.80,-0.70,-0.60,-0.50,-0.40,-0.30,-0.20,-0.10,0,0.10,0.20,0.30,0.40,0.50,0.60,0.70,0.80,0.90,1))
abline(v=0,col="red")

plot(res.LS~W,ylab="POM L-S residuals",xlab="Y")

model2<-vglm(formula=W~X,family = cumulative(link = logit,parallel = FALSE))

alpha.hat<--coef(model2)[1];beta.hat<--coef(model2)[4]
thrd.hat<-c(0,coef(model2)[2]-coef(model2)[1],coef(model2)[3]-coef(model2)[1])

residual.LS<-function(w,x){
  cc<-c(-Inf,thrd.hat,Inf)
  res<-pnorm(cc[w+1]-(alpha.hat+beta.hat*x))+pnorm(cc[w]-(alpha.hat+beta.hat*x))-1
  return(res)
}

res.LS2<-residual.LS(W,X)
hist(res.LS2,main="",xlab="PPOM L-S residuals",xlim=c(-1,1),ylim=c(0,1500),breaks=c(-1,-0.90,-0.80,-0.70,-0.60,-0.50,-0.40,-0.30,-0.20,-0.10,0,0.10,0.20,0.30,0.40,0.50,0.60,0.70,0.80,0.90,1))
abline(v=0,col="red")

plot(res.LS2~W,ylab="PPOM L-S residuals",xlab="Y")
#####################################################################################
#####################################################################################
#D-S
#####################################################################################
#####################################################################################

#POM
model_c<-clm(as.ordered(W)~X_1,link="logit")
#Without as.ordered() Error: response in 'formula' needs to be a factor
#PPOM
model_c2<-clm(as.ordered(W)~X_1,link="logit",nominal=~X_1)
#Without as.ordered() Error: response in 'formula' needs to be a factor
clm.residuals = function(obj) {
  preds = predict(obj, type="cum.prob")
  residuals = runif(length(preds$cprob1))*(preds$cprob1-preds$cprob2) + preds$cprob2
  return(qnorm(residuals))}


par(mfrow=c(1,2))
#PO
hist(clm.residuals(model_c),main="",xlab="POM D-S residuals",xlim=c(-4,4))
abline(v=0,col="red")
#POM
hist(clm.residuals(model_c2),main="",xlab="PPOM D-S residuals",xlim=c(-4,4))
abline(v=0,col="red")
#Slightly less symmetric, consequence of wrong model or properties don't necessarily hold for PPO?


#####################################################################################
#####################################################################################
#Surrogate
#####################################################################################
#####################################################################################
library(sure)
set.seed(977)
modelpo<-vglm(formula=W~X_1,family = cumulative(link =logit,parallel = TRUE))
modelppo<-vglm(formula=W~X_1,family = cumulative(link =logit,parallel = FALSE))
par(mfrow=c(1,2))
hist(resids(modelpo),xlim=c(-10,10),main="",xlab="POM Surrogate residuals")
abline(v=0,col="red")
hist(resids(modelppo),xlim=c(-10,10),main="",xlab="PPOM Surrogate residuals")
abline(v=0,col="red")
plot(resids(modelpo)~X,ylab="POM surrogate residuals")
plot(resids(modelppo)~X,ylab="PPOM surrogate residuals")



####FROM POM AND PPOM
# Simulate data from both a proportional odds and a non-proportional
# odds population model.  Check how 3 kinds of residuals detect
# non-prop. odds
set.seed(71)
n <- 400
x <- rnorm(n)

par(mfrow=c(2,3))
for(j in 1:2) {     # 1: prop.odds   2: non-prop. odds
  if(j==1) 
    L <- matrix(c(1.4,.4,-.1,-.5,-.9),nrow=n,ncol=5,byrow=TRUE) + x/2 else {
      # Slopes and intercepts for cutoffs of 1:5 :
      slopes <- c(.7,.5,.3,.3,0)
      ints   <- c(2.5,1.2,0,-1.2,-2.5)
      L <- matrix(ints,nrow=n,ncol=5,byrow=TRUE)+
        matrix(slopes,nrow=n,ncol=5,byrow=TRUE)*x
    }
  p <- plogis(L)
  # Cell probabilities
  p <- cbind(1-p[,1],p[,1]-p[,2],p[,2]-p[,3],p[,3]-p[,4],p[,4]-p[,5],p[,5])
  # Cumulative probabilities from left to right
  cp  <- matrix(cumsum(t(p)) - rep(0:(n-1), rep(6,n)), byrow=TRUE, ncol=6)
  y   <- (cp < runif(n)) %*% rep(1,6)
  
  
  f <- lrm(y ~ x, x=TRUE, y=TRUE)
  for(cutoff in 1:5)print(lrm(y>=cutoff ~ x)$coef)
  
  
  print(resid(f,'gof'))
  resid(f, 'score', pl=TRUE)
  # Note that full ordinal model score residuals exhibit a
  # U-shaped pattern even under prop. odds
  ti <- if(j==2) 'Non-Proportional Odds\nSlopes=.7 .5 .3 .3 0' else
    'True Proportional Odds\nOrdinal Model Score Residuals'
  title(ti)
  resid(f, 'score.binary', pl=TRUE)
  if(j==1) ti <- 'True Proportional Odds\nBinary Score Residuals'
  title(ti)
  resid(f, 'partial', pl=TRUE)
  if(j==1) ti <- 'True Proportional Odds\nPartial Residuals'
  title(ti)
}
par(mfrow=c(1,1))

#Histograms of residuals 
par(mfrow=c(2,3))
#L-S residuals POM
hist(res.LS,main="",xlab="POM L-S residuals",xlim=c(-1,1),ylim=c(0,1500),breaks=c(-1,-0.90,-0.80,-0.70,-0.60,-0.50,-0.40,-0.30,-0.20,-0.10,0,0.10,0.20,0.30,0.40,0.50,0.60,0.70,0.80,0.90,1),cex.axis=1.5,cex.lab=1.5)
abline(v=0,col="red")
#D-S residuals POM
hist(clm.residuals(model_c),main="",xlab="POM D-S residuals",xlim=c(-4,4),cex.axis=1.5,cex.lab=1.5)
abline(v=0,col="red")
#Surrogate residuals POM
hist(resids(modelpo),xlim=c(-10,10),main="",xlab="POM Surrogate residuals",cex.axis=1.5,cex.lab=1.5)
abline(v=0,col="red")
#L-S residuals PPOM
hist(res.LS2,main="",xlab="PPOM L-S residuals",xlim=c(-1,1),ylim=c(0,1500),breaks=c(-1,-0.90,-0.80,-0.70,-0.60,-0.50,-0.40,-0.30,-0.20,-0.10,0,0.10,0.20,0.30,0.40,0.50,0.60,0.70,0.80,0.90,1),cex.axis=1.5,cex.lab=1.5)
abline(v=0,col="red")
#D-S residuals PPOM
hist(clm.residuals(model_c2),main="",xlab="PPOM D-S residuals",xlim=c(-4,4),cex.axis=1.5,cex.lab=1.5)
abline(v=0,col="red")
#Surrogate residuals PPOM
hist(resids(modelppo),xlim=c(-10,10),main="",xlab="PPOM Surrogate residuals",cex.axis=1.5,cex.lab=1.5)
abline(v=0,col="red")

#Plots Resids vs Y
par(mfrow=c(2,3))
plot(res.LS~W,ylab="POM L-S residuals",xlab="Y",cex.axis=1.5,cex.lab=1.5)
abline(h=mean(res.LS),col="red")
plot(clm.residuals(model_c)~W,main="",ylab="POM D-S residuals",xlab="Y",cex.axis=1.5,cex.lab=1.5)
plot(resids(modelpo)~W,ylab="POM Surrogate residuals",xlab="Y",cex.axis=1.5,cex.lab=1.5)
plot(res.LS2~W,ylab="PPOM L-S residuals",xlab="Y",cex.axis=1.5,cex.lab=1.5)
plot(clm.residuals(model_c2)~W,main="",ylab="PPOM D-S residuals",xlab="Y",cex.axis=1.5,cex.lab=1.5)
plot(resids(modelppo)~W,ylab="PPOM Surrogate residuals",xlab="Y",cex.axis=1.5,cex.lab=1.5)

#Boxplots Resids by Y
par(mfrow=c(2,3))
boxplot(res.LS~W,ylab="POM L-S residuals",xlab="Y",cex.axis=1.5,cex.lab=1.5,ylim=c(-1,1),yaxt="n")
axis(2,at=c(-1,-0.5,0,0.5,1),labels=c(-1,-0.5,0,0.5,1),cex.lab=1.5,cex.axis=1.5)
boxplot(clm.residuals(model_c)~W,main="",ylab="POM D-S residuals",xlab="Y",cex.axis=1.5,cex.lab=1.5,ylim=c(-5,5),yaxt="n")
axis(2,at=c(-4,-2,0,2,4),labels=c(-4,-2,0,2,4),cex.lab=1.5,cex.axis=1.5)
boxplot(resids(modelpo)~W,ylab="POM Surrogate residuals",xlab="Y",cex.axis=1.5,cex.lab=1.5,ylim=c(-10,10),yaxt="n")
axis(2,at=c(-10,-5,0,5,10),labels=c(-10,-5,0,5,10),cex.lab=1.5,cex.axis=1.5)
boxplot(res.LS2~W,ylab="PPOM L-S residuals",xlab="Y",cex.axis=1.5,cex.lab=1.5,ylim=c(-1,1),yaxt="n")
axis(2,at=c(-1,-0.5,0,0.5,1),labels=c(-1,-0.5,0,0.5,1),cex.lab=1.5,cex.axis=1.5)
boxplot(clm.residuals(model_c2)~W,main="",ylab="PPOM D-S residuals",xlab="Y",cex.axis=1.5,cex.lab=1.5,ylim=c(-5,5),yaxt="n")
axis(2,at=c(-4,-2,0,2,4),labels=c(-4,-2,0,2,4),cex.lab=1.5,cex.axis=1.5)
boxplot(resids(modelppo)~W,ylab="PPOM Surrogate residuals",xlab="Y",cex.axis=1.5,cex.lab=1.5,ylim=c(-10,10),yaxt="n")
axis(2,at=c(-10,-5,0,5,10),labels=c(-10,-5,0,5,10),cex.lab=1.5,cex.axis=1.5)



LS<-res.LS
DS<-clm.residuals(model_c)
Surrogate<-resids(modelpo)
data_res<-cbind(W,LS,DS,Surrogate)
data_res<-data.frame(data_res)

library(ggpubr)
p1<-ggline(data_res, x = "W",
       combine = TRUE,y=c("LS","DS","Surrogate"),
       ylab = "POM residuals", xlab="Y",
       color = "black",                           
       add = c("mean_sd", "jitter"),
       add.params = list(color = "W", size = 1.0),
       palette = "grey",legend="none",font.x=8,font.y=8,font.legend=8,font.tickslab=8
)
p11<-p1 +theme(strip.text.x = element_text(size = 8))
# + facet_gridlabeller = as_labeller(res_names))
# 
# res_names <- c(
#   `LS` = "L-S  residuals",
#   `DS` = "D-S  residuals",
#   `Surrogate` = "Surrogate residuals"
# )

LS<-res.LS2
DS<-clm.residuals(model_c2)
Surrogate<-resids(modelppo)
data_res<-cbind(W,LS,DS,Surrogate)
data_res<-data.frame(data_res)
p2<-ggline(data_res, x = "W",
          combine = TRUE,y=c("LS","DS","Surrogate"),
          ylab = "PPOM residuals", xlab="Y",
          color = "black",                           
          add = c("mean_sd", "jitter"),
          add.params = list(color = "W", size = 1.0),
          palette = "grey",legend="none",font.x=8,font.y=8,font.legend=8,font.tickslab=8
)
p22<-p2 +theme(strip.text.x = element_text(size = 8))


##################
# Figure 5.1
##############
library(multipanelfigure)
figure1 <- multi_panel_figure(columns = 1, rows = 2, panel_label_type = "none")
# show the layout
figure1

figure1 %<>%
  fill_panel(p11, column = 1, row = 1) %<>%
  fill_panel(p22, column = 1, row = 2) 
figure1
#Figure 5.3
ordinalize<-function(z,threshold){ 
  oo<-function(zz){
    ordinal.value<-1;index<-1
    while(index<=length(threshold) && zz>threshold[index]) {ordinal.value<-ordinal.value+1;index<-index+1}
    return(ordinal.value)
  }
  return(sapply(z,oo))
}
set.seed(5)
# covariate
n<-500
alpha<-16;beta_1<--8;beta_2<-1
thrd<-c(-16,-12,-8,-4)
X<-runif(n,1,7)
RES<-rcauchy(500)
Z<-alpha+beta_1*X+beta_2*(X^2)+RES
W<-ordinalize(Z,thrd)

thrds<-c(-36,-6,34,64)
thrde1<-c(-16,-12,-8,-4)
thrde2<-c(0,4,8,12)
thrdu<-c(-1.5,0,1,3)

Ys<-ordinalize(Z,thrds)
Ye1<-ordinalize(Z,thrde1)
Ye2<-ordinalize(Z,thrde2)
Yu<-ordinalize(Z,thrdu)

par(mar=c(5,5,2,2))
par(mfrow=c(2,3))
plot(Z~X,main="",xlab="X",ylab=expression("Y"^'*'),cex=1.5,cex.lab=1.6,cex.axis=1.5)
hist(Z,main="",xlab=expression("Y"^'*'),cex=1.6,cex.lab=1.6,cex.axis=1.6,ylim=c(0,500),xlim=c(-450,450))
barplot(unlist(table(Ys)),xlab="Y symmetric thresholds",cex=1.6,cex.lab=1.6,cex.axis=1.6,ylim=c(0,500),col="white",xaxt = "n",ylab="Frequency")
axis(side=1,at=c(0.7,1.9,3.1,4.3,5.4),label=c("(-110,-36]","(-36,-6]","(-6,34]","(34,64]","(64,60)"),cex.axis=1.5)
barplot(unlist(table(Ye1)),xlab="Y equidistant thresholds ex. 1",cex=1.6,cex.lab=1.6,cex.axis=1.6,ylim=c(0,500),col="white",xaxt = "n",ylab="Frequency")
axis(side=1,at=c(0.7,1.9,3.1,4.3,5.4),label=c("(-110,-16]","(-16,-12]","(-12,-8]","(-8,-4]","(-4,60)"),cex.axis=1.5)
barplot(unlist(table(Ye2)),xlab="Y equidistant thresholds ex. 2",cex=1.6,cex.lab=1.6,cex.axis=1.6,ylim=c(0,500),col="white",xaxt = "n",ylab="Frequency")
axis(side=1,at=c(0.7,1.9,3.1,4.3,5.4),label=c("(-110,0]","(0,4]","(4,8]","(8,12)","(12,60)"),cex.axis=1.5)
barplot(unlist(table(Yu)),xlab="Y unconstrained thresholds",cex=1.6,cex.lab=1.6,cex.axis=1.6,ylim=c(0,500),col="white",xaxt = "n",ylab="Frequency")
axis(side=1,at=c(0.7,1.9,3.1,4.3,5.4),label=c("(-110,-1.5]","(-1.5,0]","(0,1]","(1,3)","(3,60)"),cex.axis=1.5)

############################
# Figure 5.4
############################
n<=500
set.seed(123)
x<-runif(n,1,7)
# Simulate data from a quadratic regression model whose residuals are Normally
# distributed with standard deviation 12
mu<-16-8*x+1*x*x
z<-1.2*rnorm(100)
y<-mu+z
# true latent continuous response
#ordinal variable
ycs <- factor(cut(y,c(-1000,-2,0,2,1000)),labels=1:4)
yce <- factor(cut(y,c(-1000,0,4,8,1000)),labels=1:4)
ycu <- factor(cut(y,c(-1000,-1,2,9,1000)),labels=1:4)

#Plot quadratic latent and ordinal response
par(mfrow=c(2,2))
#font size 1.1 for mac, 1.5 for pc
plot(y~x,xlab="X",ylab=expression("Y"^'*'),cex=1.1,cex.main=1.1,cex.lab=1.1,cex.axis=1.1)
plot(ycs,ylab="Frequency",xlab="Y symmetric thresholds",ylim=c(0,300),xaxt='n',cex=1.1,cex.main=1.1,cex.lab=1.1,cex.axis=1.1,col="white")
axis(side=1,at=c(0.7,1.95,3.1,4.3),labels=c("(-3,-2]","(-2,0]","(0,2]","(2,11)"),cex=1.1,cex.main=1.1,cex.lab=1.1,cex.axis=1.1)
plot(yce,ylab="Frequency",xlab="Y equidistant thresholds",ylim=c(0,300),xaxt='n',cex=1.1,cex.main=1.1,cex.lab=1.1,cex.axis=1.1,col="white")
axis(side=1,at=c(0.7,1.95,3.1,4.3),labels=c("(-3,0]","(0,4]","(4,8]","(8,11)"),cex=1.1,cex.main=1.1,cex.lab=1.1,cex.axis=1.1)
plot(ycu,ylab="Frequency",xlab="Y unconstrained thresholds",ylim=c(0,300),xaxt='n',cex=1.1,cex.main=1.1,cex.lab=1.1,cex.axis=1.1,col="white")
axis(side=1,at=c(0.7,1.95,3.1,4.3),labels=c("(-3,-1]","(-1,2]","(2,9]","(9,11)"),cex=1.1,cex.main=1.1,cex.lab=1.1,cex.axis=1.1)

############################
#Figures 5.2, 5.6, 5.9 and 5.10
############################
library("tmvtnorm")
library("VGAM")
library("ordinal")
library("rms")
set.seed(977)
######################################################## Function and L-S and D-S residuals definitions are adapted from Liu & Zhang 
# (2018)
### The function used to ordinalize a continous variable
### Ordinal value: 1,2,3...
### Inputs: 
### 1. "z" is a vector to be ordinalized; 
### 2. "threshold" is a vector specifying the cut-off points
### Output: the returned value is also a vector
###############################################################
ordinalize<-function(z,threshold){ 
  oo<-function(zz){
    ordinal.value<-1;index<-1
    while(index<=length(threshold) && zz>threshold[index]) {ordinal.value<-ordinal.value+1;index<-index+1}
    return(ordinal.value)
  }
  return(sapply(z,oo))
}
#########################################################################
### Simulate latent variable Z from a quadratic function of X plus noise
### The ordinal outcome W is obtained by discretizing Z
########################################################################
n<-2000

alpha<-16;beta_1<--8;beta_2<-1
thrd<-c(0,4,8)

X<-rnorm(n,mean=3,sd=2)
#X<-runif(n,1,7)
RES<-rnorm(n)
Z<-alpha+beta_1*X+RES
W<-ordinalize(Z,thrd)
table(W)

#par(mfrow=c(1,2),oma = c(0,0,3,0))
#par(mfrow=c(1,2))
#plot(X,Z,main="(a) Latent variable Z")

################################################################
### Model diagnosis when the model is specified correctly
###############################################################
X_1<-X
model<-vglm(formula=W~X_1,family = cumulative(link =logit,parallel = TRUE))
response<-as.ordered(W)
model_c<-clm(response~X_1,link="logit")
model_l<-orm(response~X_1,x=TRUE,y=TRUE)
model_l2<-orm(response~X_1,x=TRUE,y=TRUE)
#as.numeric(coef(summary(model))[,4][4]) p-value X1
#as.numeric(coef(summary(model))[,4][5]) p-value X2
alpha.hat<--coef(model)[1];beta_1.hat<--coef(model)[3];
thrd.hat<-c(0,coef(model)[2]-coef(model)[1],coef(model)[3]-coef(model)[1])


#Deviance
model<-orm(response~as.numeric(X_1),x=TRUE,y=TRUE)
hist(resid(model, type="deviance"))
#Warning message:
#In residuals.lrm(object = list(freq = c(1407L, 147L, 119L, 327L),  :
#using first intercept and y>=2 to compute residuals or test GOF
#####################################################################################
#####################################################################################
#L-S
#####################################################################################
#####################################################################################

##### Li-Shepherd residual
width<-0.45

model<-vglm(formula=W~X,family = cumulative(link = logit,parallel = TRUE))
alpha.hat<--coef(model)[1];
beta_1.hat<--coef(model)[3];
thrd.hat<-c(0,coef(model)[2]-coef(model)[1],coef(model)[3]-coef(model)[1])


residual.LS<-function(w,x){
cc<-c(-Inf,thrd.hat,Inf)
res<-pnorm(cc[w+1]-(alpha.hat+beta_1.hat*x)+pnorm(cc[w]-(alpha.hat+beta_1.hat*x)))-1
return(res)
}


par(mfrow=c(1,2))
#PO
#model<-orm(response~X_1,x=TRUE,y=TRUE)
#hist(resid(model, type="li.shepherd"),main="",xlab="POM L-S residuals",xlim=c(-1,1))
#abline(v=0,col="red")
#or:
#library(MASS)
#library(PResiduals)
#mod<-polr(response~X_1,method="logistic")
#hist(presid(mod))
#PPO



model<-vglm(formula=W~X,family = cumulative(link = logit,parallel = TRUE))



alpha.hat<--coef(model)[1];beta.hat<--coef(model)[4]
thrd.hat<-c(0,coef(model)[2]-coef(model)[1],coef(model)[3]-coef(model)[1])

residual.LS<-function(w,x){
  cc<-c(-Inf,thrd.hat,Inf)
  res<-pnorm(cc[w+1]-(alpha.hat+beta.hat*x))+pnorm(cc[w]-(alpha.hat+beta.hat*x))-1
  return(res)
}

res.LS<-residual.LS(W,X)
hist(res.LS,main="",xlab="POM L-S residuals",xlim=c(-1,1),ylim=c(0,1500),breaks=c(-1,-0.90,-0.80,-0.70,-0.60,-0.50,-0.40,-0.30,-0.20,-0.10,0,0.10,0.20,0.30,0.40,0.50,0.60,0.70,0.80,0.90,1))
abline(v=0,col="red")

plot(res.LS~W,ylab="POM L-S residuals",xlab="Y")

model2<-vglm(formula=W~X,family = cumulative(link = logit,parallel = FALSE))

alpha.hat<--coef(model2)[1];beta.hat<--coef(model2)[4]
thrd.hat<-c(0,coef(model2)[2]-coef(model2)[1],coef(model2)[3]-coef(model2)[1])

residual.LS<-function(w,x){
  cc<-c(-Inf,thrd.hat,Inf)
  res<-pnorm(cc[w+1]-(alpha.hat+beta.hat*x))+pnorm(cc[w]-(alpha.hat+beta.hat*x))-1
  return(res)
}

res.LS2<-residual.LS(W,X)
hist(res.LS2,main="",xlab="PPOM L-S residuals",xlim=c(-1,1),ylim=c(0,1500),breaks=c(-1,-0.90,-0.80,-0.70,-0.60,-0.50,-0.40,-0.30,-0.20,-0.10,0,0.10,0.20,0.30,0.40,0.50,0.60,0.70,0.80,0.90,1))
abline(v=0,col="red")

plot(res.LS2~W,ylab="PPOM L-S residuals",xlab="Y")
#####################################################################################
#####################################################################################
#D-S
#####################################################################################
#####################################################################################

#POM
model_c<-clm(as.ordered(W)~X_1,link="logit")
#Without as.ordered() Error: response in 'formula' needs to be a factor
#PPOM
model_c2<-clm(as.ordered(W)~X_1,link="logit",nominal=~X_1)
#Without as.ordered() Error: response in 'formula' needs to be a factor
clm.residuals = function(obj) {
  preds = predict(obj, type="cum.prob")
  residuals = runif(length(preds$cprob1))*(preds$cprob1-preds$cprob2) + preds$cprob2
  return(qnorm(residuals))}


par(mfrow=c(1,2))
#PO
hist(clm.residuals(model_c),main="",xlab="POM D-S residuals",xlim=c(-4,4))
abline(v=0,col="red")
#POM
hist(clm.residuals(model_c2),main="",xlab="PPOM D-S residuals",xlim=c(-4,4))
abline(v=0,col="red")
#Slightly less symmetric, consequence of wrong model or properties don't necessarily hold for PPO?


#####################################################################################
#####################################################################################
#Surrogate
#####################################################################################
#####################################################################################
library(sure)
set.seed(977)
modelpo<-vglm(formula=W~X_1,family = cumulative(link =logit,parallel = TRUE))
modelppo<-vglm(formula=W~X_1,family = cumulative(link =logit,parallel = FALSE))
par(mfrow=c(1,2))
hist(resids(modelpo),xlim=c(-10,10),main="",xlab="POM Surrogate residuals")
abline(v=0,col="red")
hist(resids(modelppo),xlim=c(-10,10),main="",xlab="PPOM Surrogate residuals")
abline(v=0,col="red")
plot(resids(modelpo)~X,ylab="POM surrogate residuals")
plot(resids(modelppo)~X,ylab="PPOM surrogate residuals")



####FROM POM AND PPOM
# Simulate data from both a proportional odds and a non-proportional
# odds population model.  Check how 3 kinds of residuals detect
# non-prop. odds
set.seed(71)
n <- 400
x <- rnorm(n)

par(mfrow=c(2,3))
for(j in 1:2) {     # 1: prop.odds   2: non-prop. odds
  if(j==1) 
    L <- matrix(c(1.4,.4,-.1,-.5,-.9),nrow=n,ncol=5,byrow=TRUE) + x/2 else {
      # Slopes and intercepts for cutoffs of 1:5 :
      slopes <- c(.7,.5,.3,.3,0)
      ints   <- c(2.5,1.2,0,-1.2,-2.5)
      L <- matrix(ints,nrow=n,ncol=5,byrow=TRUE)+
        matrix(slopes,nrow=n,ncol=5,byrow=TRUE)*x
    }
  p <- plogis(L)
  # Cell probabilities
  p <- cbind(1-p[,1],p[,1]-p[,2],p[,2]-p[,3],p[,3]-p[,4],p[,4]-p[,5],p[,5])
  # Cumulative probabilities from left to right
  cp  <- matrix(cumsum(t(p)) - rep(0:(n-1), rep(6,n)), byrow=TRUE, ncol=6)
  y   <- (cp < runif(n)) %*% rep(1,6)
  
  
  f <- lrm(y ~ x, x=TRUE, y=TRUE)
  for(cutoff in 1:5)print(lrm(y>=cutoff ~ x)$coef)
  
  

LS<-res.LS
DS<-clm.residuals(model_c)
Surrogate<-resids(modelpo)
data_res<-cbind(W,LS,DS,Surrogate)
data_res<-data.frame(data_res)

library(ggpubr)
p1<-ggline(data_res, x = "W",
       combine = TRUE,y=c("LS","DS","Surrogate"),
       ylab = "POM residuals", xlab="Y",
       color = "black",                           
       add = c("mean_sd", "jitter"),
       add.params = list(color = "W", size = 1.0),
       palette = "grey",legend="none",font.x=8,font.y=8,font.legend=8,font.tickslab=8
)
p11<-p1 +theme(strip.text.x = element_text(size = 8))
# + facet_gridlabeller = as_labeller(res_names))
# 
# res_names <- c(
#   `LS` = "L-S  residuals",
#   `DS` = "D-S  residuals",
#   `Surrogate` = "Surrogate residuals"
# )

LS<-res.LS2
DS<-clm.residuals(model_c2)
Surrogate<-resids(modelppo)
data_res<-cbind(W,LS,DS,Surrogate)
data_res<-data.frame(data_res)
p2<-ggline(data_res, x = "W",
          combine = TRUE,y=c("LS","DS","Surrogate"),
          ylab = "PPOM residuals", xlab="Y",
          color = "black",                           
          add = c("mean_sd", "jitter"),
          add.params = list(color = "W", size = 1.0),
          palette = "grey",legend="none",font.x=8,font.y=8,font.legend=8,font.tickslab=8
)
p22<-p2 +theme(strip.text.x = element_text(size = 8))


library(multipanelfigure)
figure1 <- multi_panel_figure(columns = 1, rows = 2, panel_label_type = "none")
# show the layout
figure1

figure1 %<>%
  fill_panel(p11, column = 1, row = 1) %<>%
  fill_panel(p22, column = 1, row = 2) 
figure1



######################################################################################################
library("tmvtnorm")
library("VGAM")
library("ordinal")
library("rms")
set.seed(977)
######################################################## Function and L-S and D-S residuals definitions are adapted from Liu & Zhang 
# (2018)
### The function used to ordinalize a continous variable
### Ordinal value: 1,2,3...
### Inputs: 
### 1. "z" is a vector to be ordinalized; 
### 2. "threshold" is a vector specifying the cut-off points
### Output: the returned value is also a vector
###############################################################
ordinalize<-function(z,threshold){ 
  oo<-function(zz){
    ordinal.value<-1;index<-1
    while(index<=length(threshold) && zz>threshold[index]) {ordinal.value<-ordinal.value+1;index<-index+1}
    return(ordinal.value)
  }
  return(sapply(z,oo))
}

#########################################################################
### Simulate latent variable Z from a quadratic function of X plus noise
### The ordinal outcome W is obtained by discretizing Z
########################################################################
n<-2000

alpha<-16;beta_1<--8;beta_2<-1
thrd<-c(0,4,8)

X<-rnorm(n,mean=3,sd=2)
#X<-runif(n,1,7)
RES<-rnorm(n)
Z<-alpha+beta_1*X+RES
W<-ordinalize(Z,thrd)
table(W)

#par(mfrow=c(1,2),oma = c(0,0,3,0))
#par(mfrow=c(1,2))
#plot(X,Z,main="(a) Latent variable Z")

################################################################
### Model diagnosis when the model is specified correctly
###############################################################
X_1<-X
model<-vglm(formula=W~X_1,family = cumulative(link =logit,parallel = TRUE))
response<-as.ordered(W)
model_c<-clm(response~X_1,link="logit")
model_l<-orm(response~X_1,x=TRUE,y=TRUE)
model_l2<-orm(response~X_1,x=TRUE,y=TRUE)
#as.numeric(coef(summary(model))[,4][4]) p-value X1
#as.numeric(coef(summary(model))[,4][5]) p-value X2
alpha.hat<--coef(model)[1];beta_1.hat<--coef(model)[3];
thrd.hat<-c(0,coef(model)[2]-coef(model)[1],coef(model)[3]-coef(model)[1])


#Deviance
model<-orm(response~as.numeric(X_1),x=TRUE,y=TRUE)
hist(resid(model, type="deviance"))
#Warning message:
#In residuals.lrm(object = list(freq = c(1407L, 147L, 119L, 327L),  :
#using first intercept and y>=2 to compute residuals or test GOF
#####################################################################################
#####################################################################################
#L-S
#####################################################################################
#####################################################################################

##### Li-Shepherd residual
width<-0.45

model<-vglm(formula=W~X,family = cumulative(link = logit,parallel = TRUE))
alpha.hat<--coef(model)[1];
beta_1.hat<--coef(model)[3];
thrd.hat<-c(0,coef(model)[2]-coef(model)[1],coef(model)[3]-coef(model)[1])


residual.LS<-function(w,x){
cc<-c(-Inf,thrd.hat,Inf)
res<-pnorm(cc[w+1]-(alpha.hat+beta_1.hat*x)+pnorm(cc[w]-(alpha.hat+beta_1.hat*x)))-1
return(res)
}


par(mfrow=c(1,2))
#PO
#model<-orm(response~X_1,x=TRUE,y=TRUE)
#hist(resid(model, type="li.shepherd"),main="",xlab="POM L-S residuals",xlim=c(-1,1))
#abline(v=0,col="red")
#or:
#library(MASS)
#library(PResiduals)
#mod<-polr(response~X_1,method="logistic")
#hist(presid(mod))
#PPO



model<-vglm(formula=W~X,family = cumulative(link = logit,parallel = TRUE))

alpha.hat<--coef(model)[1];beta.hat<--coef(model)[4]
thrd.hat<-c(0,coef(model)[2]-coef(model)[1],coef(model)[3]-coef(model)[1])

residual.LS<-function(w,x){
  cc<-c(-Inf,thrd.hat,Inf)
  res<-pnorm(cc[w+1]-(alpha.hat+beta.hat*x))+pnorm(cc[w]-(alpha.hat+beta.hat*x))-1
  return(res)
}

res.LS<-residual.LS(W,X)
hist(res.LS,main="",xlab="POM L-S residuals",xlim=c(-1,1),ylim=c(0,1500),breaks=c(-1,-0.90,-0.80,-0.70,-0.60,-0.50,-0.40,-0.30,-0.20,-0.10,0,0.10,0.20,0.30,0.40,0.50,0.60,0.70,0.80,0.90,1))
abline(v=0,col="red")

model2<-vglm(formula=W~X,family = cumulative(link = logit,parallel = FALSE))

alpha.hat<--coef(model2)[1];beta.hat<--coef(model2)[4]
thrd.hat<-c(0,coef(model2)[2]-coef(model2)[1],coef(model2)[3]-coef(model2)[1])

residual.LS<-function(w,x){
  cc<-c(-Inf,thrd.hat,Inf)
  res<-pnorm(cc[w+1]-(alpha.hat+beta.hat*x))+pnorm(cc[w]-(alpha.hat+beta.hat*x))-1
  return(res)
}

res.LS2<-residual.LS(W,X)
hist(res.LS2,main="",xlab="PPOM L-S residuals",xlim=c(-1,1),ylim=c(0,1500),breaks=c(-1,-0.90,-0.80,-0.70,-0.60,-0.50,-0.40,-0.30,-0.20,-0.10,0,0.10,0.20,0.30,0.40,0.50,0.60,0.70,0.80,0.90,1))
abline(v=0,col="red")
#####################################################################################
#####################################################################################
#D-S
#####################################################################################
#####################################################################################

#POM
model_c<-clm(as.ordered(W)~X_1,link="logit")
#Without as.ordered() Error: response in 'formula' needs to be a factor
#PPOM
model_c2<-clm(as.ordered(W)~X_1,link="logit",nominal=~X_1)
#Without as.ordered() Error: response in 'formula' needs to be a factor
clm.residuals = function(obj) {
  preds = predict(obj, type="cum.prob")
  residuals = runif(length(preds$cprob1))*(preds$cprob1-preds$cprob2) + preds$cprob2
  return(qnorm(residuals))}


par(mfrow=c(1,2))
#PO
hist(clm.residuals(model_c),main="",xlab="POM D-S residuals",xlim=c(-4,4))
abline(v=0,col="red")
#POM
hist(clm.residuals(model_c2),main="",xlab="PPOM D-S residuals",xlim=c(-4,4))
abline(v=0,col="red")
#Slightly less symmetric, consequence of wrong model or properties don't necessarily hold for PPO?


#####################################################################################
#####################################################################################
#Surrogate
#####################################################################################
#####################################################################################
library(sure)
set.seed(977)
modelpo<-vglm(formula=W~X_1,family = cumulative(link =logit,parallel = TRUE))
modelppo<-vglm(formula=W~X_1,family = cumulative(link =logit,parallel = FALSE))
par(mfrow=c(1,2))
hist(resids(modelpo),xlim=c(-10,10),main="",xlab="POM Surrogate residuals")
abline(v=0,col="red")
hist(resids(modelppo),xlim=c(-10,10),main="",xlab="PPOM Surrogate residuals")
abline(v=0,col="red")
plot(resids(modelpo)~X,ylab="PO surrogate residuals")
plot(resids(modelppo)~X,ylab="PPO surrogate residuals")



####FROM POM AND PPOM
# Simulate data from both a proportional odds and a non-proportional
# odds population model.  Check how 3 kinds of residuals detect
# non-prop. odds
set.seed(71)
n <- 400
x <- rnorm(n)

par(mfrow=c(2,3))
for(j in 1:2) {     # 1: prop.odds   2: non-prop. odds
  if(j==1) 
    L <- matrix(c(1.4,.4,-.1,-.5,-.9),nrow=n,ncol=5,byrow=TRUE) + x/2 else {
      # Slopes and intercepts for cutoffs of 1:5 :
      slopes <- c(.7,.5,.3,.3,0)
      ints   <- c(2.5,1.2,0,-1.2,-2.5)
      L <- matrix(ints,nrow=n,ncol=5,byrow=TRUE)+
        matrix(slopes,nrow=n,ncol=5,byrow=TRUE)*x
    }
  p <- plogis(L)
  # Cell probabilities
  p <- cbind(1-p[,1],p[,1]-p[,2],p[,2]-p[,3],p[,3]-p[,4],p[,4]-p[,5],p[,5])
  # Cumulative probabilities from left to right
  cp  <- matrix(cumsum(t(p)) - rep(0:(n-1), rep(6,n)), byrow=TRUE, ncol=6)
  y   <- (cp < runif(n)) %*% rep(1,6)
  
  
  f <- lrm(y ~ x, x=TRUE, y=TRUE)
  for(cutoff in 1:5)print(lrm(y>=cutoff ~ x)$coef)
  
  
  print(resid(f,'gof'))
  resid(f, 'score', pl=TRUE)
  # Note that full ordinal model score residuals exhibit a
  # U-shaped pattern even under prop. odds
  ti <- if(j==2) 'Non-Proportional Odds\nSlopes=.7 .5 .3 .3 0' else
    'True Proportional Odds\nOrdinal Model Score Residuals'
  title(ti)
  resid(f, 'score.binary', pl=TRUE)
  if(j==1) ti <- 'True Proportional Odds\nBinary Score Residuals'
  title(ti)
  resid(f, 'partial', pl=TRUE)
  if(j==1) ti <- 'True Proportional Odds\nPartial Residuals'
  title(ti)
}
par(mfrow=c(1,1))


##########################################
#CNS case study â€“ Figures 5.24-5.29
##########################################
library(ggplot2)
# [CHANGE THE WORKING DIRECTORY TO WHEREVER THE CSV IS....]
setwd("M:/Personal Sub-Projects/Themes/2010-2015/Theme 8/WP8.3/Tony Craig/Connectednesss to nature")
setwd("~/Dropbox")
melt_select_data<-read.csv(file="melteddata.csv", header=TRUE, sep=",")
head(melt_select_data)
# id = participant id
# CNS = Connectedness to Nature Score [1=Low, 2=MED, 3=HIGH]
# Category = Condition (what category were the responses related to? - Nature or Shopping)
# value = rated pleasantness.
# NOTE - each person gave a pleasantness rating for both categories (Nature and Shopping)
#names(melt_select_data)<-c("id","CNS","Category","value")
melt_select_data$id<-as.factor(melt_select_data$id)
levels(melt_select_data$Category)<-c("Nature","Shopping")
levels(melt_select_data$CNS)<-c("low","medium","high")
melt_select_data$CNS<-as.factor(melt_select_data$CNS)
#
# DRAW GRAPH USING GGPLOT - looking to see if there is an interaction
#
p<-ggplot(melt_select_data, aes(CNS,value,colour=Category))
p + stat_summary(fun.y=median, geom="point") +
  stat_summary(fun.y=median, geom="line", linetype="dotted", aes(group=Category)) +
  stat_summary(fun.data=mean_cl_boot,geom="errorbar", width=0.2) +
  scale_colour_brewer(palette="Set1")+labs (x="Connectedness to Nature", y="Rated pleasantness of experience")
#
# There appears to be an interaction - in the expected direction.
#
# I think this is how to recreate the repeated measures ANOVA that SPSS does, but am not 100% sure....
#aov_model<-aov(value~CNS*Category + Error(id/Category), data=melt_select_data)
aov_model<-aov(value~CNS*Category + Error(id), data=melt_select_data)
summary(aov_model)
# so there is a significant interaction (which was seen visually in the graph)
# But - two questions:
# 1) should I be using a mixed model to do this?, and.....
# 2) I would rather run this as an ordinal model, as pretty much everything else in the paper is reporting paired Wilcoxon tests, but I am not really clear what steps I would need to use to do such a thing.....Any advice would be most appreciated.

#Linear model residuals
model_lm<-lm(value~CNS*Category, data=melt_select_data)
par(mfrow=c(2,2))
plot(model_lm)



library(nlme)
lme.fit <- lme(value~CNS*Category,random=~1|id, data=melt_select_data)
summary(lme.fit)
anova(lme.fit,type="marginal")

library(ordinal)
melt_select_data$facvalue <- as.factor(melt_select_data$value)
clmm.fit <- clmm(facvalue~CNS*Category+(1|id),data=melt_select_data)
summary(clmm.fit)
drop1(clmm.fit,test="Chisq")

clmm.fit <- clmm(facvalue~CNS*Category+(1|id),threshold="symmetric",data=melt_select_data)
summary(clmm.fit)
drop1(clmm.fit,test="Chisq")

clmm1.fit <- clmm(facvalue~CNS*Category+(1|id),data=melt_select_data,start=clmm.fit$optRes$par*0.9)
#gives me an error:  Error: is.numeric(start) && length(start) == (nalpha + nbeta + ntau) is not TRUE


clmm.fit <- clmm(facvalue~CNS*Category+(1|id),nominal=~CNS,threshold="symmetric",data=melt_select_data)
#Error: names(control) %in% names(con) is not all TRUE
clmm.fit <- clmm(facvalue~CNS*Category+(1|id),nominal=~Category,threshold="symmetric",data=melt_select_data)
#Error: names(control) %in% names(con) is not all TRUE
clmm.fit <- clmm(facvalue~CNS*Category+(1|id),nominal=~CNS*Category,threshold="symmetric",data=melt_select_data)
#Error: names(control) %in% names(con) is not all TRUE

library(vgam)
pprom_changereplc<- vglm(as.ordered(v5b_desirable)~as.factor(country)*as.factor(sp)+v6a_attractive+v6b_strong+v6c_valuable+v6d_common+v6e_harmful+v6f_foreign+v5a_changereplc,na.action="na.omit",data_survey3,family = cumulative(parallel=FALSE~v5a_changereplc,reverse=TRUE))
1 - pchisq(deviance(prom) - deviance(pprom_changereplc),df=df.residual(prom)-df.residual(pprom_changereplc))
#A not significant reduction in deviance will mean the proportional odds assumption is true.


#D-S residuals for ordinal model with symmetric thresholds
#FINAL ORDINAL MODEL
attach(melt_select_data)
clm.fit <- clm(facvalue~CNS*Category,nominal=~Category,threshold="symmetric",data=melt_select_data)


#D-S residuals
clm.residuals = function(obj) {
  preds = predict(obj, type="cum.prob")
  residuals = runif(length(preds$cprob1))*(preds$cprob1-preds$cprob2) + preds$cprob2
  return(qnorm(residuals))}

plot(clm.residuals(clm.fit),ylab="D-S residuals")
qqnorm(clm.residuals(clm.fit),main="")
qqline(clm.residuals(clm.fit))

plot(clm.residuals(clm.fit)~Category,xlab="Experience",ylab="D-S residuals")
plot(clm.residuals(clm.fit)~CNS,ylab="D-S residuals")

library(VGAM)
vglm_fit<- vglm(formula=as.ordered(facvalue)~CNS*Category,nominal=~Category,family = cumulative(link =logit,parallel = TRUE),data=melt_select_data)
library(sure)
par(mfrow=c(2,2))
plot(resids(vglm_fit),ylab="Surrogate residuals",cex.lab=1.5)
plot(resids(vglm_fit)~CNS,ylab="Surrogate residuals",xlab="CNS",cex.lab=1.5)
plot(resids(vglm_fit)~Category,ylab="Surrogate residuals",xlab="Experience",cex.lab=1.5)
qqnorm(resids(vglm_fit),xlab="Normal distribution",ylab="Surrogate residuals",main="",cex.lab=1.5)
qqline(resids(vglm_fit),col="red")

#D-S residuals for ordinal model with symmetric thresholds
#FINAL WRONG ORDINAL MODEL - NO INTERACTION
attach(melt_select_data)
clm.fit2 <- clm(facvalue~CNS+Category,nominal=~Category,threshold="symmetric",data=melt_select_data)


#D-S residuals
clm.residuals = function(obj) {
  preds = predict(obj, type="cum.prob")
  residuals = runif(length(preds$cprob1))*(preds$cprob1-preds$cprob2) + preds$cprob2
  return(qnorm(residuals))}

plot(clm.residuals(clm.fit2),ylab="D-S residuals",cex.lab=1.5)
qqnorm(clm.residuals(clm.fit2),main="",cex.lab=1.5)
qqline(clm.residuals(clm.fit2))

plot(clm.residuals(clm.fit2)~Category,xlab="Experience",ylab="D-S residuals",cex.lab=1.5)
plot(clm.residuals(clm.fit2)~CNS,ylab="D-S residuals",cex.lab=1.5)

#Models for interaction, two levels of Category
#Careful with space in name of category!

clm.fit2_N<-clm(facvalue~CNS,threshold="symmetric",data=melt_select_data[melt_select_data$Category=="Nature",],link="logit")
clm.fit2_S<-clm(facvalue~CNS,threshold="symmetric",data=melt_select_data[melt_select_data$Category=="Shopping",],link="logit")

set.seed(1105)
#Surrogate response values
melt_select_data$s<-c(surrogate(clm.fit2_N),surrogate(clm.fit2_S))


library(ggplot2)

ggplot(melt_select_data,aes(x=CNS,y=s))+ stat_summary(fun.x=mean, colour="red", geom="line",aes(group = 1),size=2)+geom_point(color="#444444",shape=19,size=2,alpha=0.5)+facet_wrap(~Category)+ylab("Surrogate response")+xlab("CNS")+theme_bw(base_size = 22)+theme(axis.line = element_line(colour = "black"),
                                                                                                                                                                                                                                   panel.grid.major = element_blank(),
                                                                                                                                                                                                                                   panel.grid.minor = element_blank(),
                                                                                                                                                                                                                                   panel.background = element_blank()) 
plot(resids(clm.fit2,nsim=10000))#Number of bootstrap replicates to use



############
library(VGAM)
vglm_fit<- vglm(formula=as.ordered(facvalue)~CNS*Category,nominal=~Category,family = cumulative(link =logit,parallel = TRUE),data=melt_select_data)
library(sure)
par(mfrow=c(2,2))
plot(resids(vglm_fit),ylab="Surrogate residuals",cex.lab=1.5)
plot(resids(vglm_fit)~CNS,ylab="Surrogate residuals",xlab="CNS",cex.lab=1.5)
plot(resids(vglm_fit)~Category,ylab="Surrogate residuals",xlab="Experience",cex.lab=1.5)
qqnorm(resids(vglm_fit),xlab="Normal distribution",ylab="Surrogate residuals",main="",cex.lab=1.5)
qqline(resids(vglm_fit),col="red")


##################################


#WITHOUT A COVARIATE
clm.fit2 <- clm(facvalue~CNS,nominal=~Category,threshold="symmetric",data=melt_select_data)

qqnorm(clm.residuals(clm.fit2))
qqline(clm.residuals(clm.fit2))

plot(clm.residuals(clm.fit2)~Category)
plot(clm.residuals(clm.fit2)~CNS)

#WITHOUT THE OTHER COVARIATE
clm.fit3 <- clm(facvalue~CNS,nominal=~CNS,threshold="symmetric",data=melt_select_data)

qqnorm(clm.residuals(clm.fit3))
qqline(clm.residuals(clm.fit3))

plot(clm.residuals(clm.fit3)~Category) #boxplots very different to previous
plot(clm.residuals(clm.fit3)~CNS)


####
#Example sure package
library(ordinal)
library(sure)
data(df5)
fit1<-clm(y~x1,data=df5[df5$x2=="Control",],link="probit")
fit2<-clm(y~x1,data=df5[df5$x2=="Treatment",],link="probit")

set.seed(1105)
df5$s<-c(surrogate(fit1),surrogate(fit2))
ggplot(df5,aes(x=x1,y=s))+geom_point(color="#444444",shape=19,size=2,alpha=0.5)+geom_smooth(se=FALSE,size=1.2,color="red2")+facet_wrap(~x2)+ylab("Surrogate response")+xlab(expression(x[1]))



##GAMLSS
#library(GAMLSS)
# data(aids) # fitting a model from a discrete distribution 
# model3<-gamlss(facvalue~CNS+Category,family=LO,data=melt_select_data)
# h<-gamlss(y~pb(x)+qrt, family=NBI, data=aids)
# plot(h)
# # a worm-plot of the medians from 10 realizations
# a<-rqres.plot(h,howmany=2,plot="all",save=TRUE) #vector of the median residuals is saved.
# a[,1]
# a[,2]


set.seed(11)
autoplot(clm.fit2,nsim=10) #bootstrapped
plot(a)
a<-resids(clm.fit2,nsim=10,save=TRUE)
plot(a)
plot(a~CNS)
plot(a~Category)
qqnorm(a)
qqline(a)
#attr(a, "boot.reps") 10 bootstrapped replications
plot(attr(a, "boot.reps"))


#Bootstrapped surrogate residuals
set.seed(101)
autoplot(clm.fit2,nsim=10000) #bootstrapped
plot(resids(clm.fit2,save=TRUE,nsim=100),ylab="Surrogate residuals")
a<-resids(clm.fit2,nsim=10000,save=TRUE)
plot(a)
plot(a~CNS)
plot(a~Category)
qqnorm(a)
qqline(a)


clm_res<-vector("list",5)

for(j in 1:5)
{
  set.seed(j)
  clm.residuals = function(obj) {
    preds = predict(obj, type="cum.prob")
    residuals = runif(length(preds$cprob1))*(preds$cprob1-preds$cprob2) + preds$cprob2
    return(qnorm(residuals))}
  clm_res[[j]]<-clm.residuals(clm.fit2)
}

plot(unlist(clm_res),pch = 19, col = adjustcolor("black", alpha.f = .10))

#vector of i medians (700)
transpose = lapply(1:length(clm_res[[1]]), function(j) sapply(clm_res, "[[", j))
result = sapply(transpose, function(x) median(x))
#plot(result)
qqnorm(result)
qqline(result)

######################################################################################################
######################################################################################################
#SIMULATION STUDY
######################################################################################################
######################################################################################################

### The goal of these simulations is to 
### 1. compare the performance of L-S, D-S and surrogate residuals, and 
### 2. extend work in Liu and Zhang (2018, JASA)
######################################################################################################


############################
# Scenario 1. PO misspecification
############################

#Symmetric thresholds
#(2.5,1.2,0,-1.2,-2.5)

#####################################################################
#####################################################################

# Simulate data from both a proportional odds and a non-proportional
# odds population model.  Check how 3 kinds of residuals detect
# non-prop. odds
library(rms)
library(ordinal)
library(VGAM)
library(sure)
set.seed(71)
n <- 500
x <- rnorm(n)
x1 <- rnorm(n)

par(mfrow=c(2,3))
for(j in 1:2) {     # 1: prop.odds   2: non-prop. odds
  if(j==1) 
    L <- matrix(c(1.4,.4,-.1,-.5,-.9),nrow=n,ncol=5,byrow=TRUE) + x/2 else {
      # Slopes and intercepts for cutoffs of 1:5 :
      slopes <- c(.7,.5,.3,.3,0)
      ints   <- c(2.5,1.2,0,-1.2,-2.5)
      L <- matrix(ints,nrow=n,ncol=5,byrow=TRUE)+
        matrix(slopes,nrow=n,ncol=5,byrow=TRUE)*x
    }
  p <- plogis(L)
  # Cell probabilities
  p <- cbind(1-p[,1],p[,1]-p[,2],p[,2]-p[,3],p[,3]-p[,4],p[,4]-p[,5],p[,5])
  # Cumulative probabilities from left to right
  cp  <- matrix(cumsum(t(p)) - rep(0:(n-1), rep(6,n)), byrow=TRUE, ncol=6)
  y   <- (cp < runif(n)) %*% rep(1,6)
  

  f <- lrm(y ~ x, x=TRUE, y=TRUE)
  for(cutoff in 1:5)print(lrm(y>=cutoff ~ x)$coef)
  
  
  print(resid(f,'gof'))
  resid(f, 'score', pl=TRUE)
  # Note that full ordinal model score residuals exhibit a
  # U-shaped pattern even under prop. odds
  ti <- if(j==2) 'Non-Proportional Odds\nSlopes=.7 .5 .3 .3 0' else
    'True Proportional Odds\nOrdinal Model Score Residuals'
  title(ti,cex=4.5)
  resid(f, 'score.binary', pl=TRUE)
  if(j==1) ti <- 'True Proportional Odds\nBinary Score Residuals'
  title(ti)
  resid(f, 'partial', pl=TRUE)
  if(j==1) ti <- 'True Proportional Odds\nPartial Residuals'
  title(ti)

}
par(mfrow=c(1,1))


set.seed(71)
n <- 500
x1 <- rnorm(n)

par(mfrow=c(2,3))
for(j in 1:2) {     # 1: prop.odds   2: non-prop. odds
  if(j==1) 
    L <- matrix(c(1.4,.4,-.1,-.5,-.9),nrow=n,ncol=5,byrow=TRUE) + x/2 else {
      # Slopes and intercepts for cutoffs of 1:5 :
      slopes <- c(.7,.5,.3,.3,0)
      ints   <- c(2.5,1.2,0,-1.2,-2.5)
      L <- matrix(ints,nrow=n,ncol=5,byrow=TRUE)+
        matrix(slopes,nrow=n,ncol=5,byrow=TRUE)*x
    }
  p <- plogis(L)
  # Cell probabilities
  p <- cbind(1-p[,1],p[,1]-p[,2],p[,2]-p[,3],p[,3]-p[,4],p[,4]-p[,5],p[,5])
  # Cumulative probabilities from left to right
  cp  <- matrix(cumsum(t(p)) - rep(0:(n-1), rep(6,n)), byrow=TRUE, ncol=6)
  y   <- (cp < runif(n)) %*% rep(1,6)
  
  g <- orm(y ~ x1, family=probit, x=TRUE, y=TRUE)
  g.resid <- resid(g)
  f <- lrm(y ~ x1, x=TRUE, y=TRUE)
  for(cutoff in 1:5)print(lrm(y>=cutoff ~ x)$coef)
  h<-clm(as.ordered(y)~x1,link="logit")
  clm.residuals = function(obj) {
    preds = predict(obj, type="cum.prob")
    residuals = runif(length(preds$cprob1))*(preds$cprob1-preds$cprob2) + preds$cprob2
    return(qnorm(residuals))}
  i<-vglm(formula=y~x1,family = cumulative(link =logit,parallel = TRUE))
  
  print(resid(f,'gof'))
  plot(x1, g.resid, cex=0.4,ylab="L-S residuals",xlab="x",xlim=c(-3,3),ylim=c(-1,1),cex.axis=1.5,cex.lab=1.5); lines(lowess(x1, g.resid)); abline(h=0, col=2,lty=2)
  ti <- if(j==2) 'Non-Proportional Odds\nSlopes=.7 .5 .3 .3 0' else
    'True Proportional Odds\nL-S Residuals'
  title(ti,cex.main=1.5)
  plot(clm.residuals(h)~x1,ylab="D-S residuals",xlab="x",xlim=c(-3,3),ylim=c(-4,4),cex.axis=1.5,cex.lab=1.5)
  if(j==1) ti <- 'True Proportional Odds\nD-S Residuals'
  title(ti,cex.main=1.5)
  plot(resids(i)~x1,ylab="Surrogate residuals",xlab="x",xlim=c(-3,3),ylim=c(-7,7),cex.axis=1.5,cex.lab=1.5)
  if(j==1) ti <- 'True Proportional Odds\nSurrogate Residuals'
  title(ti,cex.main=1.5)
}
par(mfrow=c(1,1))

set.seed(71)
n <- 500
x1 <- rnorm(n)

par(mfrow=c(2,3))
for(j in 1:2) {     # 1: prop.odds   2: non-prop. odds
  if(j==1) 
    L <- matrix(c(1.4,.4,-.1,-.5,-.9),nrow=n,ncol=5,byrow=TRUE) + x/2 else {
      # Slopes and intercepts for cutoffs of 1:5 :
      slopes <- c(.7,.5,.3,.3,0)
      ints   <- c(2.5,1.2,0,-1.2,-2.5)
      L <- matrix(ints,nrow=n,ncol=5,byrow=TRUE)+
        matrix(slopes,nrow=n,ncol=5,byrow=TRUE)*x
    }
  p <- plogis(L)
  # Cell probabilities
  p <- cbind(1-p[,1],p[,1]-p[,2],p[,2]-p[,3],p[,3]-p[,4],p[,4]-p[,5],p[,5])
  # Cumulative probabilities from left to right
  cp  <- matrix(cumsum(t(p)) - rep(0:(n-1), rep(6,n)), byrow=TRUE, ncol=6)
  y   <- (cp < runif(n)) %*% rep(1,6)
  
  g <- orm(y ~ x1, family=probit, x=TRUE, y=TRUE)
  g.resid <- resid(g)
  f <- lrm(y ~ x1, x=TRUE, y=TRUE)
  for(cutoff in 1:5)print(lrm(y>=cutoff ~ x)$coef)
  h<-clm(as.ordered(y)~x1,link="logit")
  clm.residuals = function(obj) {
    preds = predict(obj, type="cum.prob")
    residuals = runif(length(preds$cprob1))*(preds$cprob1-preds$cprob2) + preds$cprob2
    return(qnorm(residuals))}
  i<-vglm(formula=y~x1,family = cumulative(link =logit,parallel = TRUE))
  
  print(resid(f,'gof'))
  boxplot(x1, g.resid, cex=0.4,ylab="L-S residuals",xlab="x",cex.axis=1.5,cex.lab=1.5) 
  abline(h=0, col=2,lty=2)
  ti <- if(j==2) 'Non-Proportional Odds\nSlopes=.7 .5 .3 .3 0' else
    'True Proportional Odds\nL-S Residuals'
  title(ti,cex.main=1.5)
  boxplot(clm.residuals(h)~y,ylab="D-S residuals",xlab="y",cex.axis=1.5,cex.lab=1.5,ylim=c(-4,4))
  abline(h=0, col=2,lty=2)
  if(j==1) ti <- 'True Proportional Odds\nD-S Residuals'
  title(ti,cex.main=1.5)
  boxplot(resids(i)~y,ylab="Surrogate residuals",xlab="y",cex.axis=1.5,cex.lab=1.5)
  abline(h=0, col=2,lty=2)
  if(j==1) ti <- 'True Proportional Odds\nSurrogate Residuals'
  title(ti,cex.main=1.5)
}
par(mfrow=c(1,1))

# ########

set.seed(71)
n <- 500
x1 <- rnorm(n)

par(mfrow=c(2,3))
for(j in 1:2) {     # 1: prop.odds   2: non-prop. odds
  if(j==1) 
    L <- matrix(c(1.4,.4,-.1,-.5,-.9),nrow=n,ncol=5,byrow=TRUE) + x/2 else {
      # Slopes and intercepts for cutoffs of 1:5 :
      slopes <- c(.7,.5,.3,.3,0)
      ints   <- c(2.5,1.2,0,-1.2,-2.5)
      L <- matrix(ints,nrow=n,ncol=5,byrow=TRUE)+
        matrix(slopes,nrow=n,ncol=5,byrow=TRUE)*x
    }
  p <- plogis(L)
  # Cell probabilities
  p <- cbind(1-p[,1],p[,1]-p[,2],p[,2]-p[,3],p[,3]-p[,4],p[,4]-p[,5],p[,5])
  # Cumulative probabilities from left to right
  cp  <- matrix(cumsum(t(p)) - rep(0:(n-1), rep(6,n)), byrow=TRUE, ncol=6)
  y   <- (cp < runif(n)) %*% rep(1,6)
  
  g <- orm(y ~ x1, family=probit, x=TRUE, y=TRUE)
  g.resid <- resid(g)
  f <- lrm(y ~ x1, x=TRUE, y=TRUE)
  for(cutoff in 1:5)print(lrm(y>=cutoff ~ x)$coef)
  h<-clm(as.ordered(y)~x1,link="logit")
  clm.residuals = function(obj) {
    preds = predict(obj, type="cum.prob")
    residuals = runif(length(preds$cprob1))*(preds$cprob1-preds$cprob2) + preds$cprob2
    return(qnorm(residuals))}
  i<-vglm(formula=y~x1,family = cumulative(link =logit,parallel = TRUE))
  
  print(resid(f,'gof'))
  qqnorm(g.resid,main="",cex.lab=1.5,ylim=c(-1,1))
  qqline(g.resid,col="red")
  ti <- if(j==2) 'Non-Proportional Odds\nSlopes=.7 .5 .3 .3 0' else
    'True Proportional Odds\nL-S Residuals'
  title(ti)
  qqnorm(clm.residuals(h),ylab="D-S residuals",cex.lab=1.5,main="",ylim=c(-3,3))
  qqline(clm.residuals(h),col="red")
  if(j==1) ti <- 'True Proportional Odds\nD-S Residuals'
  title(ti)
  qqnorm(resids(i),xlab="Normal distribution",ylab="Surrogate residual",main="",cex.lab=1.5,ylim=c(-7,7))
  qqline(resids(i),col="red")
  if(j==1) ti <- 'True Proportional Odds\nSurrogate Residuals'
  title(ti)
}
par(mfrow=c(1,1))

title(xlab="a", ylab="b")
#This adds new labs to resid plot but overimposes
#it, I can't find the way to delete the original ones.
#Score residual plot could be replicated:
library(gplots)
plotmeans(resid(f,'score')[,6]~y)
#Can't plot binary score residuals any other way!ASK HARRELL!
#Partial residuals plot cannot be replicated either
plot(resid(f,'partial'))
length(resid(f,'partial'))

#[1] 2500
#They are not separated as different columns in head! ASK HARRELL!!


#####################################################################
#####################################################################

#Equidistant thresholds
#(3.0,1.5,0,-1.5,-3.0)

#####################################################################
#####################################################################

# Simulate data from both a proportional odds and a non-proportional
# odds population model.  Check how 3 kinds of residuals detect
# non-prop. odds
library(rms)
library(ordinal)
library(VGAM)
library(sure)
set.seed(71)
n <- 500
x <- rnorm(n)
x1 <- rnorm(n)

par(mfrow=c(2,3))
for(j in 1:2) {     # 1: prop.odds   2: non-prop. odds
  if(j==1) 
    L <- matrix(c(1.4,.4,-.1,-.5,-.9),nrow=n,ncol=5,byrow=TRUE) + x/2 else {
      # Slopes and intercepts for cutoffs of 1:5 :
      slopes <- c(.7,.5,.3,.3,0)
      ints   <- c(3.0,1.5,0,-1.5,-3.0)
      L <- matrix(ints,nrow=n,ncol=5,byrow=TRUE)+
        matrix(slopes,nrow=n,ncol=5,byrow=TRUE)*x
    }
  p <- plogis(L)
  # Cell probabilities
  p <- cbind(1-p[,1],p[,1]-p[,2],p[,2]-p[,3],p[,3]-p[,4],p[,4]-p[,5],p[,5])
  # Cumulative probabilities from left to right
  cp  <- matrix(cumsum(t(p)) - rep(0:(n-1), rep(6,n)), byrow=TRUE, ncol=6)
  y   <- (cp < runif(n)) %*% rep(1,6)
  
  
  f <- lrm(y ~ x, x=TRUE, y=TRUE)
  for(cutoff in 1:5)print(lrm(y>=cutoff ~ x)$coef)
  
  
  print(resid(f,'gof'))
  resid(f, 'score', pl=TRUE)
  # Note that full ordinal model score residuals exhibit a
  # U-shaped pattern even under prop. odds
  ti <- if(j==2) 'Non-Proportional Odds\nSlopes=.7 .5 .3 .3 0' else
    'True Proportional Odds\nOrdinal Model Score Residuals'
  title(ti)
  resid(f, 'score.binary', pl=TRUE)
  if(j==1) ti <- 'True Proportional Odds\nBinary Score Residuals'
  title(ti)
  resid(f, 'partial', pl=TRUE)
  if(j==1) ti <- 'True Proportional Odds\nPartial Residuals'
  title(ti)
  
}
par(mfrow=c(1,1))


set.seed(71)
n <- 500
x1 <- rnorm(n)

par(mfrow=c(2,3))
for(j in 1:2) {     # 1: prop.odds   2: non-prop. odds
  if(j==1) 
    L <- matrix(c(1.4,.4,-.1,-.5,-.9),nrow=n,ncol=5,byrow=TRUE) + x/2 else {
      # Slopes and intercepts for cutoffs of 1:5 :
      slopes <- c(.7,.5,.3,.3,0)
      ints   <- c(3.0,1.5,0,-1.5,-3.0)
      L <- matrix(ints,nrow=n,ncol=5,byrow=TRUE)+
        matrix(slopes,nrow=n,ncol=5,byrow=TRUE)*x
    }
  p <- plogis(L)
  # Cell probabilities
  p <- cbind(1-p[,1],p[,1]-p[,2],p[,2]-p[,3],p[,3]-p[,4],p[,4]-p[,5],p[,5])
  # Cumulative probabilities from left to right
  cp  <- matrix(cumsum(t(p)) - rep(0:(n-1), rep(6,n)), byrow=TRUE, ncol=6)
  y   <- (cp < runif(n)) %*% rep(1,6)
  
  g <- orm(y ~ x1, family=probit, x=TRUE, y=TRUE)
  g.resid <- resid(g)
  f <- lrm(y ~ x1, x=TRUE, y=TRUE)
  for(cutoff in 1:5)print(lrm(y>=cutoff ~ x)$coef)
  h<-clm(as.ordered(y)~x1,link="logit")
  clm.residuals = function(obj) {
    preds = predict(obj, type="cum.prob")
    residuals = runif(length(preds$cprob1))*(preds$cprob1-preds$cprob2) + preds$cprob2
    return(qnorm(residuals))}
  i<-vglm(formula=y~x1,family = cumulative(link =logit,parallel = TRUE))
  
  print(resid(f,'gof'))
  plot(x1, g.resid, cex=0.4,ylab="L-S residuals",xlab="x",xlim=c(-3,3),ylim=c(-1,1)); lines(lowess(x1, g.resid)); abline(h=0, col=2,lty=2)
  ti <- if(j==2) 'Non-Proportional Odds\nSlopes=.7 .5 .3 .3 0' else
    'True Proportional Odds\nL-S Residuals'
  title(ti)
  plot(clm.residuals(h)~x1,ylab="D-S residuals",xlab="x",xlim=c(-3,3),ylim=c(-4,4))
  if(j==1) ti <- 'True Proportional Odds\nD-S Residuals'
  title(ti)
  plot(resids(i)~x1,ylab="Surrogate residuals",xlab="x",xlim=c(-3,3),ylim=c(-7,7))
  if(j==1) ti <- 'True Proportional Odds\nSurrogate Residuals'
  title(ti)
}
par(mfrow=c(1,1))


######################################################
#Boxplots
set.seed(71)
n <- 500
x1 <- rnorm(n)

par(mfrow=c(2,3))
for(j in 1:2) {     # 1: prop.odds   2: non-prop. odds
  if(j==1) 
    L <- matrix(c(1.4,.4,-.1,-.5,-.9),nrow=n,ncol=5,byrow=TRUE) + x/2 else {
      # Slopes and intercepts for cutoffs of 1:5 :
      slopes <- c(.7,.5,.3,.3,0)
      ints   <- c(3.0,1.5,0,-1.5,-3.0)
      L <- matrix(ints,nrow=n,ncol=5,byrow=TRUE)+
        matrix(slopes,nrow=n,ncol=5,byrow=TRUE)*x
    }
  p <- plogis(L)
  # Cell probabilities
  p <- cbind(1-p[,1],p[,1]-p[,2],p[,2]-p[,3],p[,3]-p[,4],p[,4]-p[,5],p[,5])
  # Cumulative probabilities from left to right
  cp  <- matrix(cumsum(t(p)) - rep(0:(n-1), rep(6,n)), byrow=TRUE, ncol=6)
  y   <- (cp < runif(n)) %*% rep(1,6)
  
  g <- orm(y ~ x1, family=probit, x=TRUE, y=TRUE)
  g.resid <- resid(g)
  f <- lrm(y ~ x1, x=TRUE, y=TRUE)
  for(cutoff in 1:5)print(lrm(y>=cutoff ~ x)$coef)
  h<-clm(as.ordered(y)~x1,link="logit")
  clm.residuals = function(obj) {
    preds = predict(obj, type="cum.prob")
    residuals = runif(length(preds$cprob1))*(preds$cprob1-preds$cprob2) + preds$cprob2
    return(qnorm(residuals))}
  i<-vglm(formula=y~x1,family = cumulative(link =logit,parallel = TRUE))
  
  print(resid(f,'gof'))
  boxplot(x1, g.resid, cex=0.4,ylab="L-S residuals",xlab="x",cex.axis=1.5,cex.lab=1.5); abline(h=0, col=2,lty=2)
  ti <- if(j==2) 'Non-Proportional Odds\nSlopes=.7 .5 .3 .3 0' else
    'True Proportional Odds\nL-S Residuals'
  title(ti,main.cex=1.5)
  boxplot(clm.residuals(h)~y,ylab="D-S residuals",xlab="y",cex.axis=1.5,cex.lab=1.5); abline(h=0, col=2,lty=2)
  if(j==1) ti <- 'True Proportional Odds\nD-S Residuals'
  title(ti,main.cex=1.5)
  boxplot(resids(i)~y,ylab="Surrogate residuals",xlab="y",cex.axis=1.5,cex.lab=1.5); abline(h=0, col=2,lty=2)
  if(j==1) ti <- 'True Proportional Odds\nSurrogate Residuals'
  title(ti,main.cex=1.5)
}
par(mfrow=c(1,1))

#######################

set.seed(71)
n <- 500
x1 <- rnorm(n)

par(mfrow=c(2,3))
for(j in 1:2) {     # 1: prop.odds   2: non-prop. odds
  if(j==1) 
    L <- matrix(c(1.4,.4,-.1,-.5,-.9),nrow=n,ncol=5,byrow=TRUE) + x/2 else {
      # Slopes and intercepts for cutoffs of 1:5 :
      slopes <- c(.7,.5,.3,.3,0)
      ints   <- c(3.0,1.5,0,-1.5,-3.0)
      L <- matrix(ints,nrow=n,ncol=5,byrow=TRUE)+
        matrix(slopes,nrow=n,ncol=5,byrow=TRUE)*x
    }
  p <- plogis(L)
  # Cell probabilities
  p <- cbind(1-p[,1],p[,1]-p[,2],p[,2]-p[,3],p[,3]-p[,4],p[,4]-p[,5],p[,5])
  # Cumulative probabilities from left to right
  cp  <- matrix(cumsum(t(p)) - rep(0:(n-1), rep(6,n)), byrow=TRUE, ncol=6)
  y   <- (cp < runif(n)) %*% rep(1,6)
  
  g <- orm(y ~ x1, family=probit, x=TRUE, y=TRUE)
  g.resid <- resid(g)
  f <- lrm(y ~ x1, x=TRUE, y=TRUE)
  for(cutoff in 1:5)print(lrm(y>=cutoff ~ x)$coef)
  h<-clm(as.ordered(y)~x1,link="logit")
  clm.residuals = function(obj) {
    preds = predict(obj, type="cum.prob")
    residuals = runif(length(preds$cprob1))*(preds$cprob1-preds$cprob2) + preds$cprob2
    return(qnorm(residuals))}
  i<-vglm(formula=y~x1,family = cumulative(link =logit,parallel = TRUE))
  
  print(resid(f,'gof'))
  qqnorm(g.resid,main="",cex.lab=1.5,ylim=c(-1,1))
  qqline(g.resid,col="red")
  ti <- if(j==2) 'Non-Proportional Odds\nSlopes=.7 .5 .3 .3 0' else
    'True Proportional Odds\nL-S Residuals'
  title(ti)
  qqnorm(clm.residuals(h),ylab="D-S residuals",cex.lab=1.5,main="",ylim=c(-3,3))
  qqline(clm.residuals(h),col="red")
  if(j==1) ti <- 'True Proportional Odds\nD-S Residuals'
  title(ti)
  qqnorm(resids(i),xlab="Normal distribution",ylab="Surrogate residual",main="",cex.lab=1.5,ylim=c(-7,7))
  qqline(resids(i),col="red")
  if(j==1) ti <- 'True Proportional Odds\nSurrogate Residuals'
  title(ti)
}
par(mfrow=c(1,1))

title(xlab="a", ylab="b")
#This adds new labs to resid plot but overimposes
#it, I can't find the way to delete the original ones.
#Score residual plot could be replicated:
library(gplots)
plotmeans(resid(f,'score')[,6]~y)
#Can't plot binary score residuals any other way!ASK HARRELL!
#Partial residuals plot cannot be replicated either
plot(resid(f,'partial'))
length(resid(f,'partial'))

#[1] 2500
#They are not separated as different columns in head! ASK HARRELL!!

#####################################################################
#####################################################################

#Unconstrained thresholds
#(3.0,0.5,0,-1.0,-2.5)

#####################################################################
#####################################################################

# Simulate data from both a proportional odds and a non-proportional
# odds population model.  Check how 3 kinds of residuals detect
# non-prop. odds
library(rms)
library(ordinal)
library(VGAM)
library(sure)
set.seed(71)
n <- 500
x <- rnorm(n)
x1 <- rnorm(n)

par(mfrow=c(2,3))
for(j in 1:2) {     # 1: prop.odds   2: non-prop. odds
  if(j==1) 
    L <- matrix(c(1.4,.4,-.1,-.5,-.9),nrow=n,ncol=5,byrow=TRUE) + x/2 else {
      # Slopes and intercepts for cutoffs of 1:5 :
      slopes <- c(.7,.5,.3,.3,0)
      ints   <- c(3.0,0.5,0,-1.0,-2.5)
      L <- matrix(ints,nrow=n,ncol=5,byrow=TRUE)+
        matrix(slopes,nrow=n,ncol=5,byrow=TRUE)*x
    }
  p <- plogis(L)
  # Cell probabilities
  p <- cbind(1-p[,1],p[,1]-p[,2],p[,2]-p[,3],p[,3]-p[,4],p[,4]-p[,5],p[,5])
  # Cumulative probabilities from left to right
  cp  <- matrix(cumsum(t(p)) - rep(0:(n-1), rep(6,n)), byrow=TRUE, ncol=6)
  y   <- (cp < runif(n)) %*% rep(1,6)
  
  
  f <- lrm(y ~ x, x=TRUE, y=TRUE)
  for(cutoff in 1:5)print(lrm(y>=cutoff ~ x)$coef)
  
  
  print(resid(f,'gof'))
  resid(f, 'score', pl=TRUE)
  # Note that full ordinal model score residuals exhibit a
  # U-shaped pattern even under prop. odds
  ti <- if(j==2) 'Non-Proportional Odds\nSlopes=.7 .5 .3 .3 0' else
    'True Proportional Odds\nOrdinal Model Score Residuals'
  title(ti)
  resid(f, 'score.binary', pl=TRUE)
  if(j==1) ti <- 'True Proportional Odds\nBinary Score Residuals'
  title(ti)
  resid(f, 'partial', pl=TRUE)
  if(j==1) ti <- 'True Proportional Odds\nPartial Residuals'
  title(ti)
  
}
par(mfrow=c(1,1))


set.seed(71)
n <- 500
x1 <- rnorm(n)

par(mfrow=c(2,3))
for(j in 1:2) {     # 1: prop.odds   2: non-prop. odds
  if(j==1) 
    L <- matrix(c(1.4,.4,-.1,-.5,-.9),nrow=n,ncol=5,byrow=TRUE) + x/2 else {
      # Slopes and intercepts for cutoffs of 1:5 :
      slopes <- c(.7,.5,.3,.3,0)
      ints   <- c(3.0,0.5,0,-1.0,-2.5)
      L <- matrix(ints,nrow=n,ncol=5,byrow=TRUE)+
        matrix(slopes,nrow=n,ncol=5,byrow=TRUE)*x
    }
  p <- plogis(L)
  # Cell probabilities
  p <- cbind(1-p[,1],p[,1]-p[,2],p[,2]-p[,3],p[,3]-p[,4],p[,4]-p[,5],p[,5])
  # Cumulative probabilities from left to right
  cp  <- matrix(cumsum(t(p)) - rep(0:(n-1), rep(6,n)), byrow=TRUE, ncol=6)
  y   <- (cp < runif(n)) %*% rep(1,6)
  
  g <- orm(y ~ x1, family=probit, x=TRUE, y=TRUE)
  g.resid <- resid(g)
  f <- lrm(y ~ x1, x=TRUE, y=TRUE)
  for(cutoff in 1:5)print(lrm(y>=cutoff ~ x)$coef)
  h<-clm(as.ordered(y)~x1,link="logit")
  clm.residuals = function(obj) {
    preds = predict(obj, type="cum.prob")
    residuals = runif(length(preds$cprob1))*(preds$cprob1-preds$cprob2) + preds$cprob2
    return(qnorm(residuals))}
  i<-vglm(formula=y~x1,family = cumulative(link =logit,parallel = TRUE))
  
  print(resid(f,'gof'))
  plot(x1, g.resid, cex=0.4,ylab="L-S residuals",xlab="x",xlim=c(-3,3),ylim=c(-1,1)); lines(lowess(x1, g.resid)); abline(h=0, col=2,lty=2)
  ti <- if(j==2) 'Non-Proportional Odds\nSlopes=.7 .5 .3 .3 0' else
    'True Proportional Odds\nL-S Residuals'
  title(ti)
  plot(clm.residuals(h)~x1,ylab="D-S residuals",xlab="x",xlim=c(-3,3),ylim=c(-4,4))
  if(j==1) ti <- 'True Proportional Odds\nD-S Residuals'
  title(ti)
  plot(resids(i)~x1,ylab="Surrogate residuals",xlab="x",xlim=c(-3,3),ylim=c(-7,7))
  if(j==1) ti <- 'True Proportional Odds\nSurrogate Residuals'
  title(ti)
}
par(mfrow=c(1,1))


###################################
#Boxplots

set.seed(71)
n <- 500
x1 <- rnorm(n)

par(mfrow=c(2,3))
for(j in 1:2) {     # 1: prop.odds   2: non-prop. odds
  if(j==1) 
    L <- matrix(c(1.4,.4,-.1,-.5,-.9),nrow=n,ncol=5,byrow=TRUE) + x/2 else {
      # Slopes and intercepts for cutoffs of 1:5 :
      slopes <- c(.7,.5,.3,.3,0)
      ints   <- c(3.0,0.5,0,-1.0,-2.5)
      L <- matrix(ints,nrow=n,ncol=5,byrow=TRUE)+
        matrix(slopes,nrow=n,ncol=5,byrow=TRUE)*x
    }
  p <- plogis(L)
  # Cell probabilities
  p <- cbind(1-p[,1],p[,1]-p[,2],p[,2]-p[,3],p[,3]-p[,4],p[,4]-p[,5],p[,5])
  # Cumulative probabilities from left to right
  cp  <- matrix(cumsum(t(p)) - rep(0:(n-1), rep(6,n)), byrow=TRUE, ncol=6)
  y   <- (cp < runif(n)) %*% rep(1,6)
  
  g <- orm(y ~ x1, family=probit, x=TRUE, y=TRUE)
  g.resid <- resid(g)
  f <- lrm(y ~ x1, x=TRUE, y=TRUE)
  for(cutoff in 1:5)print(lrm(y>=cutoff ~ x)$coef)
  h<-clm(as.ordered(y)~x1,link="logit")
  clm.residuals = function(obj) {
    preds = predict(obj, type="cum.prob")
    residuals = runif(length(preds$cprob1))*(preds$cprob1-preds$cprob2) + preds$cprob2
    return(qnorm(residuals))}
  i<-vglm(formula=y~x1,family = cumulative(link =logit,parallel = TRUE))
  
  print(resid(f,'gof'))
  boxplot(x1, g.resid, cex=0.4,ylab="L-S residuals",xlab="x",cex.axis=1.5,cex.lab=1.5
); abline(h=0, col=2,lty=2)
  ti <- if(j==2) 'Non-Proportional Odds\nSlopes=.7 .5 .3 .3 0' else
    'True Proportional Odds\nL-S Residuals'
  title(ti,main.cex=1.5)
  boxplot(clm.residuals(h)~y,ylab="D-S residuals",xlab="x",cex.axis=1.5,cex.lab=1.5
)
  abline(h=0, col=2,lty=2)
  if(j==1) ti <- 'True Proportional Odds\nD-S Residuals'
  title(ti,main.cex=1.5)
  boxplot(resids(i)~y,ylab="Surrogate residuals",xlab="x",cex.axis=1.5,cex.lab=1.5
)
  abline(h=0, col=2,lty=2)
  if(j==1) ti <- 'True Proportional Odds\nSurrogate Residuals'
  title(ti,main.cex=1.5)
}
par(mfrow=c(1,1))

###################################

set.seed(71)
n <- 500
x1 <- rnorm(n)

par(mfrow=c(2,3))
for(j in 1:2) {     # 1: prop.odds   2: non-prop. odds
  if(j==1) 
    L <- matrix(c(1.4,.4,-.1,-.5,-.9),nrow=n,ncol=5,byrow=TRUE) + x/2 else {
      # Slopes and intercepts for cutoffs of 1:5 :
      slopes <- c(.7,.5,.3,.3,0)
      ints   <- c(3.0,0.5,0,-1.0,-2.5)
      L <- matrix(ints,nrow=n,ncol=5,byrow=TRUE)+
        matrix(slopes,nrow=n,ncol=5,byrow=TRUE)*x
    }
  p <- plogis(L)
  # Cell probabilities
  p <- cbind(1-p[,1],p[,1]-p[,2],p[,2]-p[,3],p[,3]-p[,4],p[,4]-p[,5],p[,5])
  # Cumulative probabilities from left to right
  cp  <- matrix(cumsum(t(p)) - rep(0:(n-1), rep(6,n)), byrow=TRUE, ncol=6)
  y   <- (cp < runif(n)) %*% rep(1,6)
  
  g <- orm(y ~ x1, family=probit, x=TRUE, y=TRUE)
  g.resid <- resid(g)
  f <- lrm(y ~ x1, x=TRUE, y=TRUE)
  for(cutoff in 1:5)print(lrm(y>=cutoff ~ x)$coef)
  h<-clm(as.ordered(y)~x1,link="logit")
  clm.residuals = function(obj) {
    preds = predict(obj, type="cum.prob")
    residuals = runif(length(preds$cprob1))*(preds$cprob1-preds$cprob2) + preds$cprob2
    return(qnorm(residuals))}
  i<-vglm(formula=y~x1,family = cumulative(link =logit,parallel = TRUE))
  
  print(resid(f,'gof'))
  qqnorm(g.resid,main="",cex.lab=1.5,ylim=c(-1,1))
  qqline(g.resid,col="red")
  ti <- if(j==2) 'Non-Proportional Odds\nSlopes=.7 .5 .3 .3 0' else
    'True Proportional Odds\nL-S Residuals'
  title(ti)
  qqnorm(clm.residuals(h),ylab="D-S residuals",cex.lab=1.5,main="",ylim=c(-3,3))
  qqline(clm.residuals(h),col="red")
  if(j==1) ti <- 'True Proportional Odds\nD-S Residuals'
  title(ti)
  qqnorm(resids(i),xlab="Normal distribution",ylab="Surrogate residual",main="",cex.lab=1.5,ylim=c(-7,7))
  qqline(resids(i),col="red")
  if(j==1) ti <- 'True Proportional Odds\nSurrogate Residuals'
  title(ti)
}
par(mfrow=c(1,1))

title(xlab="a", ylab="b")
#This adds new labs to resid plot but overimposes
#it, I can't find the way to delete the original ones.
#Score residual plot could be replicated:
library(gplots)
plotmeans(resid(f,'score')[,6]~y)
#Can't plot binary score residuals any other way!ASK HARRELL!
#Partial residuals plot cannot be replicated either
plot(resid(f,'partial'))
length(resid(f,'partial'))

############################
# Scenario 2. Link misspecification
############################
library(ordinal)
library(rms)
library(VGAM)
library(sure)
###################################
#Simulation 2.1.Cauchy errors
###################################

#####################
#   D-S RESIDUALS   #
#####################

###########################################################################################
###########################################################################################

#(a) Equidistant  example  1 & symmetric (-16,-12,-8,-4)
ordinalize<-function(z,threshold){ 
  oo<-function(zz){
    ordinal.value<-1;index<-1
    while(index<=length(threshold) && zz>threshold[index]) {ordinal.value<-ordinal.value+1;index<-index+1}
    return(ordinal.value)
  }
  return(sapply(z,oo))
}


#############################################################################
#############################################################################

#Probit-Cauchit

clm_res<-vector("list",500)
clm2_res<-vector("list",500)
clm3_res<-vector("list",500)
ls_res<-vector("list",500)
ls2_res<-vector("list",500)
IQR_clm_res<-vector("list",500)
IQR_ls_res<-vector("list",500)
p_value_clm<-vector("list",500)
p_value_ls<-vector("list",500)
p_values_ks<-vector("list",500)
n <- 500
for (i in 1:10000)
{
  set.seed(i)
  # covariate
  n<-500
  
  alpha<-16;beta_1<--8;beta_2<-1
  thrd<-c(-16,-12,-8,-4)

  X<-runif(n,1,7)
  RES<-rcauchy(500)
  
  Z<-alpha+beta_1*X+beta_2*(X^2)+RES
  W<-ordinalize(Z,thrd)
  table(W)
  
  X_1<-X;X_2<-X^2
  
  #CLM models using ordinal - clm
  clmfit <- clm(as.ordered(W-1)~X_1+X_2,link="probit")
  clmfit2<-clm(as.ordered(W-1)~X_1+X_2,link="cauchit")
  clmfit3<-clm(as.ordered(W-1)~X_1+X_2,link="logit")
  par(mfrow=c(1,2))
  
  #D-S residuals
  clm.residuals = function(obj) {
    preds = predict(obj, type="cum.prob")
    residuals = runif(length(preds$cprob1))*(preds$cprob1-preds$cprob2) + preds$cprob2
    return(qnorm(residuals))}
  
  clm_res[[i]]<-clm.residuals(clmfit)
  
  clm2_res[[i]]<-clm.residuals(clmfit2)
  
  clm3_res[[i]]<-clm.residuals(clmfit3)
  
}
#warnings singularity
#Tests of normality
p_value_clm<-vector("list",500)
p_value_clm2<-vector("list",500)
p_value_clm3<-vector("list",500)
p_value_ls<-vector("list",500)
p_value_ls2<-vector("list",500)
st_clm<-vector("list",500)
st_clm2<-vector("list",500)
ks_results<-vector("list",500)
ks1_results<-vector("list",500)
ks2_results<-vector("list",500)
ks_ls_results<-vector("list",500)
ks1_ls_results<-vector("list",500)
ks2_ls_results<-vector("list",500)
p_value_ks<-vector("list",500)
p_value_ks1<-vector("list",500)
p_value_ks2<-vector("list",500)
p_value_ksls<-vector("list",500)
p_value_ks1ls<-vector("list",500)
p_value_ks2ls<-vector("list",500)
for (i in 1:10000)
{
  #shapiro.test tests the NULL hypothesis that the samples came from a Normal distribution.
  shapiro.test(clm_res[[i]])
  
  #p-values from the S-W test
  p_value_clm[[i]]<-shapiro.test(clm_res[[i]])$p.value
  p_value_clm2[[i]]<-shapiro.test(clm2_res[[i]])$p.value
  p_value_clm3[[i]]<-shapiro.test(clm3_res[[i]])$p.value

  #statistic from the S-W test
  st_clm[[i]]<-shapiro.test(clm_res[[i]])$statistic
  st_clm2[[i]]<-shapiro.test(clm2_res[[i]])$statistic
  
  #Kolmogorov-Smirnov test clmfit (probit) & clmfit2 (Cauchit)
  ks_results[[i]]<-ks.test(unlist(clm_res[[i]]),unlist(clm2_res[[i]]))
  #p-values from the K-S test
  p_value_ks[[i]]<-ks_results[[i]]$p.value
}
par(mfrow=c(1,1))
hist(unlist(p_value_ks),main="",xlab="p-values from K-S test for D-S residuals probit-Cauchit",cex.lab=1.5,ylim=c(0,1000))

# Results from Kolmogorv-Smirnov Test. If p>0.05, we  cannot reject  same  distribution.
which(unlist(p_value_ks)>=0.05)
length(which(unlist(p_value_ks)>=0.05))
length(which(unlist(p_value_ks)>=0.05))/10000
#[1] 0.9612

#Normal values - Results from Shapiro-Wilk Normality Test. If p>0.05, we  cannot reject  Null hypothesis Normal distrib.
length(which(p_value_clm>0.05))
length(which(p_value_clm>0.05))/10000
#0.9741
length(which(p_value_clm2>0.05))/10000
#[1] 0.9754
length(which(p_value_clm3>0.05))/10000
#[1] 0.9741

#Empirical cumulative distribution function of p-values from Shapiro-Wilk test
#par(mar=c(4.1,4.1,2.0,1.1))
par(mfrow=c(1,3))
plot(ecdf(unlist(p_value_clm3)),main="Logit link",cex.axis=1.5,cex.main=1.5,cex.lab=1.5)
plot(ecdf(unlist(p_value_clm)),main="Probit link",cex.axis=1.5,cex.main=1.5,cex.lab=1.5)
plot(ecdf(unlist(p_value_clm2)),main="Cauchit link",cex.axis=1.5,cex.main=1.5,cex.lab=1.5)
#These plots should be the same than for Logit-Cauchit


par(mfrow=c(1,3))
qqnorm(unlist(clm3_res[1]),main=" ",cex.main=1.5,cex.lab=1.5,cex.axis=1.5,ylab="Sample  Quantiles logit  POM")
qqnorm(unlist(clm_res[1]),main=" ",cex.main=1.5,cex.lab=1.5,cex.axis=1.5,ylab="Sample  Quantiles probit  POM")
qqnorm(unlist(clm2_res[1]),main=" ",cex.main=1.5,cex.lab=1.5,cex.axis=1.5,ylab="Sample  Quantiles Cauchit  POM")

#############################################################################
#############################################################################

#Logit-Cauchit

clm_res<-vector("list",500)
clm2_res<-vector("list",500)
ls_res<-vector("list",500)
ls2_res<-vector("list",500)
IQR_clm_res<-vector("list",500)
IQR_ls_res<-vector("list",500)
p_value_clm<-vector("list",500)
p_value_ls<-vector("list",500)
n <- 500
for (i in 1:10000)
{
  set.seed(i)
  # covariate
  n<-500
  
  alpha<-16;beta_1<--8;beta_2<-1
  thrd<-c(-16,-12,-8,-4)
  
  X<-runif(n,1,7)
  RES<-rcauchy(500)
  
  Z<-alpha+beta_1*X+beta_2*(X^2)+RES
  W<-ordinalize(Z,thrd)
  table(W)
  
  X_1<-X;X_2<-X^2
  
  #clm models using ordinal - clm
  clmfit <- clm(as.ordered(W-1)~X_1+X_2,link="logit")
  clmfit2<-clm(as.ordered(W-1)~X_1+X_2,link="cauchit")
  clmfit3<-clm(as.ordered(W-1)~X_1+X_2,link="probit")

  #D-S residuals
  clm.residuals = function(obj) {
    preds = predict(obj, type="cum.prob")
    residuals = runif(length(preds$cprob1))*(preds$cprob1-preds$cprob2) + preds$cprob2
    return(qnorm(residuals))}
  
  clm_res[[i]]<-clm.residuals(clmfit)
  
  clm2_res[[i]]<-clm.residuals(clmfit2)
  
  clm3_res[[i]]<-clm.residuals(clmfit2)
  
}
#warnings singularity
#Tests of normality
p_value_clm<-vector("list",500)
p_value_clm2<-vector("list",500)
p_value_clm3<-vector("list",500)
p_value_ls<-vector("list",500)
p_value_ls2<-vector("list",500)
st_clm<-vector("list",500)
st_clm2<-vector("list",500)
ks_results<-vector("list",500)
ks1_results<-vector("list",500)
ks2_results<-vector("list",500)
ks_ls_results<-vector("list",500)
ks1_ls_results<-vector("list",500)
ks2_ls_results<-vector("list",500)
p_values_ks<-vector("list",500)
p_values_ks1<-vector("list",500)
p_values_ks2<-vector("list",500)
p_values_ksls<-vector("list",500)
p_values_ks1ls<-vector("list",500)
p_values_ks2ls<-vector("list",500)
for (i in 1:10000)
{
  #shapiro.test tests the NULL hypothesis that the samples came from a Normal distribution.
  shapiro.test(clm_res[[i]])
  
  #p-values S-W test 
  p_value_clm[[i]]<-shapiro.test(clm_res[[i]])$p.value
  p_value_clm2[[i]]<-shapiro.test(clm2_res[[i]])$p.value
  p_value_clm3[[i]]<-shapiro.test(clm3_res[[i]])$p.value
 
  #statistic S-W test
  st_clm[[i]]<-shapiro.test(clm_res[[i]])$statistic
  st_clm2[[i]]<-shapiro.test(clm2_res[[i]])$statistic
  
  #K-S test logit-Cauchit
  ks_results[[i]]<-ks.test(unlist(clm_res[[i]]),unlist(clm2_res[[i]]))

  #p-values K-S test
  p_values_ks[[i]]<-ks_results[[i]]$p.value

}
par(mfrow=c(1,1))
hist(unlist(p_values_ks),main="",xlab="p-values from K-S test for D-S residuals logit-Cauchit",cex.lab=1.5,cex.axis=1.5,ylim=c(0,1000))

# Kolmogorov-Smirnov test. If p>0.05, they come from the same distribution.
which(unlist(p_values_ks)>=0.05)
length(which(unlist(p_values_ks)>0.05))
length(which(unlist(p_values_ks)>0.05))/10000
#[1] 0.9568

#Normal values - Results from Shapiro-Wilk Normality Test. If p>0.05, we  cannot reject  Null hypothesis Normal distrib.
length(which(p_value_clm>0.05))
length(which(p_value_clm>0.05))/10000

#Empirical cumulative distribution function of p-values from Shapiro-Wilk test
#par(mar=c(4.1,4.1,2.0,1.1))
par(mfrow=c(1,3))
plot(ecdf(unlist(p_value_clm)),main="Logit link",cex.axis=1.5,cex.main=1.5,cex.lab=1.5)
plot(ecdf(unlist(p_value_clm3)),main="Probit link",cex.axis=1.5,cex.main=1.5,cex.lab=1.5)
plot(ecdf(unlist(p_value_clm2)),main="Cauchit link",cex.axis=1.5,cex.main=1.5,cex.lab=1.5)

#AHORA HASTA AQUI ----^^

#####################
###########################################################################################
###########################################################################################
###########################################################################################
###########################################################################################
#####################
#####(b) Equidistant example  2 (0,4,8,12)
ordinalize<-function(z,threshold){ 
  oo<-function(zz){
    ordinal.value<-1;index<-1
    while(index<=length(threshold) && zz>threshold[index]) {ordinal.value<-ordinal.value+1;index<-index+1}
    return(ordinal.value)
  }
  return(sapply(z,oo))
}


#############################################################################
#############################################################################

#Probit-Cauchit

clm_res<-vector("list",500)
clm2_res<-vector("list",500)
clm3_res<-vector("list",500)
ls_res<-vector("list",500)
ls2_res<-vector("list",500)
IQR_clm_res<-vector("list",500)
IQR_ls_res<-vector("list",500)
p_value_clm<-vector("list",500)
p_value_ls<-vector("list",500)
n <- 500
for (i in 1:10000)
{
  set.seed(i)
  # covariate
  n<-500
  
  alpha<-16;beta_1<--8;beta_2<-1
  thrd<-c(0,4,8,12)
  
  #X<-rnorm(n,mean=3,sd=2)
  X<-runif(n,1,7)
  RES<-rcauchy(500)
  #RES<-rcauchy(500,0.7,0.01)
  #qqnorm(RES,xlim=c(-4,4),ylim=c(-4,4))
  #abline(0,1)
  
  Z<-alpha+beta_1*X+beta_2*(X^2)+RES
  W<-ordinalize(Z,thrd)
  table(W)
  
  X_1<-X;X_2<-X^2
  
  #lrmfit<-lrm(yc~x,data=data.frame(y=yc,x=x),x=TRUE,y=TRUE)
  clmfit <- clm(as.ordered(W-1)~X_1+X_2,link="probit")
  clmfit2<-clm(as.ordered(W-1)~X_1+X_2,link="cauchit")
  clmfit3<-clm(as.ordered(W-1)~X_1+X_2,link="logit")
  par(mfrow=c(1,2))
  
  
  
  #D-S residuals
  clm.residuals = function(obj) {
    preds = predict(obj, type="cum.prob")
    residuals = runif(length(preds$cprob1))*(preds$cprob1-preds$cprob2) + preds$cprob2
    return(qnorm(residuals))}
  
  clm_res[[i]]<-clm.residuals(clmfit)
  
  clm2_res[[i]]<-clm.residuals(clmfit2)
  
  clm3_res[[i]]<-clm.residuals(clmfit3)
  
}
#warnings singularity
#Tests of normality
p_value_clm<-vector("list",500)
p_value_clm2<-vector("list",500)
p_value_clm3<-vector("list",500)
p_value_ls<-vector("list",500)
p_value_ls2<-vector("list",500)
st_clm<-vector("list",500)
st_clm2<-vector("list",500)
ks_results<-vector("list",500)
ks1_results<-vector("list",500)
ks2_results<-vector("list",500)
ks_ls_results<-vector("list",500)
ks1_ls_results<-vector("list",500)
ks2_ls_results<-vector("list",500)
p_values_ks<-vector("list",500)
p_values_ks1<-vector("list",500)
p_values_ks2<-vector("list",500)
p_values_ksls<-vector("list",500)
p_values_ks1ls<-vector("list",500)
p_values_ks2ls<-vector("list",500)
for (i in 1:10000)
{
  #shapiro.test tests the NULL hypothesis that the samples came from a Normal distribution.
  shapiro.test(clm_res[[i]])
  #shapiro.test(ls_res[[i]]) 
  p_value_clm[[i]]<-shapiro.test(clm_res[[i]])$p.value
  p_value_clm2[[i]]<-shapiro.test(clm2_res[[i]])$p.value
  p_value_clm3[[i]]<-shapiro.test(clm3_res[[i]])$p.value
  #p_value_ls[[i]]<-shapiro.test(ls_res[[i]])$p.value
  #p_value_ls2[[i]]<-shapiro.test(ls2_res[[i]])$p.value
  st_clm[[i]]<-shapiro.test(clm_res[[i]])$statistic
  st_clm2[[i]]<-shapiro.test(clm2_res[[i]])$statistic
  ks_results[[i]]<-ks.test(unlist(clm_res[[i]]),unlist(clm2_res[[i]]))
  #ks1_results[[i]]<-ks.test(unlist(clm_res[[i]]),"punif",0,1) #0
  #ks2_results[[i]]<-ks.test(unlist(clm2_res[[i]]),"punif",0,1) #0
  ks_results[[i]]<-ks.test(unlist(clm_res[[i]]),unlist(clm2_res[[i]]))
  #ks_ls_results[[i]]<-ks.test(unlist(ls_res[[i]]),unlist(ls2_res[[i]]))
  #ks1_ls_results[[i]]<-ks.test(unlist(ls_res[[i]]),"punif",0,1) #0
  #ks2_ls_results[[i]]<-ks.test(unlist(ls2_res[[i]]),"punif",0,1) #0
  p_values_ks[[i]]<-ks_results[[i]]$p.value
  #p_values_ks1[[i]]<-ks1_results[[i]]$p.value
  #p_values_ks2[[i]]<-ks1_results[[i]]$p.value
  #p_values_ksls[[i]]<-ks_ls_results[[i]]$p.value
  #p_values_ks1ls[[i]]<-ks1_ls_results[[i]]$p.value
  #p_values_ks2ls[[i]]<-ks1_ls_results[[i]]$p.value
  #hist(unlist(p_values_ks[[i]]))
}
par(mfrow=c(1,1))
hist(unlist(p_values_ks),main="",xlab="p-values from K-S test for D-S residuals probit-Cauchit",cex.lab=1.5,ylim=c(0,1950),cex.axis=1.5,cex.main=1.5,cex.lab=1.5)

which(unlist(p_values_ks)>0.05)
length(which(unlist(p_values_ks)>0.05))

length(which(unlist(p_values_ks)>0.05))/10000
#0.801
#Normal values - Results from Shapiro-Wilk Normality Test. If p>0.05, we  cannot reject  Null hypothesis Normal distrib.

length(which(unlist(p_value_clm>0.05)))
length(which(unlist(p_value_clm>0.05)))/10000
length(which(unlist(p_value_clm2>0.05)))/10000
length(which(unlist(p_value_clm3>0.05)))/10000

#Empirical cumulative distribution function of p-values from Shapiro-Wilk test
#par(mar=c(4.1,4.1,2.0,1.1))
par(mfrow=c(1,3))
plot(ecdf(unlist(p_value_clm3)),main="Logit link",cex.axis=1.5,cex.main=1.5,cex.lab=1.5)
plot(ecdf(unlist(p_value_clm)),main="Probit link",cex.axis=1.5,cex.main=1.5,cex.lab=1.5)
plot(ecdf(unlist(p_value_clm2)),main="Cauchit link",cex.axis=1.5,cex.main=1.5,cex.lab=1.5)


#############################################################################
#############################################################################

#Logit-Cauchit

clm_res<-vector("list",500)
clm2_res<-vector("list",500)
clm3_res<-vector("list",500)
ls_res<-vector("list",500)
ls2_res<-vector("list",500)
IQR_clm_res<-vector("list",500)
IQR_ls_res<-vector("list",500)
p_value_clm<-vector("list",500)
p_value_clm2<-vector("list",500)
p_value_clm3<-vector("list",500)
p_value_ls<-vector("list",500)
n <- 500
for (i in 1:10000)
{
  set.seed(i)
  # covariate
  n<-500
  
  alpha<-16;beta_1<--8;beta_2<-1
  thrd<-c(0,4,8,12)
  
  #X<-rnorm(n,mean=3,sd=2)
  X<-runif(n,1,7)
  RES<-rcauchy(500)
  #RES<-rcauchy(500,0.7,0.01)
  #qqnorm(RES,xlim=c(-4,4),ylim=c(-4,4))
  #abline(0,1)
  
  Z<-alpha+beta_1*X+beta_2*(X^2)+RES
  W<-ordinalize(Z,thrd)
  table(W)
  
  X_1<-X;X_2<-X^2
  
  #lrmfit<-lrm(yc~x,data=data.frame(y=yc,x=x),x=TRUE,y=TRUE)
  clmfit <- clm(as.ordered(W-1)~X_1+X_2,link="logit")
  clmfit2<-clm(as.ordered(W-1)~X_1+X_2,link="cauchit")
  clmfit3<-clm(as.ordered(W-1)~X_1+X_2,link="probit")
  par(mfrow=c(1,2))
  
  
  
  #D-S residuals
  clm.residuals = function(obj) {
    preds = predict(obj, type="cum.prob")
    residuals = runif(length(preds$cprob1))*(preds$cprob1-preds$cprob2) + preds$cprob2
    return(qnorm(residuals))}
  
  clm_res[[i]]<-clm.residuals(clmfit)
  
  clm2_res[[i]]<-clm.residuals(clmfit2)
  
  clm3_res[[i]]<-clm.residuals(clmfit3)
  
}
#warnings singularity
#Tests of normality
p_value_clm<-vector("list",500)
p_value_clm2<-vector("list",500)
p_value_clm3<-vector("list",500)
p_value_ls<-vector("list",500)
p_value_ls2<-vector("list",500)
st_clm<-vector("list",500)
st_clm2<-vector("list",500)
ks_results<-vector("list",500)
ks1_results<-vector("list",500)
ks2_results<-vector("list",500)
ks_ls_results<-vector("list",500)
ks1_ls_results<-vector("list",500)
ks2_ls_results<-vector("list",500)
p_values_ks<-vector("list",500)
p_values_ks1<-vector("list",500)
p_values_ks2<-vector("list",500)
p_values_ksls<-vector("list",500)
p_values_ks1ls<-vector("list",500)
p_values_ks2ls<-vector("list",500)
for (i in 1:10000)
{
  #shapiro.test tests the NULL hypothesis that the samples came from a Normal distribution.
  shapiro.test(clm_res[[i]])
  #shapiro.test(ls_res[[i]]) 
  p_value_clm[[i]]<-shapiro.test(clm_res[[i]])$p.value
  p_value_clm2[[i]]<-shapiro.test(clm2_res[[i]])$p.value
  p_value_clm3[[i]]<-shapiro.test(clm3_res[[i]])$p.value
  #p_value_ls[[i]]<-shapiro.test(ls_res[[i]])$p.value
  #p_value_ls2[[i]]<-shapiro.test(ls2_res[[i]])$p.value
  st_clm[[i]]<-shapiro.test(clm_res[[i]])$statistic
  st_clm2[[i]]<-shapiro.test(clm2_res[[i]])$statistic
  ks_results[[i]]<-ks.test(unlist(clm_res[[i]]),unlist(clm2_res[[i]]))
  #ks1_results[[i]]<-ks.test(unlist(clm_res[[i]]),"punif",0,1) #0
  #ks2_results[[i]]<-ks.test(unlist(clm2_res[[i]]),"punif",0,1) #0
  ks_results[[i]]<-ks.test(unlist(clm_res[[i]]),unlist(clm2_res[[i]]))
  #ks_ls_results[[i]]<-ks.test(unlist(ls_res[[i]]),unlist(ls2_res[[i]]))
  #ks1_ls_results[[i]]<-ks.test(unlist(ls_res[[i]]),"punif",0,1) #0
  #ks2_ls_results[[i]]<-ks.test(unlist(ls2_res[[i]]),"punif",0,1) #0
  p_values_ks[[i]]<-ks_results[[i]]$p.value
  #p_values_ks1[[i]]<-ks1_results[[i]]$p.value
  #p_values_ks2[[i]]<-ks1_results[[i]]$p.value
  #p_values_ksls[[i]]<-ks_ls_results[[i]]$p.value
  #p_values_ks1ls[[i]]<-ks1_ls_results[[i]]$p.value
  #p_values_ks2ls[[i]]<-ks1_ls_results[[i]]$p.value
  #hist(unlist(p_values_ks[[i]]))
}
par(mfrow=c(1,1))
hist(unlist(p_values_ks),main="",xlab="p-values from K-S test for D-S residuals logit-Cauchit",cex.lab=1.5,cex.main=1.5,cex.axis=1.5,ylim=c(0,1200))

which(unlist(p_values_ks)<=0.05)
length(which(unlist(p_values_ks)>0.05))

length(which(unlist(p_values_ks)>0.05))/10000
#[1] 0.9568

#Normal values - Results from Shapiro-Wilk Normality Test. If p>0.05, we  cannot reject  Null hypothesis Normal distrib.
length(which(p_value_clm>0.05))
length(which(p_value_clm>0.05))/10000
length(which(p_value_clm2>0.05))/10000
length(which(p_value_clm3>0.05))/10000
#[1] 0.0281

#Empirical cumulative distribution function of p-values from Shapiro-Wilk test
#par(mar=c(4.1,4.1,2.0,1.1))
par(mfrow=c(1,3))
plot(ecdf(unlist(p_value_clm)),main="Logit link",cex.axis=1.5,cex.main=1.5,cex.lab=1.5)
plot(ecdf(unlist(p_value_clm3)),main="Probit link",cex.axis=1.5,cex.main=1.5,cex.lab=1.5)
plot(ecdf(unlist(p_value_clm2)),main="Cauchit link",cex.axis=1.5,cex.main=1.5,cex.lab=1.5)

###########################################################################################
###########################################################################################


#####(c) Unconstrained (-1.5,0,1,3)
ordinalize<-function(z,threshold){ 
  oo<-function(zz){
    ordinal.value<-1;index<-1
    while(index<=length(threshold) && zz>threshold[index]) {ordinal.value<-ordinal.value+1;index<-index+1}
    return(ordinal.value)
  }
  return(sapply(z,oo))
}

clm_res<-vector("list",500)
clm2_res<-vector("list",500)
clm3_res<-vector("list",500)
ls_res<-vector("list",500)
ls2_res<-vector("list",500)
IQR_clm_res<-vector("list",500)
IQR_ls_res<-vector("list",500)
p_value_clm<-vector("list",500)
p_value_ls<-vector("list",500)
n <- 500
for (i in 1:10000)
{
  set.seed(i)
  # covariate
  n<-500
  
  alpha<-16;beta_1<--8;beta_2<-1
  thrd<-c(-1.5,0,1,3)
  
  #X<-rnorm(n,mean=3,sd=2)
  X<-runif(n,1,7)
  RES<-rcauchy(500)
  #RES<-rcauchy(500,0.7,0.01)
  #qqnorm(RES,xlim=c(-4,4),ylim=c(-4,4))
  #abline(0,1)
  
  Z<-alpha+beta_1*X+beta_2*(X^2)+RES
  W<-ordinalize(Z,thrd)
  table(W)
  
  X_1<-X;X_2<-X^2
  
  #lrmfit<-lrm(yc~x,data=data.frame(y=yc,x=x),x=TRUE,y=TRUE)
  clmfit <- clm(as.ordered(W-1)~X_1+X_2,link="probit")
  clmfit2<-clm(as.ordered(W-1)~X_1+X_2,link="cauchit")
  clmfit3<-clm(as.ordered(W-1)~X_1+X_2,link="logit")
  
  par(mfrow=c(1,2))
  
  
  
  #D-S residuals
  clm.residuals = function(obj) {
    preds = predict(obj, type="cum.prob")
    residuals = runif(length(preds$cprob1))*(preds$cprob1-preds$cprob2) + preds$cprob2
    return(qnorm(residuals))}
  
  clm_res[[i]]<-clm.residuals(clmfit)
  
  clm2_res[[i]]<-clm.residuals(clmfit2)
  
  clm3_res[[i]]<-clm.residuals(clmfit3)
  
}
#warnings singularity
#Tests of normality
p_value_clm<-vector("list",500)
p_value_clm2<-vector("list",500)
p_value_clm3<-vector("list",500)
p_value_ls<-vector("list",500)
p_value_ls2<-vector("list",500)
st_clm<-vector("list",500)
st_clm2<-vector("list",500)
ks_results<-vector("list",500)
ks1_results<-vector("list",500)
ks2_results<-vector("list",500)
ks_ls_results<-vector("list",500)
ks1_ls_results<-vector("list",500)
ks2_ls_results<-vector("list",500)
p_values_ks<-vector("list",500)
p_values_ks1<-vector("list",500)
p_values_ks2<-vector("list",500)
p_values_ksls<-vector("list",500)
p_values_ks1ls<-vector("list",500)
p_values_ks2ls<-vector("list",500)
for (i in 1:10000)
{
  #shapiro.test tests the NULL hypothesis that the samples came from a Normal distribution.
  shapiro.test(clm_res[[i]])
  #shapiro.test(ls_res[[i]]) 
  p_value_clm[[i]]<-shapiro.test(clm_res[[i]])$p.value
  p_value_clm2[[i]]<-shapiro.test(clm2_res[[i]])$p.value
  p_value_clm3[[i]]<-shapiro.test(clm3_res[[i]])$p.value
  #p_value_ls[[i]]<-shapiro.test(ls_res[[i]])$p.value
  #p_value_ls2[[i]]<-shapiro.test(ls2_res[[i]])$p.value
  st_clm[[i]]<-shapiro.test(clm_res[[i]])$statistic
  st_clm2[[i]]<-shapiro.test(clm2_res[[i]])$statistic
  ks_results[[i]]<-ks.test(unlist(clm_res[[i]]),unlist(clm2_res[[i]]))
  #ks1_results[[i]]<-ks.test(unlist(clm_res[[i]]),"punif",0,1) #0
  #ks2_results[[i]]<-ks.test(unlist(clm2_res[[i]]),"punif",0,1) #0
  ks_results[[i]]<-ks.test(unlist(clm_res[[i]]),unlist(clm2_res[[i]]))
  #ks_ls_results[[i]]<-ks.test(unlist(ls_res[[i]]),unlist(ls2_res[[i]]))
  #ks1_ls_results[[i]]<-ks.test(unlist(ls_res[[i]]),"punif",0,1) #0
  #ks2_ls_results[[i]]<-ks.test(unlist(ls2_res[[i]]),"punif",0,1) #0
  p_values_ks[[i]]<-ks_results[[i]]$p.value
  #p_values_ks1[[i]]<-ks1_results[[i]]$p.value
  #p_values_ks2[[i]]<-ks1_results[[i]]$p.value
  #p_values_ksls[[i]]<-ks_ls_results[[i]]$p.value
  #p_values_ks1ls[[i]]<-ks1_ls_results[[i]]$p.value
  #p_values_ks2ls[[i]]<-ks1_ls_results[[i]]$p.value
  #hist(unlist(p_values_ks[[i]]))
}
par(mfrow=c(1,1))
hist(unlist(p_values_ks),main="",xlab="p-values from K-S test for D-S residuals probit-Cauchit",cex.lab=1.5,ylim=c(0,1700))

which(unlist(p_values_ks)>0.05)
length(which(unlist(p_values_ks)>0.05))
length(which(unlist(p_values_ks)>0.05))/10000
#[1] 0.8316
#Normal values - Results from Shapiro-Wilk Normality Test. If p>0.05, we  cannot reject  Null hypothesis Normal distrib.

length(which(p_value_clm>0.05))
length(which(p_value_clm>0.05))/10000
length(which(unlist(p_value_clm>0.05)))/10000
length(which(unlist(p_value_clm2>0.05)))/10000
length(which(unlist(p_value_clm3>0.05)))/10000

#Empirical cumulative distribution function of p-values from Shapiro-Wilk test
par(mar=c(4.1,4.1,2.0,1.1))
par(mfrow=c(1,3))
plot(ecdf(unlist(p_value_clm3)),main="Logit link",cex.axis=1.5,cex.main=1.5,cex.lab=1.5)
plot(ecdf(unlist(p_value_clm)),main="Probit link",cex.axis=1.5,cex.main=1.5,cex.lab=1.5)
plot(ecdf(unlist(p_value_clm2)),main="Cauchit link",cex.axis=1.5,cex.main=1.5,cex.lab=1.5)

#############################################################################
#############################################################################

#Logit-Cauchit

clm_res<-vector("list",500)
clm2_res<-vector("list",500)
clm3_res<-vector("list",500)
ls_res<-vector("list",500)
ls2_res<-vector("list",500)
IQR_clm_res<-vector("list",500)
IQR_ls_res<-vector("list",500)
p_value_clm<-vector("list",500)
p_value_clm2<-vector("list",500)
p_value_clm3<-vector("list",500)
p_value_ls<-vector("list",500)
n <- 500
for (i in 1:10000)
{
  set.seed(i)
  # covariate
  n<-500
  
  alpha<-16;beta_1<--8;beta_2<-1
  thrd<-c(-1.5,0,1,3)
  
  #X<-rnorm(n,mean=3,sd=2)
  X<-runif(n,1,7)
  RES<-rcauchy(500)
  #RES<-rcauchy(500,0.7,0.01)
  #qqnorm(RES,xlim=c(-4,4),ylim=c(-4,4))
  #abline(0,1)
  
  Z<-alpha+beta_1*X+beta_2*(X^2)+RES
  W<-ordinalize(Z,thrd)
  table(W)
  
  X_1<-X;X_2<-X^2
  
  #lrmfit<-lrm(yc~x,data=data.frame(y=yc,x=x),x=TRUE,y=TRUE)
  clmfit <- clm(as.ordered(W-1)~X_1+X_2,link="logit")
  clmfit2<-clm(as.ordered(W-1)~X_1+X_2,link="cauchit")
  clmfit3<-clm(as.ordered(W-1)~X_1+X_2,link="probit")
  par(mfrow=c(1,2))
  
  
  #D-S residuals
  clm.residuals = function(obj) {
    preds = predict(obj, type="cum.prob")
    residuals = runif(length(preds$cprob1))*(preds$cprob1-preds$cprob2) + preds$cprob2
    return(qnorm(residuals))}
  
  clm_res[[i]]<-clm.residuals(clmfit)
  
  clm2_res[[i]]<-clm.residuals(clmfit2)
  
  clm3_res[[i]]<-clm.residuals(clmfit3)
  
}
#warnings singularity
#Tests of normality
p_value_clm<-vector("list",500)
p_value_clm2<-vector("list",500)
p_value_clm3<-vector("list",500)
p_value_ls<-vector("list",500)
p_value_ls2<-vector("list",500)
st_clm<-vector("list",500)
st_clm2<-vector("list",500)
ks_results<-vector("list",500)
ks1_results<-vector("list",500)
ks2_results<-vector("list",500)
ks_ls_results<-vector("list",500)
ks1_ls_results<-vector("list",500)
ks2_ls_results<-vector("list",500)
p_values_ks<-vector("list",500)
p_values_ks1<-vector("list",500)
p_values_ks2<-vector("list",500)
p_values_ksls<-vector("list",500)
p_values_ks1ls<-vector("list",500)
p_values_ks2ls<-vector("list",500)
for (i in 1:10000)
{
  #shapiro.test tests the NULL hypothesis that the samples came from a Normal distribution.
  shapiro.test(clm_res[[i]])
  #shapiro.test(ls_res[[i]]) 
  p_value_clm[[i]]<-shapiro.test(clm_res[[i]])$p.value
  p_value_clm2[[i]]<-shapiro.test(clm2_res[[i]])$p.value
  p_value_clm3[[i]]<-shapiro.test(clm3_res[[i]])$p.value
  #p_value_ls[[i]]<-shapiro.test(ls_res[[i]])$p.value
  #p_value_ls2[[i]]<-shapiro.test(ls2_res[[i]])$p.value
  st_clm[[i]]<-shapiro.test(clm_res[[i]])$statistic
  st_clm2[[i]]<-shapiro.test(clm2_res[[i]])$statistic
  ks_results[[i]]<-ks.test(unlist(clm_res[[i]]),unlist(clm2_res[[i]]))
  #ks1_results[[i]]<-ks.test(unlist(clm_res[[i]]),"punif",0,1) #0
  #ks2_results[[i]]<-ks.test(unlist(clm2_res[[i]]),"punif",0,1) #0
  ks_results[[i]]<-ks.test(unlist(clm_res[[i]]),unlist(clm2_res[[i]]))
  #ks_ls_results[[i]]<-ks.test(unlist(ls_res[[i]]),unlist(ls2_res[[i]]))
  #ks1_ls_results[[i]]<-ks.test(unlist(ls_res[[i]]),"punif",0,1) #0
  #ks2_ls_results[[i]]<-ks.test(unlist(ls2_res[[i]]),"punif",0,1) #0
  p_values_ks[[i]]<-ks_results[[i]]$p.value
  #p_values_ks1[[i]]<-ks1_results[[i]]$p.value
  #p_values_ks2[[i]]<-ks1_results[[i]]$p.value
  #p_values_ksls[[i]]<-ks_ls_results[[i]]$p.value
  #p_values_ks1ls[[i]]<-ks1_ls_results[[i]]$p.value
  #p_values_ks2ls[[i]]<-ks1_ls_results[[i]]$p.value
  #hist(unlist(p_values_ks[[i]]))
}
par(mfrow=c(1,1))
hist(unlist(p_values_ks),main="",xlab="p-values from K-S test for D-S residuals logit-Cauchit",cex.lab=1.5,ylim=c(0,1000))

which(unlist(p_values_ks)<=0.05)
length(which(unlist(p_values_ks)>0.05))
length(which(unlist(p_values_ks)>0.05))/10000


#Normal values - Results from Shapiro-Wilk Normality Test. If p>0.05, we  cannot reject  Null hypothesis Normal distrib.
length(which(unlist(p_value_clm>0.05)))
length(which(unlist(p_value_clm>0.05)))/10000
length(which(unlist(p_value_clm2>0.05)))/10000
length(which(unlist(p_value_clm3>0.05)))/10000
#0.061

#Empirical cumulative distribution function of p-values from Shapiro-Wilk test
#par(mar=c(4.1,4.1,2.0,1.1))
par(mfrow=c(1,3))
plot(ecdf(unlist(p_value_clm)),main="Logit link",cex.axis=1.5,cex.main=1.5,cex.lab=1.5)
plot(ecdf(unlist(p_value_clm3)),main="Probit link",cex.axis=1.5,cex.main=1.5,cex.lab=1.5)
plot(ecdf(unlist(p_value_clm2)),main="Cauchit link",cex.axis=1.5,cex.main=1.5,cex.lab=1.5)

###########################################################################################
###########################################################################################


#####(d) Symmetric (-36,-6,34,64)
ordinalize<-function(z,threshold){ 
  oo<-function(zz){
    ordinal.value<-1;index<-1
    while(index<=length(threshold) && zz>threshold[index]) {ordinal.value<-ordinal.value+1;index<-index+1}
    return(ordinal.value)
  }
  return(sapply(z,oo))
}


#############################################################################
#############################################################################

#Probit-Cauchit

clm_res<-vector("list",500)
clm2_res<-vector("list",500)
ls_res<-vector("list",500)
ls2_res<-vector("list",500)
IQR_clm_res<-vector("list",500)
IQR_ls_res<-vector("list",500)
p_value_clm<-vector("list",500)
p_value_clm2<-vector("list",500)
p_value_clm3<-vector("list",500)
p_value_ls<-vector("list",500)
n <- 500
for (i in 1:10000)
{
  set.seed(i)
  # covariate
  n<-500
  
  alpha<-16;beta_1<--8;beta_2<-1
  thrd<-c(-36,-6,34,64)
  
  #X<-rnorm(n,mean=3,sd=2)
  X<-runif(n,1,7)
  RES<-rcauchy(500)
  #RES<-rcauchy(500,0.7,0.01)
  #qqnorm(RES,xlim=c(-4,4),ylim=c(-4,4))
  #abline(0,1)
  
  Z<-alpha+beta_1*X+beta_2*(X^2)+RES
  W<-ordinalize(Z,thrd)
  table(W)
  
  X_1<-X;X_2<-X^2
  
  #lrmfit<-lrm(yc~x,data=data.frame(y=yc,x=x),x=TRUE,y=TRUE)
  clmfit <- clm(as.ordered(W-1)~X_1+X_2,link="probit")
  clmfit2<-clm(as.ordered(W-1)~X_1+X_2,link="cauchit")
  clmfit3<-clm(as.ordered(W-1)~X_1+X_2,link="logit")
  par(mfrow=c(1,2))
  
  
  
  #D-S residuals
  clm.residuals = function(obj) {
    preds = predict(obj, type="cum.prob")
    residuals = runif(length(preds$cprob1))*(preds$cprob1-preds$cprob2) + preds$cprob2
    return(qnorm(residuals))}
  
  clm_res[[i]]<-clm.residuals(clmfit)
  
  clm2_res[[i]]<-clm.residuals(clmfit2)
  
  clm3_res[[i]]<-clm.residuals(clmfit3)
  
}
#warnings singularity
#Tests of normality
p_value_clm<-vector("list",500)
p_value_clm2<-vector("list",500)
p_value_clm3<-vector("list",500)
p_value_ls<-vector("list",500)
p_value_ls2<-vector("list",500)
st_clm<-vector("list",500)
st_clm2<-vector("list",500)
ks_results<-vector("list",500)
ks1_results<-vector("list",500)
ks2_results<-vector("list",500)
ks_ls_results<-vector("list",500)
ks1_ls_results<-vector("list",500)
ks2_ls_results<-vector("list",500)
p_values_ks<-vector("list",500)
p_values_ks1<-vector("list",500)
p_values_ks2<-vector("list",500)
p_values_ksls<-vector("list",500)
p_values_ks1ls<-vector("list",500)
p_values_ks2ls<-vector("list",500)
for (i in 1:10000)
{
  #shapiro.test tests the NULL hypothesis that the samples came from a Normal distribution.
  shapiro.test(clm_res[[i]])
  #shapiro.test(ls_res[[i]]) 
  p_value_clm[[i]]<-shapiro.test(clm_res[[i]])$p.value
  p_value_clm2[[i]]<-shapiro.test(clm2_res[[i]])$p.value
  p_value_clm3[[i]]<-shapiro.test(clm3_res[[i]])$p.value
  #p_value_ls[[i]]<-shapiro.test(ls_res[[i]])$p.value
  #p_value_ls2[[i]]<-shapiro.test(ls2_res[[i]])$p.value
  st_clm[[i]]<-shapiro.test(clm_res[[i]])$statistic
  st_clm2[[i]]<-shapiro.test(clm2_res[[i]])$statistic
  ks_results[[i]]<-ks.test(unlist(clm_res[[i]]),unlist(clm2_res[[i]]))
  #ks1_results[[i]]<-ks.test(unlist(clm_res[[i]]),"punif",0,1) #0
  #ks2_results[[i]]<-ks.test(unlist(clm2_res[[i]]),"punif",0,1) #0
  ks_results[[i]]<-ks.test(unlist(clm_res[[i]]),unlist(clm2_res[[i]]))
  #ks_ls_results[[i]]<-ks.test(unlist(ls_res[[i]]),unlist(ls2_res[[i]]))
  #ks1_ls_results[[i]]<-ks.test(unlist(ls_res[[i]]),"punif",0,1) #0
  #ks2_ls_results[[i]]<-ks.test(unlist(ls2_res[[i]]),"punif",0,1) #0
  p_values_ks[[i]]<-ks_results[[i]]$p.value
  #p_values_ks1[[i]]<-ks1_results[[i]]$p.value
  #p_values_ks2[[i]]<-ks1_results[[i]]$p.value
  #p_values_ksls[[i]]<-ks_ls_results[[i]]$p.value
  #p_values_ks1ls[[i]]<-ks1_ls_results[[i]]$p.value
  #p_values_ks2ls[[i]]<-ks1_ls_results[[i]]$p.value
  #hist(unlist(p_values_ks[[i]]))
}
par(mfrow=c(1,1))
hist(unlist(p_values_ks),main="",xlab="p-values from K-S test for D-S residuals probit-Cauchit",cex.lab=1.5,ylim=c(0,800))

which(unlist(p_values_ks)>0.05)
length(which(unlist(p_values_ks)>0.05))
length(which(unlist(p_values_ks)>0.05))/10000

#Normal values - Results from Shapiro-Wilk Normality Test. If p>0.05, we  cannot reject  Null hypothesis Normal distrib.

length(which(p_value_clm>0.05))
length(which(p_value_clm>0.05))/10000
length(which(unlist(p_value_clm>0.05)))/10000
length(which(unlist(p_value_clm2>0.05)))/10000
length(which(unlist(p_value_clm3>0.05)))/10000


#Empirical cumulative distribution function of p-values from Shapiro-Wilk test
#par(mar=c(4.1,4.1,2.0,1.1))
par(mfrow=c(1,3))
plot(ecdf(unlist(p_value_clm3)),main="Logit link",cex.axis=1.5,cex.main=1.5,cex.lab=1.5)
plot(ecdf(unlist(p_value_clm)),main="Probit link",cex.axis=1.5,cex.main=1.5,cex.lab=1.5)
plot(ecdf(unlist(p_value_clm2)),main="Cauchit link",cex.axis=1.5,cex.main=1.5,cex.lab=1.5)

#############################################################################
#############################################################################

#Logit-Cauchit

clm_res<-vector("list",500)
clm2_res<-vector("list",500)
ls_res<-vector("list",500)
ls2_res<-vector("list",500)
IQR_clm_res<-vector("list",500)
IQR_ls_res<-vector("list",500)
p_value_clm<-vector("list",500)
p_value_ls<-vector("list",500)
n <- 500
for (i in 1:10000)
{
  set.seed(i)
  # covariate
  n<-500
  
  alpha<-16;beta_1<--8;beta_2<-1
  thrd<-c(-36,-6,34,64)
  
  #X<-rnorm(n,mean=3,sd=2)
  X<-runif(n,1,7)
  RES<-rcauchy(500)
  #RES<-rcauchy(500,0.7,0.01)
  #qqnorm(RES,xlim=c(-4,4),ylim=c(-4,4))
  #abline(0,1)
  
  Z<-alpha+beta_1*X+beta_2*(X^2)+RES
  W<-ordinalize(Z,thrd)
  table(W)
  
  X_1<-X;X_2<-X^2
  
  #lrmfit<-lrm(yc~x,data=data.frame(y=yc,x=x),x=TRUE,y=TRUE)
  clmfit <- clm(as.ordered(W-1)~X_1+X_2,link="logit")
  clmfit2<-clm(as.ordered(W-1)~X_1+X_2,link="cauchit")
  clmfit3<-clm(as.ordered(W-1)~X_1+X_2,link="probit")
  par(mfrow=c(1,2))
  
  #D-S residuals
  clm.residuals = function(obj) {
    preds = predict(obj, type="cum.prob")
    residuals = runif(length(preds$cprob1))*(preds$cprob1-preds$cprob2) + preds$cprob2
    return(qnorm(residuals))}
  
  clm_res[[i]]<-clm.residuals(clmfit)
  
  clm2_res[[i]]<-clm.residuals(clmfit2)
  
  clm3_res[[i]]<-clm.residuals(clmfit3)
  
}
#warnings singularity
#Tests of normality
p_value_clm<-vector("list",500)
p_value_clm2<-vector("list",500)
p_value_clm3<-vector("list",500)
p_value_ls<-vector("list",500)
p_value_ls2<-vector("list",500)
st_clm<-vector("list",500)
st_clm2<-vector("list",500)
ks_results<-vector("list",500)
ks1_results<-vector("list",500)
ks2_results<-vector("list",500)
ks_ls_results<-vector("list",500)
ks1_ls_results<-vector("list",500)
ks2_ls_results<-vector("list",500)
p_values_ks<-vector("list",500)
p_values_ks1<-vector("list",500)
p_values_ks2<-vector("list",500)
p_values_ksls<-vector("list",50)
p_values_ks1ls<-vector("list",500)
p_values_ks2ls<-vector("list",500)

for (i in 1:10000)
{
  #shapiro.test tests the NULL hypothesis that the samples came from a Normal distribution.
  shapiro.test(clm_res[[i]])
  #shapiro.test(ls_res[[i]]) 
  p_value_clm[[i]]<-shapiro.test(clm_res[[i]])$p.value
  p_value_clm2[[i]]<-shapiro.test(clm2_res[[i]])$p.value
  p_value_clm3[[i]]<-shapiro.test(clm3_res[[i]])$p.value
  #p_value_ls[[i]]<-shapiro.test(ls_res[[i]])$p.value
  #p_value_ls2[[i]]<-shapiro.test(ls2_res[[i]])$p.value
  st_clm[[i]]<-shapiro.test(clm_res[[i]])$statistic
  st_clm2[[i]]<-shapiro.test(clm2_res[[i]])$statistic
  ks_results[[i]]<-ks.test(unlist(clm_res[[i]]),unlist(clm2_res[[i]]))
  #ks1_results[[i]]<-ks.test(unlist(clm_res[[i]]),"punif",0,1) #0
  #ks2_results[[i]]<-ks.test(unlist(clm2_res[[i]]),"punif",0,1) #0
  ks_results[[i]]<-ks.test(unlist(clm_res[[i]]),unlist(clm2_res[[i]]))
  #ks_ls_results[[i]]<-ks.test(unlist(ls_res[[i]]),unlist(ls2_res[[i]]))
  #ks1_ls_results[[i]]<-ks.test(unlist(ls_res[[i]]),"punif",0,1) #0
  #ks2_ls_results[[i]]<-ks.test(unlist(ls2_res[[i]]),"punif",0,1) #0
  p_values_ks[[i]]<-ks_results[[i]]$p.value
  #p_values_ks1[[i]]<-ks1_results[[i]]$p.value
  #p_values_ks2[[i]]<-ks1_results[[i]]$p.value
  #p_values_ksls[[i]]<-ks_ls_results[[i]]$p.value
  #p_values_ks1ls[[i]]<-ks1_ls_results[[i]]$p.value
  #p_values_ks2ls[[i]]<-ks1_ls_results[[i]]$p.value
  #hist(unlist(p_values_ks[[i]]))
}
par(mfrow=c(1,1))
hist(unlist(p_values_ks),main="",xlab="p-values from K-S test for D-S residuals logit-Cauchit",cex.lab=1.5,ylim=c(0,800))

which(unlist(p_values_ks)>0.05)
length(which(unlist(p_values_ks)>0.05))
length(which(unlist(p_values_ks)>0.05))/10000


#Normal values - Results from Shapiro-Wilk Normality Test. If p>0.05, we  cannot reject  Null hypothesis Normal distrib.
length(which(p_value_clm>0.05))
length(which(p_value_clm>0.05))/10000
length(which(unlist(p_value_clm>0.05)))/10000
length(which(unlist(p_value_clm2>0.05)))/10000
length(which(unlist(p_value_clm3>0.05)))/10000


#Empirical cumulative distribution function of p-values from Shapiro-Wilk test
#par(mar=c(4.1,4.1,2.0,1.1))
par(mfrow=c(1,3))
plot(ecdf(unlist(p_value_clm)),main="Logit link",cex.axis=1.5,cex.main=1.5,cex.lab=1.5)
plot(ecdf(unlist(p_value_clm2)),main="Cauchit link",cex.axis=1.5,cex.main=1.5,cex.lab=1.5)
plot(ecdf(unlist(p_value_clm3)),main="Probit link",cex.axis=1.5,cex.main=1.5,cex.lab=1.5)

#####################
#   L-S RESIDUALS   #
#####################

###########################################################################################
###########################################################################################

#(a) Equidistant  example  1 & symmetric (-16,-12,-8,-4)
ordinalize<-function(z,threshold){ 
  oo<-function(zz){
    ordinal.value<-1;index<-1
    while(index<=length(threshold) && zz>threshold[index]) {ordinal.value<-ordinal.value+1;index<-index+1}
    return(ordinal.value)
  }
  return(sapply(z,oo))
}


#############################################################################
#############################################################################

#Probit-Cauchit

clm_res<-vector("list",500)
clm2_res<-vector("list",500)
clm3_res<-vector("list",500)
ls_res<-vector("list",500)
ls2_res<-vector("list",500)
ls3_res<-vector("list",500)
IQR_clm_res<-vector("list",500)
IQR_ls_res<-vector("list",500)
p_value_clm<-vector("list",500)
p_value_ls<-vector("list",500)
n <- 500
for (i in 1:10000)
{
  set.seed(i)
  # covariate
  n<-500
  
  alpha<-16;beta_1<--8;beta_2<-1
  thrd<-c(-16,-12,-8,-4)
  
  #X<-rnorm(n,mean=3,sd=2)
  X<-runif(n,1,7)
  RES<-rcauchy(500)
  #RES<-rcauchy(500,0.7,0.01)
  #qqnorm(RES,xlim=c(-4,4),ylim=c(-4,4))
  #abline(0,1)
  
  Z<-alpha+beta_1*X+beta_2*X^2+RES
  W<-ordinalize(Z,thrd)
  table(W)
  
  X_1<-X;X_2<-X^2
  
  #lrmfit<-lrm(yc~x,data=data.frame(y=yc,x=x),x=TRUE,y=TRUE)
  model1<-orm(as.ordered(W-1)~X_1,family=probit,x=TRUE,y=TRUE)
  model2<-orm(as.ordered(W-1)~X_1,family=cauchit,x=TRUE,y=TRUE,linear.predictors=TRUE)
  model3<-orm(as.ordered(W-1)~X_1,family=logistic,x=TRUE,y=TRUE)
  par(mfrow=c(1,2))
  
  # #D-S residuals
  # clm.residuals = function(obj) {
  #   preds = predict(obj, type="cum.prob")
  #   residuals = runif(length(preds$cprob1))*(preds$cprob1-preds$cprob2) + preds$cprob2
  #   return(qnorm(residuals))}
  # 
  ls_res[[i]]<-residuals(model1,type="li.shepherd")
  
  ls2_res[[i]]<-residuals(model2,type="li.shepherd")
  
  ls3_res[[i]]<-residuals(model3,type="li.shepherd")
  
}
#warnings singularity
#Tests of normality
p_value_clm<-vector("list",500)
p_value_clm2<-vector("list",500)
p_value_clm3<-vector("list",500)
p_value_ls<-vector("list",500)
p_value_ls2<-vector("list",500)
p_value_ls3<-vector("list",500)
st_clm<-vector("list",500)
st_clm2<-vector("list",500)
ks_results<-vector("list",500)
ks1_results<-vector("list",500)
ks2_results<-vector("list",500)
ks_ls_results<-vector("list",500)
ks2_ls_results<-vector("list",500)
ks3_ls_results<-vector("list",500)
p_values_ks<-vector("list",500)
p_values_ks1<-vector("list",500)
p_values_ks2<-vector("list",500)
p_values_ksls<-vector("list",500)
p_values_ksls2<-vector("list",500)
p_values_ksls3<-vector("list",500)
for (i in 1:10000)
{
  #shapiro.test tests the NULL hypothesis that the samples came from a Normal distribution.
  # shapiro.test(clm_res[[i]])
  shapiro.test(ls_res[[i]]) 
  # p_value_clm[[i]]<-shapiro.test(clm_res[[i]])$p.value
  # p_value_clm2[[i]]<-shapiro.test(clm2_res[[i]])$p.value
  # p_value_clm3[[i]]<-shapiro.test(clm3_res[[i]])$p.value
  p_value_ls[[i]]<-shapiro.test(ls_res[[i]])$p.value
  p_value_ls2[[i]]<-shapiro.test(ls2_res[[i]])$p.value
  p_value_ls3[[i]]<-shapiro.test(ls3_res[[i]])$p.value
  # st_clm[[i]]<-shapiro.test(clm_res[[i]])$statistic
  # st_clm2[[i]]<-shapiro.test(clm2_res[[i]])$statistic
  # ks_results[[i]]<-ks.test(unlist(clm_res[[i]]),unlist(clm2_res[[i]]))
  # #ks1_results[[i]]<-ks.test(unlist(clm_res[[i]]),"punif",0,1) #0
  # #ks2_results[[i]]<-ks.test(unlist(clm2_res[[i]]),"punif",0,1) #0
  # ks_results[[i]]<-ks.test(unlist(clm_res[[i]]),unlist(clm2_res[[i]]))
  ks_ls_results[[i]]<-ks.test(unlist(ls_res[[i]]),unlist(ls2_res[[i]]))
  ks2_ls_results[[i]]<-ks.test(unlist(ls2_res[[i]]),"punif",0,1) #0
  ks3_ls_results[[i]]<-ks.test(unlist(ls3_res[[i]]),"punif",0,1) #0
  #p_values_ks[[i]]<-ks_results[[i]]$p.value
  #p_values_ks1[[i]]<-ks1_results[[i]]$p.value
  #p_values_ks2[[i]]<-ks1_results[[i]]$p.value
  p_values_ksls[[i]]<-ks_ls_results[[i]]$p.value
  p_values_ksls2[[i]]<-ks2_ls_results[[i]]$p.value
  p_values_ksls3[[i]]<-ks3_ls_results[[i]]$p.value
  #hist(unlist(p_values_ks[[i]]))
}
par(mfrow=c(1,1))
hist(unlist(p_values_ksls),main="",xlab="p-values from K-S test for L-S residuals probit-Cauchit",cex.lab=1.5,ylim=c(0,10000))

which(unlist(p_values_ksls)>0.05)
length(which(unlist(p_values_ksls)>0.05))
length(which(unlist(p_values_ksls)>0.05))/10000

#Normal values - Results from Shapiro-Wilk Normality Test. If p>0.05, we  cannot reject  Null hypothesis Normal distrib.

length(which(unlist(p_value_ls)>0.05))
length(which(unlist(p_value_ls)>0.05))/10000
length(which(unlist(p_value_ls2>0.05)))/10000
length(which(unlist(p_value_ls3>0.05)))/10000

#Empirical cumulative distribution function of p-values from Shapiro-Wilk test
#par(mar=c(4.1,4.1,2.0,1.1))
par(mfrow=c(1,3))
plot(ecdf(unlist(p_value_ls3)),main="Logit link",cex.axis=1.5,cex.main=1.5,cex.lab=1.5)
plot(ecdf(unlist(p_value_ls)),main="Probit link",cex.axis=1.5,cex.main=1.5,cex.lab=1.5)
plot(ecdf(unlist(p_value_ls2)),main="Cauchit link",cex.axis=1.5,cex.main=1.5,cex.lab=1.5)

#############################################################################
#############################################################################

#Logit-Cauchit

clm_res<-vector("list",500)
clm2_res<-vector("list",500)
clm3_res<-vector("list",500)
ls_res<-vector("list",500)
ls2_res<-vector("list",500)
ls3_res<-vector("list",500)
IQR_clm_res<-vector("list",500)
IQR_ls_res<-vector("list",500)
p_value_clm<-vector("list",500)
p_value_clm2<-vector("list",500)
p_value_clm3<-vector("list",500)
p_value_ls<-vector("list",500)
p_value_ls2<-vector("list",500)
p_value_ls3<-vector("list",500)
n <- 500
for (i in 1:10000)
{
  set.seed(i)
  # covariate
  n<-500
  
  alpha<-16;beta_1<--8;beta_2<-1
  thrd<-c(-16,-12,-8,-4)
  
  #X<-rnorm(n,mean=3,sd=2)
  X<-runif(n,1,7)
  RES<-rcauchy(500)
  #RES<-rcauchy(500,0.7,0.01)
  #qqnorm(RES,xlim=c(-4,4),ylim=c(-4,4))
  #abline(0,1)
  
  Z<-alpha+beta_1*X+beta_2*X^2+RES
  W<-ordinalize(Z,thrd)
  table(W)
  
  X_1<-X;X_2<-X^2
  
  #lrmfit<-lrm(yc~x,data=data.frame(y=yc,x=x),x=TRUE,y=TRUE)
  model1 <- orm(as.ordered(W-1)~X_1,family=logistic,x=TRUE,y=TRUE,linear.predictors=TRUE)
  model2 <- orm(as.ordered(W-1)~X_1,family=cauchit,x=TRUE,y=TRUE,linear.predictors=TRUE)
  model3<-orm(as.ordered(W-1)~X_1,family=probit,x=TRUE,y=TRUE,linear.predictors=TRUE)
  par(mfrow=c(1,2))
  
  
  
  #D-S residuals
  # clm.residuals = function(obj) {
  #   preds = predict(obj, type="cum.prob")
  #   residuals = runif(length(preds$cprob1))*(preds$cprob1-preds$cprob2) + preds$cprob2
  #   return(qnorm(residuals))}
  
  ls_res[[i]]<-residuals(model1,type="li.shepherd")
  
  ls2_res[[i]]<-residuals(model2,type="li.shepherd")
  
  ls3_res[[i]]<-residuals(model3,type="li.shepherd")
  
  
}
#warnings singularity
#Tests of normality
# p_value_clm<-vector("list",500)
# p_value_clm2<-vector("list",500)
# p_value_clm3<-vector("list",500)
p_value_ls<-vector("list",500)
p_value_ls2<-vector("list",500)
p_value_ls3<-vector("list",500)
# st_clm<-vector("list",500)
# st_clm2<-vector("list",500)
# ks_results<-vector("list",500)
# ks1_results<-vector("list",500)
# ks2_results<-vector("list",500)
ks_ls_results<-vector("list",500)
ks_ls2_results<-vector("list",500)
ks_ls3_results<-vector("list",500)
p_values_ks<-vector("list",500)
p_values_ks1<-vector("list",500)
p_values_ks2<-vector("list",500)
p_values_ksls<-vector("list",500)
p_values_ks1ls<-vector("list",500)
p_values_ks2ls<-vector("list",500)
for (i in 1:10000)
{
  #shapiro.test tests the NULL hypothesis that the samples came from a Normal distribution.
  # shapiro.test(clm_res[[i]])
  # #shapiro.test(ls_res[[i]]) 
  # p_value_clm[[i]]<-shapiro.test(clm_res[[i]])$p.value
  # p_value_clm2[[i]]<-shapiro.test(clm2_res[[i]])$p.value
  # p_value_clm3[[i]]<-shapiro.test(clm3_res[[i]])$p.value
  p_value_ls[[i]]<-shapiro.test(ls_res[[i]])$p.value
  p_value_ls2[[i]]<-shapiro.test(ls2_res[[i]])$p.value
  p_value_ls3[[i]]<-shapiro.test(ls3_res[[i]])$p.value
  # st_clm[[i]]<-shapiro.test(clm_res[[i]])$statistic
  # st_clm2[[i]]<-shapiro.test(clm2_res[[i]])$statistic
  # ks_results[[i]]<-ks.test(unlist(clm_res[[i]]),unlist(clm2_res[[i]]))
  # #ks1_results[[i]]<-ks.test(unlist(clm_res[[i]]),"punif",0,1) #0
  # #ks2_results[[i]]<-ks.test(unlist(clm2_res[[i]]),"punif",0,1) #0
  # ks_results[[i]]<-ks.test(unlist(clm_res[[i]]),unlist(clm2_res[[i]]))
  ks_ls_results[[i]]<-ks.test(unlist(ls_res[[i]]),unlist(ls2_res[[i]]))
  ks_ls2_results[[i]]<-ks.test(unlist(ls_res[[i]]),"punif",0,1) #0
  ks_ls3_results[[i]]<-ks.test(unlist(ls2_res[[i]]),"punif",0,1) #0
  # p_values_ks[[i]]<-ks_results[[i]]$p.value
  #p_values_ks1[[i]]<-ks1_results[[i]]$p.value
  #p_values_ks2[[i]]<-ks1_results[[i]]$p.value
  p_values_ksls[[i]]<-ks_ls_results[[i]]$p.value
  p_values_ksls2[[i]]<-ks_ls2_results[[i]]$p.value
  p_values_ksls3[[i]]<-ks_ls3_results[[i]]$p.value
  #hist(unlist(p_values_ks[[i]]))
}
par(mfrow=c(1,1))
hist(unlist(p_values_ksls),main="",xlab="p-values from K-S test for L-S residuals logit-Cauchit",cex.lab=1.5,ylim=c(0,10000))

which(unlist(p_values_ksls)<=0.05)
length(which(unlist(p_values_ksls)>0.05))

length(which(unlist(p_values_ksls)>0.05))/10000
#[1] 0.9568

#Normal values - Results from Shapiro-Wilk Normality Test. If p>0.05, we  cannot reject  Null hypothesis Normal distrib.
length(which(p_value_ls>0.05))
length(which(p_value_ls>0.05))/10000
length(which(unlist(p_value_ls2>0.05)))/10000
length(which(unlist(p_value_ls3>0.05)))/10000

#Empirical cumulative distribution function of p-values from Shapiro-Wilk test
#par(mar=c(4.1,4.1,2.0,1.1))
par(mfrow=c(1,3))
plot(ecdf(unlist(p_value_ls)),main="Logit link",cex.axis=1.5,cex.main=1.5,cex.lab=1.5)
plot(ecdf(unlist(p_value_ls2)),main="Cauchit link",cex.axis=1.5,cex.main=1.5,cex.lab=1.5)
plot(ecdf(unlist(p_value_ls3)),main="Probit link",cex.axis=1.5,cex.main=1.5,cex.lab=1.5)

###########################################################################################
###########################################################################################

#####(b) Equidistant example  2 (0,4,8,12) # CAUCHIT WORKS FOR THIS ONE 
ordinalize<-function(z,threshold){ 
  oo<-function(zz){
    ordinal.value<-1;index<-1
    while(index<=length(threshold) && zz>threshold[index]) {ordinal.value<-ordinal.value+1;index<-index+1}
    return(ordinal.value)
  }
  return(sapply(z,oo))
}


#############################################################################
#############################################################################

#Probit-Cauchit

clm_res<-vector("list",500)
clm2_res<-vector("list",500)
clm3_res<-vector("list",500)
ls_res<-vector("list",500)
ls2_res<-vector("list",500)
IQR_clm_res<-vector("list",500)
IQR_ls_res<-vector("list",500)
p_value_clm<-vector("list",500)
p_value_ls<-vector("list",500)
n <- 500
for (i in 1:10000)
{
  set.seed(i)
  # covariate
  n<-500
  
  alpha<-16;beta_1<--8;beta_2<-1
  thrd<-c(0,4,8,12)
  
  #X<-rnorm(n,mean=3,sd=2)
  X<-runif(n,1,7)
  RES<-rcauchy(500)
  #RES<-rcauchy(500,0.7,0.01)
  #qqnorm(RES,xlim=c(-4,4),ylim=c(-4,4))
  #abline(0,1)
  
  Z<-alpha+beta_1*X+beta_2*X^2+RES
  W<-ordinalize(Z,thrd)
  table(W)
  
  X_1<-X;X_2<-X^2
  
  #lrmfit<-lrm(yc~x,data=data.frame(y=yc,x=x),x=TRUE,y=TRUE)
  model1<-orm(as.ordered(W-1)~X_1,family=probit,x=TRUE,y=TRUE)
  model2<-orm(as.ordered(W-1)~X_1,family=cauchit,x=TRUE,y=TRUE,linear.predictors=TRUE)
  model3<-orm(as.ordered(W-1)~X_1,family=logistic,x=TRUE,y=TRUE)
  par(mfrow=c(1,2))
  
  # #D-S residuals
  # clm.residuals = function(obj) {
  #   preds = predict(obj, type="cum.prob")
  #   residuals = runif(length(preds$cprob1))*(preds$cprob1-preds$cprob2) + preds$cprob2
  #   return(qnorm(residuals))}
  # 
  ls_res[[i]]<-residuals(model1,type="li.shepherd")
  
  ls2_res[[i]]<-residuals(model2,type="li.shepherd")
  
  ls3_res[[i]]<-residuals(model3,type="li.shepherd")
  
}
#warnings singularity
#Tests of normality
p_value_clm<-vector("list",500)
p_value_clm2<-vector("list",500)
p_value_clm3<-vector("list",500)
p_value_ls<-vector("list",500)
p_value_ls2<-vector("list",500)
p_value_ls3<-vector("list",500)
st_clm<-vector("list",500)
st_clm2<-vector("list",500)
ks_results<-vector("list",500)
ks1_results<-vector("list",500)
ks2_results<-vector("list",500)
ks_ls_results<-vector("list",500)
ks2_ls_results<-vector("list",500)
ks3_ls_results<-vector("list",500)
p_values_ks<-vector("list",500)
p_values_ks1<-vector("list",500)
p_values_ks2<-vector("list",500)
p_values_ksls<-vector("list",500)
p_values_ksls2<-vector("list",500)
p_values_ksls3<-vector("list",500)
for (i in 1:10000)
{
  #shapiro.test tests the NULL hypothesis that the samples came from a Normal distribution.
  # shapiro.test(clm_res[[i]])
  shapiro.test(ls_res[[i]]) 
  # p_value_clm[[i]]<-shapiro.test(clm_res[[i]])$p.value
  # p_value_clm2[[i]]<-shapiro.test(clm2_res[[i]])$p.value
  # p_value_clm3[[i]]<-shapiro.test(clm3_res[[i]])$p.value
  p_value_ls[[i]]<-shapiro.test(ls_res[[i]])$p.value
  p_value_ls2[[i]]<-shapiro.test(ls2_res[[i]])$p.value
  p_value_ls3[[i]]<-shapiro.test(ls3_res[[i]])$p.value
  # st_clm[[i]]<-shapiro.test(clm_res[[i]])$statistic
  # st_clm2[[i]]<-shapiro.test(clm2_res[[i]])$statistic
  # ks_results[[i]]<-ks.test(unlist(clm_res[[i]]),unlist(clm2_res[[i]]))
  # #ks1_results[[i]]<-ks.test(unlist(clm_res[[i]]),"punif",0,1) #0
  # #ks2_results[[i]]<-ks.test(unlist(clm2_res[[i]]),"punif",0,1) #0
  # ks_results[[i]]<-ks.test(unlist(clm_res[[i]]),unlist(clm2_res[[i]]))
  ks_ls_results[[i]]<-ks.test(unlist(ls_res[[i]]),unlist(ls2_res[[i]]))
  ks2_ls_results[[i]]<-ks.test(unlist(ls2_res[[i]]),"punif",0,1) #0
  ks3_ls_results[[i]]<-ks.test(unlist(ls3_res[[i]]),"punif",0,1) #0
  #p_values_ks[[i]]<-ks_results[[i]]$p.value
  #p_values_ks1[[i]]<-ks1_results[[i]]$p.value
  #p_values_ks2[[i]]<-ks1_results[[i]]$p.value
  p_values_ksls[[i]]<-ks_ls_results[[i]]$p.value
  p_values_ksls2[[i]]<-ks2_ls_results[[i]]$p.value
  p_values_ksls3[[i]]<-ks3_ls_results[[i]]$p.value
  #hist(unlist(p_values_ks[[i]]))
}
par(mfrow=c(1,1))
hist(unlist(p_values_ksls),main="",xlab="p-values from K-S test for L-S residuals probit-Cauchit",cex.lab=1.5,ylim=c(0,8150))

which(unlist(p_values_ksls)>0.05)
length(which(unlist(p_values_ksls)>0.05))
length(which(unlist(p_values_ksls)>0.05))/10000
length(which(unlist(p_values_ksls2)>0.05))/10000
length(which(unlist(p_values_ksls3)>0.05))/10000
#Normal values - Results from Shapiro-Wilk Normality Test. If p>0.05, we  cannot reject  Null hypothesis Normal distrib.

length(which(unlist(p_value_ls)>0.05))
length(which(unlist(p_value_ls)>0.05))/10000
length(which(p_value_ls2>0.05))/10000
length(which(p_value_ls3>0.05))/10000

#Empirical cumulative distribution function of p-values from Shapiro-Wilk test
#par(mar=c(4.1,4.1,2.0,1.1))
par(mfrow=c(1,3))
plot(ecdf(unlist(p_value_ls3)),main="Logit link",cex.axis=1.5,cex.main=1.5,cex.lab=1.5)
plot(ecdf(unlist(p_value_ls)),main="Probit link",cex.axis=1.5,cex.main=1.5,cex.lab=1.5)
plot(ecdf(unlist(p_value_ls2)),main="Cauchit link",cex.axis=1.5,cex.main=1.5,cex.lab=1.5)

#############################################################################
#############################################################################

#Logit-Cauchit

clm_res<-vector("list",500)
clm2_res<-vector("list",500)
clm3_res<-vector("list",500)
ls_res<-vector("list",500)
ls2_res<-vector("list",500)
ls3_res<-vector("list",500)
IQR_clm_res<-vector("list",500)
IQR_ls_res<-vector("list",500)
p_value_clm<-vector("list",500)
p_value_clm2<-vector("list",500)
p_value_clm3<-vector("list",500)
p_value_ls<-vector("list",500)
p_value_ls2<-vector("list",500)
p_value_ls3<-vector("list",500)
n <- 500
for (i in 1:10000)
{
  set.seed(i)
  # covariate
  n<-500
  
  alpha<-16;beta_1<--8;beta_2<-1
  thrd<-c(0,4,8,12)
  
  #X<-rnorm(n,mean=3,sd=2)
  X<-runif(n,1,7)
  RES<-rcauchy(500)
  #RES<-rcauchy(500,0.7,0.01)
  #qqnorm(RES,xlim=c(-4,4),ylim=c(-4,4))
  #abline(0,1)
  
  Z<-alpha+beta_1*X+beta_2*X^2+RES
  W<-ordinalize(Z,thrd)
  table(W)
  
  X_1<-X;X_2<-X^2
  
  #lrmfit<-lrm(yc~x,data=data.frame(y=yc,x=x),x=TRUE,y=TRUE)
  model1 <- orm(as.ordered(W-1)~X_1,family=logistic,x=TRUE,y=TRUE,linear.predictors=TRUE)
  model2 <- orm(as.ordered(W-1)~X_1,family=cauchit,x=TRUE,y=TRUE,linear.predictors=TRUE)
  model3<-orm(as.ordered(W-1)~X_1,family=probit,x=TRUE,y=TRUE,linear.predictors=TRUE)
  par(mfrow=c(1,2))
  
  
  
  #D-S residuals
  # clm.residuals = function(obj) {
  #   preds = predict(obj, type="cum.prob")
  #   residuals = runif(length(preds$cprob1))*(preds$cprob1-preds$cprob2) + preds$cprob2
  #   return(qnorm(residuals))}
  
  ls_res[[i]]<-residuals(model1,type="li.shepherd")
  
  ls2_res[[i]]<-residuals(model2,type="li.shepherd")
  
  ls3_res[[i]]<-residuals(model3,type="li.shepherd")
  
  
}
#warnings singularity
#Tests of normality
# p_value_clm<-vector("list",500)
# p_value_clm2<-vector("list",500)
# p_value_clm3<-vector("list",500)
p_value_ls<-vector("list",500)
p_value_ls2<-vector("list",500)
p_value_ls3<-vector("list",500)
# st_clm<-vector("list",500)
# st_clm2<-vector("list",500)
# ks_results<-vector("list",500)
# ks1_results<-vector("list",500)
# ks2_results<-vector("list",500)
ks_ls_results<-vector("list",500)
ks_ls2_results<-vector("list",500)
ks_ls3_results<-vector("list",500)
p_values_ks<-vector("list",500)
p_values_ks1<-vector("list",500)
p_values_ks2<-vector("list",500)
p_values_ksls<-vector("list",500)
p_values_ks1ls<-vector("list",500)
p_values_ks2ls<-vector("list",500)
for (i in 1:10000)
{
  #shapiro.test tests the NULL hypothesis that the samples came from a Normal distribution.
  # shapiro.test(clm_res[[i]])
  # #shapiro.test(ls_res[[i]]) 
  # p_value_clm[[i]]<-shapiro.test(clm_res[[i]])$p.value
  # p_value_clm2[[i]]<-shapiro.test(clm2_res[[i]])$p.value
  # p_value_clm3[[i]]<-shapiro.test(clm3_res[[i]])$p.value
  p_value_ls[[i]]<-shapiro.test(ls_res[[i]])$p.value
  p_value_ls2[[i]]<-shapiro.test(ls2_res[[i]])$p.value
  p_value_ls3[[i]]<-shapiro.test(ls3_res[[i]])$p.value
  # st_clm[[i]]<-shapiro.test(clm_res[[i]])$statistic
  # st_clm2[[i]]<-shapiro.test(clm2_res[[i]])$statistic
  # ks_results[[i]]<-ks.test(unlist(clm_res[[i]]),unlist(clm2_res[[i]]))
  # #ks1_results[[i]]<-ks.test(unlist(clm_res[[i]]),"punif",0,1) #0
  # #ks2_results[[i]]<-ks.test(unlist(clm2_res[[i]]),"punif",0,1) #0
  # ks_results[[i]]<-ks.test(unlist(clm_res[[i]]),unlist(clm2_res[[i]]))
  ks_ls_results[[i]]<-ks.test(unlist(ls_res[[i]]),unlist(ls2_res[[i]]))
  ks_ls2_results[[i]]<-ks.test(unlist(ls_res[[i]]),"punif",0,1) #0
  ks_ls3_results[[i]]<-ks.test(unlist(ls2_res[[i]]),"punif",0,1) #0
  # p_values_ks[[i]]<-ks_results[[i]]$p.value
  #p_values_ks1[[i]]<-ks1_results[[i]]$p.value
  #p_values_ks2[[i]]<-ks1_results[[i]]$p.value
  p_values_ksls[[i]]<-ks_ls_results[[i]]$p.value
  p_values_ksls2[[i]]<-ks_ls2_results[[i]]$p.value
  p_values_ksls3[[i]]<-ks_ls3_results[[i]]$p.value
  #hist(unlist(p_values_ks[[i]]))
}
par(mfrow=c(1,1))
hist(unlist(p_values_ksls),main="",xlab="p-values from K-S test for L-S residuals logit-Cauchit",cex.lab=1.5,ylim=c(0,8600))

which(unlist(p_values_ksls)<=0.05)
length(which(unlist(p_values_ksls)>0.05))

length(which(unlist(p_values_ksls)>0.05))/10000
#[1] 0.9568
length(which(unlist(p_values_ksls2)>0.05))/10000
length(which(unlist(p_values_ksls3)>0.05))/10000

#Normal values - Results from Shapiro-Wilk Normality Test. If p>0.05, we  cannot reject  Null hypothesis Normal distrib.
length(which(p_value_ls>0.05))
length(which(p_value_ls>0.05))/10000
length(which(p_value_ls2>0.05))/10000
length(which(p_value_ls3>0.05))/10000
#[1] 0.0281

#Empirical cumulative distribution function of p-values from Shapiro-Wilk test
#par(mar=c(4.1,4.1,2.0,1.1))
par(mfrow=c(1,3))
plot(ecdf(unlist(p_value_ls)),main="Logit link",cex.axis=1.5,cex.main=1.5,cex.lab=1.5)
plot(ecdf(unlist(p_value_ls2)),main="Cauchit link",cex.axis=1.5,cex.main=1.5,cex.lab=1.5)
plot(ecdf(unlist(p_value_ls3)),main="Probit link",cex.axis=1.5,cex.main=1.5,cex.lab=1.5)

###########################################################################################
###########################################################################################

#####(c) Unconstrained (-1.5,0,1,3)
ordinalize<-function(z,threshold){ 
  oo<-function(zz){
    ordinal.value<-1;index<-1
    while(index<=length(threshold) && zz>threshold[index]) {ordinal.value<-ordinal.value+1;index<-index+1}
    return(ordinal.value)
  }
  return(sapply(z,oo))
}

#Probit-Cauchit
clm_res<-vector("list",500)
clm2_res<-vector("list",500)
clm3_res<-vector("list",500)
ls_res<-vector("list",500)
ls2_res<-vector("list",500)
IQR_clm_res<-vector("list",500)
IQR_ls_res<-vector("list",500)
p_value_clm<-vector("list",500)
p_value_ls<-vector("list",500)
n <- 500
for (i in 1:10000)
{
  set.seed(i)
  # covariate
  n<-500
  
  alpha<-16;beta_1<--8;beta_2<-1
  thrd<-c(-1.5,0,1,3)
  #X<-rnorm(n,mean=3,sd=2)
  X<-runif(n,1,7)
  RES<-rcauchy(500)
  #RES<-rcauchy(500,0.7,0.01)
  #qqnorm(RES,xlim=c(-4,4),ylim=c(-4,4))
  #abline(0,1)
  
  Z<-alpha+beta_1*X+beta_2*X^2+RES
  W<-ordinalize(Z,thrd)
  table(W)
  
  X_1<-X;X_2<-X^2
  
  #lrmfit<-lrm(yc~x,data=data.frame(y=yc,x=x),x=TRUE,y=TRUE)
  model1<-orm(as.ordered(W-1)~X_1,family=probit,x=TRUE,y=TRUE)
  model2<-orm(as.ordered(W-1)~X_1,family=cauchit,x=TRUE,y=TRUE,linear.predictors=TRUE)
  model3<-orm(as.ordered(W-1)~X_1,family=logistic,x=TRUE,y=TRUE)
  par(mfrow=c(1,2))
  
  # #D-S residuals
  # clm.residuals = function(obj) {
  #   preds = predict(obj, type="cum.prob")
  #   residuals = runif(length(preds$cprob1))*(preds$cprob1-preds$cprob2) + preds$cprob2
  #   return(qnorm(residuals))}
  # 
  ls_res[[i]]<-residuals(model1,type="li.shepherd")
  
  ls2_res[[i]]<-residuals(model2,type="li.shepherd")
  
  ls3_res[[i]]<-residuals(model3,type="li.shepherd")
  
}
#warnings singularity
#Tests of normality
p_value_clm<-vector("list",500)
p_value_clm2<-vector("list",500)
p_value_clm3<-vector("list",500)
p_value_ls<-vector("list",500)
p_value_ls2<-vector("list",500)
p_value_ls3<-vector("list",500)
st_clm<-vector("list",500)
st_clm2<-vector("list",500)
ks_results<-vector("list",500)
ks1_results<-vector("list",500)
ks2_results<-vector("list",500)
ks_ls_results<-vector("list",500)
ks2_ls_results<-vector("list",500)
ks3_ls_results<-vector("list",500)
p_values_ks<-vector("list",500)
p_values_ks1<-vector("list",500)
p_values_ks2<-vector("list",500)
p_values_ksls<-vector("list",500)
p_values_ksls2<-vector("list",500)
p_values_ksls3<-vector("list",500)
for (i in 1:10000)
{
  #shapiro.test tests the NULL hypothesis that the samples came from a Normal distribution.
  # shapiro.test(clm_res[[i]])
  shapiro.test(ls_res[[i]]) 
  # p_value_clm[[i]]<-shapiro.test(clm_res[[i]])$p.value
  # p_value_clm2[[i]]<-shapiro.test(clm2_res[[i]])$p.value
  # p_value_clm3[[i]]<-shapiro.test(clm3_res[[i]])$p.value
  p_value_ls[[i]]<-shapiro.test(ls_res[[i]])$p.value
  p_value_ls2[[i]]<-shapiro.test(ls2_res[[i]])$p.value
  p_value_ls3[[i]]<-shapiro.test(ls3_res[[i]])$p.value
  # st_clm[[i]]<-shapiro.test(clm_res[[i]])$statistic
  # st_clm2[[i]]<-shapiro.test(clm2_res[[i]])$statistic
  # ks_results[[i]]<-ks.test(unlist(clm_res[[i]]),unlist(clm2_res[[i]]))
  # #ks1_results[[i]]<-ks.test(unlist(clm_res[[i]]),"punif",0,1) #0
  # #ks2_results[[i]]<-ks.test(unlist(clm2_res[[i]]),"punif",0,1) #0
  # ks_results[[i]]<-ks.test(unlist(clm_res[[i]]),unlist(clm2_res[[i]]))
  ks_ls_results[[i]]<-ks.test(unlist(ls_res[[i]]),unlist(ls2_res[[i]]))
  ks2_ls_results[[i]]<-ks.test(unlist(ls2_res[[i]]),"punif",0,1) #0
  ks3_ls_results[[i]]<-ks.test(unlist(ls3_res[[i]]),"punif",0,1) #0
  #p_values_ks[[i]]<-ks_results[[i]]$p.value
  #p_values_ks1[[i]]<-ks1_results[[i]]$p.value
  #p_values_ks2[[i]]<-ks1_results[[i]]$p.value
  p_values_ksls[[i]]<-ks_ls_results[[i]]$p.value
  p_values_ksls2[[i]]<-ks2_ls_results[[i]]$p.value
  p_values_ksls3[[i]]<-ks3_ls_results[[i]]$p.value
  #hist(unlist(p_values_ks[[i]]))
}
par(mfrow=c(1,1))
hist(unlist(p_values_ksls),main="",xlab="p-values from K-S test for L-S residuals probit-Cauchit",cex.lab=1.5,ylim=c(0,8000))

which(unlist(p_values_ksls)>0.05)
length(which(unlist(p_values_ksls)>0.05))
length(which(unlist(p_values_ksls)>0.05))/10000

#Normal values - Results from Shapiro-Wilk Normality Test. If p>0.05, we  cannot reject  Null hypothesis Normal distrib.

length(which(unlist(p_value_ls)>0.05))
length(which(unlist(p_value_ls)>0.05))/10000
0

#Empirical cumulative distribution function of p-values from Shapiro-Wilk test
#par(mar=c(4.1,4.1,2.0,1.1))
par(mfrow=c(1,3))
plot(ecdf(unlist(p_value_ls3)),main="Logit link",cex.axis=1.5,cex.main=1.5,cex.lab=1.5)
plot(ecdf(unlist(p_value_ls)),main="Probit link",cex.axis=1.5,cex.main=1.5,cex.lab=1.5)
plot(ecdf(unlist(p_value_ls2)),main="Cauchit link",cex.axis=1.5,cex.main=1.5,cex.lab=1.5)

#############################################################################
#############################################################################

#Logit-Cauchit

clm_res<-vector("list",500)
clm2_res<-vector("list",500)
clm3_res<-vector("list",500)
ls_res<-vector("list",500)
ls2_res<-vector("list",500)
ls3_res<-vector("list",500)
IQR_clm_res<-vector("list",500)
IQR_ls_res<-vector("list",500)
p_value_clm<-vector("list",500)
p_value_clm2<-vector("list",500)
p_value_clm3<-vector("list",500)
p_value_ls<-vector("list",500)
p_value_ls2<-vector("list",500)
p_value_ls3<-vector("list",500)
n <- 500
for (i in 1:10000)
{
  set.seed(i)
  # covariate
  n<-500
  
  alpha<-16;beta_1<--8;beta_2<-1
  thrd<-c(-1.5,0,1,3)
  #X<-rnorm(n,mean=3,sd=2)
  X<-runif(n,1,7)
  RES<-rcauchy(500)
  #RES<-rcauchy(500,0.7,0.01)
  #qqnorm(RES,xlim=c(-4,4),ylim=c(-4,4))
  #abline(0,1)
  
  Z<-alpha+beta_1*X+beta_2*X^2+RES
  W<-ordinalize(Z,thrd)
  table(W)
  
  X_1<-X;X_2<-X^2
  
  #lrmfit<-lrm(yc~x,data=data.frame(y=yc,x=x),x=TRUE,y=TRUE)
  model1 <- orm(as.ordered(W-1)~X_1,family=logistic,x=TRUE,y=TRUE,linear.predictors=TRUE)
  model2 <- orm(as.ordered(W-1)~X_1,family=cauchit,x=TRUE,y=TRUE,linear.predictors=TRUE)
  model3<-orm(as.ordered(W-1)~X_1,family=probit,x=TRUE,y=TRUE,linear.predictors=TRUE)
  par(mfrow=c(1,2))
  
  
  
  #D-S residuals
  # clm.residuals = function(obj) {
  #   preds = predict(obj, type="cum.prob")
  #   residuals = runif(length(preds$cprob1))*(preds$cprob1-preds$cprob2) + preds$cprob2
  #   return(qnorm(residuals))}
  
  ls_res[[i]]<-residuals(model1,type="li.shepherd")
  
  ls2_res[[i]]<-residuals(model2,type="li.shepherd")
  
  ls3_res[[i]]<-residuals(model3,type="li.shepherd")
  
  
}
#warnings singularity
#Tests of normality
# p_value_clm<-vector("list",500)
# p_value_clm2<-vector("list",500)
# p_value_clm3<-vector("list",500)
p_value_ls<-vector("list",500)
p_value_ls2<-vector("list",500)
p_value_ls3<-vector("list",500)
# st_clm<-vector("list",500)
# st_clm2<-vector("list",500)
# ks_results<-vector("list",500)
# ks1_results<-vector("list",500)
# ks2_results<-vector("list",500)
ks_ls_results<-vector("list",500)
ks_ls2_results<-vector("list",500)
ks_ls3_results<-vector("list",500)
p_values_ks<-vector("list",500)
p_values_ks1<-vector("list",500)
p_values_ks2<-vector("list",500)
p_values_ksls<-vector("list",500)
p_values_ks1ls<-vector("list",500)
p_values_ks2ls<-vector("list",500)
for (i in 1:10000)
{
  #shapiro.test tests the NULL hypothesis that the samples came from a Normal distribution.
  # shapiro.test(clm_res[[i]])
  # #shapiro.test(ls_res[[i]]) 
  # p_value_clm[[i]]<-shapiro.test(clm_res[[i]])$p.value
  # p_value_clm2[[i]]<-shapiro.test(clm2_res[[i]])$p.value
  # p_value_clm3[[i]]<-shapiro.test(clm3_res[[i]])$p.value
  p_value_ls[[i]]<-shapiro.test(ls_res[[i]])$p.value
  p_value_ls2[[i]]<-shapiro.test(ls2_res[[i]])$p.value
  p_value_ls3[[i]]<-shapiro.test(ls3_res[[i]])$p.value
  # st_clm[[i]]<-shapiro.test(clm_res[[i]])$statistic
  # st_clm2[[i]]<-shapiro.test(clm2_res[[i]])$statistic
  # ks_results[[i]]<-ks.test(unlist(clm_res[[i]]),unlist(clm2_res[[i]]))
  # #ks1_results[[i]]<-ks.test(unlist(clm_res[[i]]),"punif",0,1) #0
  # #ks2_results[[i]]<-ks.test(unlist(clm2_res[[i]]),"punif",0,1) #0
  # ks_results[[i]]<-ks.test(unlist(clm_res[[i]]),unlist(clm2_res[[i]]))
  ks_ls_results[[i]]<-ks.test(unlist(ls_res[[i]]),unlist(ls2_res[[i]]))
  ks_ls2_results[[i]]<-ks.test(unlist(ls_res[[i]]),"punif",0,1) #0
  ks_ls3_results[[i]]<-ks.test(unlist(ls2_res[[i]]),"punif",0,1) #0
  # p_values_ks[[i]]<-ks_results[[i]]$p.value
  #p_values_ks1[[i]]<-ks1_results[[i]]$p.value
  #p_values_ks2[[i]]<-ks1_results[[i]]$p.value
  p_values_ksls[[i]]<-ks_ls_results[[i]]$p.value
  p_values_ksls2[[i]]<-ks_ls2_results[[i]]$p.value
  p_values_ksls3[[i]]<-ks_ls3_results[[i]]$p.value
  #hist(unlist(p_values_ks[[i]]))
}
par(mfrow=c(1,1))
hist(unlist(p_values_ksls),main="",xlab="p-values from K-S test for L-S residuals logit-Cauchit",cex.lab=1.5,ylim=c(0,8600))

which(unlist(p_values_ksls)<=0.05)
length(which(unlist(p_values_ksls)>0.05))

length(which(unlist(p_values_ksls)>0.05))/10000
#[1] 0.9568

#Normal values - Results from Shapiro-Wilk Normality Test. If p>0.05, we  cannot reject  Null hypothesis Normal distrib.
length(which(p_value_ls>0.05))
length(which(p_value_ls>0.05))/10000
#[1] 0.0281

#Empirical cumulative distribution function of p-values from Shapiro-Wilk test
#par(mar=c(4.1,4.1,2.0,1.1))
par(mfrow=c(1,3))
plot(ecdf(unlist(p_value_ls)),main="Logit link",cex.axis=1.5,cex.main=1.5,cex.lab=1.5)
plot(ecdf(unlist(p_value_ls2)),main="Cauchit link",cex.axis=1.5,cex.main=1.5,cex.lab=1.5)
plot(ecdf(unlist(p_value_ls3)),main="Probit link",cex.axis=1.5,cex.main=1.5,cex.lab=1.5)

###########################################################################################
###########################################################################################


#####(d) Symmetric (-36,-6,34,64)
ordinalize<-function(z,threshold){ 
  oo<-function(zz){
    ordinal.value<-1;index<-1
    while(index<=length(threshold) && zz>threshold[index]) {ordinal.value<-ordinal.value+1;index<-index+1}
    return(ordinal.value)
  }
  return(sapply(z,oo))
}


#############################################################################
#############################################################################

#Probit-Cauchit

clm_res<-vector("list",500)
clm2_res<-vector("list",500)
clm3_res<-vector("list",500)
ls_res<-vector("list",500)
ls2_res<-vector("list",500)
IQR_clm_res<-vector("list",500)
IQR_ls_res<-vector("list",500)
p_value_clm<-vector("list",500)
p_value_ls<-vector("list",500)
n <- 500
for (i in 1:10000)
{
  set.seed(i)
  # covariate
  n<-500
  
  alpha<-16;beta_1<--8;beta_2<-1
  thrd<-c(-36,-6,34,64)
  
  #X<-rnorm(n,mean=3,sd=2)
  X<-runif(n,1,7)
  RES<-rcauchy(500)
  #RES<-rcauchy(500,0.7,0.01)
  #qqnorm(RES,xlim=c(-4,4),ylim=c(-4,4))
  #abline(0,1)
  
  Z<-alpha+beta_1*X+beta_2*X^2+RES
  W<-ordinalize(Z,thrd)
  table(W)
  
  X_1<-X;X_2<-X^2
  
  #lrmfit<-lrm(yc~x,data=data.frame(y=yc,x=x),x=TRUE,y=TRUE)
  model1<-orm(as.ordered(W-1)~X_1,family=probit,x=TRUE,y=TRUE)
  model2<-orm(as.ordered(W-1)~X_1,family=cauchit,x=TRUE,y=TRUE,linear.predictors=TRUE)
  model3<-orm(as.ordered(W-1)~X_1,family=logistic,x=TRUE,y=TRUE)
  par(mfrow=c(1,2))
  
  # #D-S residuals
  # clm.residuals = function(obj) {
  #   preds = predict(obj, type="cum.prob")
  #   residuals = runif(length(preds$cprob1))*(preds$cprob1-preds$cprob2) + preds$cprob2
  #   return(qnorm(residuals))}
  # 
  ls_res[[i]]<-residuals(model1,type="li.shepherd")
  
  ls2_res[[i]]<-residuals(model2,type="li.shepherd")
  
  ls3_res[[i]]<-residuals(model3,type="li.shepherd")
  
}
#warnings singularity
#Tests of normality
p_value_clm<-vector("list",500)
p_value_clm2<-vector("list",500)
p_value_clm3<-vector("list",500)
p_value_ls<-vector("list",500)
p_value_ls2<-vector("list",500)
p_value_ls3<-vector("list",500)
st_clm<-vector("list",500)
st_clm2<-vector("list",500)
ks_results<-vector("list",500)
ks1_results<-vector("list",500)
ks2_results<-vector("list",500)
ks_ls_results<-vector("list",500)
ks2_ls_results<-vector("list",500)
ks3_ls_results<-vector("list",500)
p_values_ks<-vector("list",500)
p_values_ks1<-vector("list",500)
p_values_ks2<-vector("list",500)
p_values_ksls<-vector("list",500)
p_values_ksls2<-vector("list",500)
p_values_ksls3<-vector("list",500)
for (i in 1:10000)
{
  #shapiro.test tests the NULL hypothesis that the samples came from a Normal distribution.
  # shapiro.test(clm_res[[i]])
  shapiro.test(ls_res[[i]]) 
  # p_value_clm[[i]]<-shapiro.test(clm_res[[i]])$p.value
  # p_value_clm2[[i]]<-shapiro.test(clm2_res[[i]])$p.value
  # p_value_clm3[[i]]<-shapiro.test(clm3_res[[i]])$p.value
  p_value_ls[[i]]<-shapiro.test(ls_res[[i]])$p.value
  p_value_ls2[[i]]<-shapiro.test(ls2_res[[i]])$p.value
  p_value_ls3[[i]]<-shapiro.test(ls3_res[[i]])$p.value
  # st_clm[[i]]<-shapiro.test(clm_res[[i]])$statistic
  # st_clm2[[i]]<-shapiro.test(clm2_res[[i]])$statistic
  # ks_results[[i]]<-ks.test(unlist(clm_res[[i]]),unlist(clm2_res[[i]]))
  # #ks1_results[[i]]<-ks.test(unlist(clm_res[[i]]),"punif",0,1) #0
  # #ks2_results[[i]]<-ks.test(unlist(clm2_res[[i]]),"punif",0,1) #0
  # ks_results[[i]]<-ks.test(unlist(clm_res[[i]]),unlist(clm2_res[[i]]))
  ks_ls_results[[i]]<-ks.test(unlist(ls_res[[i]]),unlist(ls2_res[[i]]))
  ks2_ls_results[[i]]<-ks.test(unlist(ls2_res[[i]]),"punif",0,1) #0
  ks3_ls_results[[i]]<-ks.test(unlist(ls3_res[[i]]),"punif",0,1) #0
  #p_values_ks[[i]]<-ks_results[[i]]$p.value
  #p_values_ks1[[i]]<-ks1_results[[i]]$p.value
  #p_values_ks2[[i]]<-ks1_results[[i]]$p.value
  p_values_ksls[[i]]<-ks_ls_results[[i]]$p.value
  p_values_ksls2[[i]]<-ks2_ls_results[[i]]$p.value
  p_values_ksls3[[i]]<-ks3_ls_results[[i]]$p.value
  #hist(unlist(p_values_ks[[i]]))
}
par(mfrow=c(1,1))
hist(unlist(p_values_ksls),main="",xlab="p-values from K-S test for L-S residuals probit-Cauchit",cex.lab=1.5,ylim=c(0,10000))

which(unlist(p_values_ksls)>0.05)
length(which(unlist(p_values_ksls)>0.05))
length(which(unlist(p_values_ksls)>0.05))/10000

#Normal values - Results from Shapiro-Wilk Normality Test. If p>0.05, we  cannot reject  Null hypothesis Normal distrib.

length(which(unlist(p_value_ls)>0.05))
length(which(unlist(p_value_ls)>0.05))/10000
0

#Empirical cumulative distribution function of p-values from Shapiro-Wilk test
#par(mar=c(4.1,4.1,2.0,1.1))
par(mfrow=c(1,3))
plot(ecdf(unlist(p_value_ls3)),main="Logit link",cex.axis=1.5,cex.main=1.5,cex.lab=1.5)
plot(ecdf(unlist(p_value_ls)),main="Probit link",cex.axis=1.5,cex.main=1.5,cex.lab=1.5)
plot(ecdf(unlist(p_value_ls2)),main="Cauchit link",cex.axis=1.5,cex.main=1.5,cex.lab=1.5)

#############################################################################
#############################################################################

#Logit-Cauchit

clm_res<-vector("list",500)
clm2_res<-vector("list",500)
clm3_res<-vector("list",500)
ls_res<-vector("list",500)
ls2_res<-vector("list",500)
ls3_res<-vector("list",500)
IQR_clm_res<-vector("list",500)
IQR_ls_res<-vector("list",500)
p_value_clm<-vector("list",500)
p_value_clm2<-vector("list",500)
p_value_clm3<-vector("list",500)
p_value_ls<-vector("list",500)
p_value_ls2<-vector("list",500)
p_value_ls3<-vector("list",500)
n <- 500
for (i in 1:10000)
{
  set.seed(i)
  # covariate
  n<-500
  
  alpha<-16;beta_1<--8;beta_2<-1
  thrd<-c(-36,-6,34,64)
  
  #X<-rnorm(n,mean=3,sd=2)
  X<-runif(n,1,7)
  RES<-rcauchy(500)
  #RES<-rcauchy(500,0.7,0.01)
  #qqnorm(RES,xlim=c(-4,4),ylim=c(-4,4))
  #abline(0,1)
  
  Z<-alpha+beta_1*X+beta_2*X^2+RES
  W<-ordinalize(Z,thrd)
  table(W)
  
  X_1<-X;X_2<-X^2
  
  #lrmfit<-lrm(yc~x,data=data.frame(y=yc,x=x),x=TRUE,y=TRUE)
  model1 <- orm(as.ordered(W-1)~X_1,family=logistic,x=TRUE,y=TRUE,linear.predictors=TRUE)
  model2 <- orm(as.ordered(W-1)~X_1,family=cauchit,x=TRUE,y=TRUE,linear.predictors=TRUE)
  model3<-orm(as.ordered(W-1)~X_1,family=probit,x=TRUE,y=TRUE,linear.predictors=TRUE)
  par(mfrow=c(1,2))
  
  
  
  #D-S residuals
  # clm.residuals = function(obj) {
  #   preds = predict(obj, type="cum.prob")
  #   residuals = runif(length(preds$cprob1))*(preds$cprob1-preds$cprob2) + preds$cprob2
  #   return(qnorm(residuals))}
  
  ls_res[[i]]<-residuals(model1,type="li.shepherd")
  
  ls2_res[[i]]<-residuals(model2,type="li.shepherd")
  
  ls3_res[[i]]<-residuals(model3,type="li.shepherd")
  
  
}
#warnings singularity
#Tests of normality
# p_value_clm<-vector("list",500)
# p_value_clm2<-vector("list",500)
# p_value_clm3<-vector("list",500)
p_value_ls<-vector("list",500)
p_value_ls2<-vector("list",500)
p_value_ls3<-vector("list",500)
# st_clm<-vector("list",500)
# st_clm2<-vector("list",500)
# ks_results<-vector("list",500)
# ks1_results<-vector("list",500)
# ks2_results<-vector("list",500)
ks_ls_results<-vector("list",500)
ks_ls2_results<-vector("list",500)
ks_ls3_results<-vector("list",500)
p_values_ks<-vector("list",500)
p_values_ks1<-vector("list",500)
p_values_ks2<-vector("list",500)
p_values_ksls<-vector("list",500)
p_values_ks1ls<-vector("list",500)
p_values_ks2ls<-vector("list",500)
for (i in 1:10000)
{
  #shapiro.test tests the NULL hypothesis that the samples came from a Normal distribution.
  # shapiro.test(clm_res[[i]])
  # #shapiro.test(ls_res[[i]]) 
  # p_value_clm[[i]]<-shapiro.test(clm_res[[i]])$p.value
  # p_value_clm2[[i]]<-shapiro.test(clm2_res[[i]])$p.value
  # p_value_clm3[[i]]<-shapiro.test(clm3_res[[i]])$p.value
  p_value_ls[[i]]<-shapiro.test(ls_res[[i]])$p.value
  p_value_ls2[[i]]<-shapiro.test(ls2_res[[i]])$p.value
  p_value_ls3[[i]]<-shapiro.test(ls3_res[[i]])$p.value
  # st_clm[[i]]<-shapiro.test(clm_res[[i]])$statistic
  # st_clm2[[i]]<-shapiro.test(clm2_res[[i]])$statistic
  # ks_results[[i]]<-ks.test(unlist(clm_res[[i]]),unlist(clm2_res[[i]]))
  # #ks1_results[[i]]<-ks.test(unlist(clm_res[[i]]),"punif",0,1) #0
  # #ks2_results[[i]]<-ks.test(unlist(clm2_res[[i]]),"punif",0,1) #0
  # ks_results[[i]]<-ks.test(unlist(clm_res[[i]]),unlist(clm2_res[[i]]))
  ks_ls_results[[i]]<-ks.test(unlist(ls_res[[i]]),unlist(ls2_res[[i]]))
  ks_ls2_results[[i]]<-ks.test(unlist(ls_res[[i]]),"punif",0,1) #0
  ks_ls3_results[[i]]<-ks.test(unlist(ls2_res[[i]]),"punif",0,1) #0
  # p_values_ks[[i]]<-ks_results[[i]]$p.value
  #p_values_ks1[[i]]<-ks1_results[[i]]$p.value
  #p_values_ks2[[i]]<-ks1_results[[i]]$p.value
  p_values_ksls[[i]]<-ks_ls_results[[i]]$p.value
  p_values_ksls2[[i]]<-ks_ls2_results[[i]]$p.value
  p_values_ksls3[[i]]<-ks_ls3_results[[i]]$p.value
  #hist(unlist(p_values_ks[[i]]))
}
par(mfrow=c(1,1))
hist(unlist(p_values_ksls),main="",xlab="p-values from K-S test for L-S residuals logit-Cauchit",cex.lab=1.5,ylim=c(0,10000))

which(unlist(p_values_ksls)<=0.05)
length(which(unlist(p_values_ksls)>0.05))

length(which(unlist(p_values_ksls)>0.05))/10000
#[1] 0.9568

#Normal values - Results from Shapiro-Wilk Normality Test. If p>0.05, we  cannot reject  Null hypothesis Normal distrib.
length(which(p_value_ls>0.05))
length(which(p_value_ls>0.05))/10000
#[1] 0.0281

#Empirical cumulative distribution function of p-values from Shapiro-Wilk test
#par(mar=c(4.1,4.1,2.0,1.1))
par(mfrow=c(1,3))
plot(ecdf(unlist(p_value_ls)),main="Logit link",cex.axis=1.5,cex.main=1.5,cex.lab=1.5)
plot(ecdf(unlist(p_value_ls2)),main="Cauchit link",cex.axis=1.5,cex.main=1.5,cex.lab=1.5)
plot(ecdf(unlist(p_value_ls3)),main="Probit link",cex.axis=1.5,cex.main=1.5,cex.lab=1.5)

####################################################################
####################################################################


###########################
#####################
#   Surrogate RESIDUALS   #
#####################
library(VGAM)
library(sure)
#####################

###########################################################################################
###########################################################################################

#(a) Equidistant  example  1 & symmetric (-16,-12,-8,-4)
ordinalize<-function(z,threshold){
  oo<-function(zz){
    ordinal.value<-1;index<-1
    while(index<=length(threshold) && zz>threshold[index]) {ordinal.value<-ordinal.value+1;index<-index+1}
    return(ordinal.value)
  }
  return(sapply(z,oo))
}


#############################################################################
#############################################################################

#Probit-Cauchit

clm_res<-vector("list",500)
clm2_res<-vector("list",500)
clm3_res<-vector("list",500)
ls_res<-vector("list",500)
ls2_res<-vector("list",500)
ls3_res<-vector("list",500)
ss_res<-vector("list",500)
ss2_res<-vector("list",500)
ss3_res<-vector("list",500)
IQR_clm_res<-vector("list",500)
IQR_ls_res<-vector("list",500)
p_value_clm<-vector("list",500)
p_value_ls<-vector("list",500)
p_value_ss<-vector("list",500)
n <- 500
for (i in 1:10000)
{
  set.seed(i)
  # covariate
  n<-500

  alpha<-16;beta_1<--8;beta_2<-1
  thrd<-c(-16,-12,-8,-4)

  #X<-rnorm(n,mean=3,sd=2)
  X<-runif(n,1,7)
  RES<-rcauchy(500)
  #RES<-rcauchy(500,0.7,0.01)
  #qqnorm(RES,xlim=c(-4,4),ylim=c(-4,4))
  #abline(0,1)

  Z<-alpha+beta_1*X+beta_2*X^2+RES
  W<-ordinalize(Z,thrd)
  table(W)

  X_1<-X;X_2<-X^2

  #lrmfit<-lrm(yc~x,data=data.frame(y=yc,x=x),x=TRUE,y=TRUE)
  # model1<-orm(as.ordered(W-1)~X_1,family=probit,x=TRUE,y=TRUE)
  # model2<-orm(as.ordered(W-1)~X_1,family=cauchit,x=TRUE,y=TRUE,linear.predictors=TRUE)
  # model3<-orm(as.ordered(W-1)~X_1,family=logistic,x=TRUE,y=TRUE)
  #
  #Fit for surrogate residuals
  models1<-vglm(formula=as.ordered(W-1)~X_1+X_2,family = cumulative(link =probit,parallel = TRUE))
  models2<-vglm(formula=as.ordered(W-1)~X_1+X_2,family = cumulative(link =cauchit,parallel = TRUE))
  models3<-vglm(formula=as.ordered(W-1)~X_1+X_2,family = cumulative(link =logit,parallel = TRUE))

  par(mfrow=c(1,2))

  # #D-S residuals
  # clm.residuals = function(obj) {
  #   preds = predict(obj, type="cum.prob")
  #   residuals = runif(length(preds$cprob1))*(preds$cprob1-preds$cprob2) + preds$cprob2
  #   return(qnorm(residuals))}
  #
  # ls_res[[i]]<-residuals(model1,type="li.shepherd")
  #
  # ls2_res[[i]]<-residuals(model2,type="li.shepherd")
  #
  # ls3_res[[i]]<-residuals(model3,type="li.shepherd")
  #
  ss_res[[i]]<-resids(models1)
  ss2_res[[i]]<-resids(models2)
  ss3_res[[i]]<-resids(models3)
}
#warnings singularity
#Tests of normality
p_value_clm<-vector("list",500)
p_value_clm2<-vector("list",500)
p_value_clm3<-vector("list",500)
p_value_ls<-vector("list",500)
p_value_ls2<-vector("list",500)
p_value_ls3<-vector("list",500)
p_value_ss<-vector("list",500)
p_value_ss2<-vector("list",500)
p_value_ss3<-vector("list",500)
st_clm<-vector("list",500)
st_clm2<-vector("list",500)
ks_results<-vector("list",500)
ks1_results<-vector("list",500)
ks2_results<-vector("list",500)
ks_ls_results<-vector("list",500)
ks2_ls_results<-vector("list",500)
ks3_ls_results<-vector("list",500)
ks_ss_results<-vector("list",500)
ks2_ss_results<-vector("list",500)
ks3_ss_results<-vector("list",500)
p_values_ks<-vector("list",500)
p_values_ks1<-vector("list",500)
p_values_ks2<-vector("list",500)
p_values_ks3<-vector("list",500)
p_values_ksls<-vector("list",500)
p_values_ksls2<-vector("list",500)
p_values_ksls3<-vector("list",500)
p_values_ksss<-vector("list",500)
p_values_ksss2<-vector("list",500)
p_values_ksss3<-vector("list",500)

for (i in 1:10000)
{
  #shapiro.test tests the NULL hypothesis that the samples came from a Normal distribution.
  # shapiro.test(clm_res[[i]])
  shapiro.test(ss_res[[i]])
  # p_value_clm[[i]]<-shapiro.test(clm_res[[i]])$p.value
  # p_value_clm2[[i]]<-shapiro.test(clm2_res[[i]])$p.value
  # p_value_clm3[[i]]<-shapiro.test(clm3_res[[i]])$p.value
  p_value_ss[[i]]<-shapiro.test(ss_res[[i]])$p.value
  p_value_ss2[[i]]<-shapiro.test(ss2_res[[i]])$p.value
  p_value_ss3[[i]]<-shapiro.test(ss3_res[[i]])$p.value
  # st_clm[[i]]<-shapiro.test(clm_res[[i]])$statistic
  # st_clm2[[i]]<-shapiro.test(clm2_res[[i]])$statistic
  # ks_results[[i]]<-ks.test(unlist(clm_res[[i]]),unlist(clm2_res[[i]]))
  # #ks1_results[[i]]<-ks.test(unlist(clm_res[[i]]),"punif",0,1) #0
  # #ks2_results[[i]]<-ks.test(unlist(clm2_res[[i]]),"punif",0,1) #0
  # ks_results[[i]]<-ks.test(unlist(clm_res[[i]]),unlist(clm2_res[[i]]))
  ks_ss_results[[i]]<-ks.test(unlist(ss_res[[i]]),unlist(ss2_res[[i]]))
  ks2_ss_results[[i]]<-ks.test(unlist(ss2_res[[i]]),"punif",0,1) #0
  ks3_ss_results[[i]]<-ks.test(unlist(ss3_res[[i]]),"punif",0,1) #0
  #p_values_ks[[i]]<-ks_results[[i]]$p.value
  #p_values_ks1[[i]]<-ks1_results[[i]]$p.value
  #p_values_ks2[[i]]<-ks1_results[[i]]$p.value
  p_values_ksss[[i]]<-ks_ss_results[[i]]$p.value
  p_values_ksss2[[i]]<-ks2_ss_results[[i]]$p.value
  p_values_ksss3[[i]]<-ks3_ss_results[[i]]$p.value
  #hist(unlist(p_values_ks[[i]]))
}
par(mfrow=c(1,1))
hist(unlist(p_values_ksss),main="",xlab="p-values from K-S test for L-S residuals probit-Cauchit",cex.lab=1.5,ylim=c(0,10000))

which(unlist(p_values_ksss)>0.05)
length(which(unlist(p_values_ksss)>0.05))
length(which(unlist(p_values_ksss)>0.05))/10000

#Normal values - Results from Shapiro-Wilk Normality Test. If p>0.05, we  cannot reject  Null hypothesis Normal distrib.

length(which(unlist(p_values_ks)>0.05))
length(which(unlist(p_values_ks)>0.05))/10000


#Empirical cumulative distribution function of p-values from Shapiro-Wilk test
#par(mar=c(4.1,4.1,2.0,1.1))
par(mfrow=c(1,3))
plot(ecdf(unlist(p_values_ksss3)),main="Logit link",cex.axis=1.5,cex.main=1.5,cex.lab=1.5)
plot(ecdf(unlist(p_values_ksss)),main="Probit link",cex.axis=1.5,cex.main=1.5,cex.lab=1.5)
plot(ecdf(unlist(p_values_ksss2)),main="Cauchit link",cex.axis=1.5,cex.main=1.5,cex.lab=1.5)

#############################################################################
#############################################################################

#Logit-Cauchit

clm_res<-vector("list",500)
clm2_res<-vector("list",500)
clm3_res<-vector("list",500)
ls_res<-vector("list",500)
ls2_res<-vector("list",500)
ss_res<-vector("list",500)
ss2_res<-vector("list",500)
ss3_res<-vector("list",500)
IQR_clm_res<-vector("list",500)
IQR_ls_res<-vector("list",500)
p_value_clm<-vector("list",500)
p_value_ls<-vector("list",500)
p_value_ss<-vector("list",500)

n <- 500
for (i in 1:10000)
{
  set.seed(i)
  # covariate
  n<-500
  
  alpha<-16;beta_1<--8;beta_2<-1
  thrd<-c(-16,-12,-8,-4)
  
  X<-runif(n,1,7)
  RES<-rcauchy(500)
  
  Z<-alpha+beta_1*X+beta_2*(X^2)+RES
  W<-ordinalize(Z,thrd)
  table(W)
  
  X_1<-X;X_2<-X^2
  
  #clm models using rms - orm
  models1<-orm(as.ordered(W-1)~X_1,family=logistic,x=TRUE,y=TRUE)
  models2<-orm(as.ordered(W-1)~X_1,family=cauchit,x=TRUE,y=TRUE,linear.predictors=TRUE)
  models3<-orm(as.ordered(W-1)~X_1,family=probit,x=TRUE,y=TRUE)
  
  ss_res[[i]]<-resids(models1)
  
  ss2_res[[i]]<-resids(models2)
  
  ss3_res[[i]]<-resids(models3)
  
  #Each of ss3_res[[1]] is length 500,  
  #but there are 1...10,000 ss3_res
  
}
#warnings singularity
#Tests of normality
p_value_clm<-vector("list",500)
p_value_clm2<-vector("list",500)
p_value_clm3<-vector("list",500)
p_value_ls<-vector("list",500)
p_value_ls2<-vector("list",500)
p_value_ls3<-vector("list",500)
p_value_ss<-vector("list",10000)
p_value_ss2<-vector("list",10000)
p_value_ss3<-vector("list",10000)
st_clm<-vector("list",500)
st_clm2<-vector("list",500)
ks_results<-vector("list",500)
ks1_results<-vector("list",500)
ks2_results<-vector("list",500)
ks_ss_results<-vector("list",500)
ks2_ss_results<-vector("list",500)
ks3_ss_results<-vector("list",500)
p_values_ks<-vector("list",500)
p_values_ks1<-vector("list",500)
p_values_ks2<-vector("list",500)
p_values_ksss<-vector("list",500)
p_values_ksss2<-vector("list",500)
p_values_ksss3<-vector("list",500)
for (i in 1:10000)
{
  #shapiro.test tests the NULL hypothesis that the samples came from a Normal distribution.
  # shapiro.test(clm_res[[i]])
  shapiro.test(ss_res[[i]]) 
  
  #p-values S-W
  p_value_ss[[i]]<-shapiro.test(ss_res[[i]])$p.value
  p_value_ss2[[i]]<-shapiro.test(ss2_res[[i]])$p.value
  p_value_ss3[[i]]<-shapiro.test(ss3_res[[i]])$p.value
  
  #K-S logit-Cauchit
  ks_ss_results[[i]]<-ks.test(unlist(ss_res[[i]]),unlist(ss2_res[[i]]))
  ks2_ss_results[[i]]<-ks.test(unlist(ss2_res[[i]]),"punif",0,1) #0
  ks3_ss_results[[i]]<-ks.test(unlist(ss3_res[[i]]),"punif",0,1) #0
  
  #p-values K-S
  p_values_ksss[[i]]<-ks_ss_results[[i]]$p.value
  p_values_ksss2[[i]]<-ks2_ss_results[[i]]$p.value
  p_values_ksss3[[i]]<-ks3_ss_results[[i]]$p.value
  
}

#Plot2
par(mfrow=c(1,1))
hist(unlist(p_values_ksss),main="",xlab="p-values from K-S test for Surrogate residuals logit-Cauchit",cex.lab=1.5,ylim=c(0,3000))

which(unlist(p_values_ksss)>0.05)
length(which(unlist(p_values_ksss)>0.05))
length(which(unlist(p_values_ksss)>0.05))/10000

#Normal values - Results from Shapiro-Wilk Normality Test. If p>0.05, we  cannot reject  Null hypothesis Normal distrib.

length(which(unlist(p_value_ss)>0.05))
length(which(unlist(p_value_ss)>0.05))/10000


#Empirical cumulative distribution function of p-values from Shapiro-Wilk test
#par(mar=c(4.1,4.1,2.0,1.1))
#Plot 3
par(mfrow=c(1,3))
plot(ecdf(unlist(p_value_ss)),main="Logistic link",cex.axis=1.5,cex.main=1.5,cex.lab=1.5)
plot(ecdf(unlist(p_value_ss3)),main="Probit link",cex.axis=1.5,cex.main=1.5,cex.lab=1.5)
plot(ecdf(unlist(p_value_ss2)),main="Cauchit link",cex.axis=1.5,cex.main=1.5,cex.lab=1.5)

###########################################################################################
###########################################################################################

#####(b) Equidistant example  2 (0,4,8,12) # CAUCHIT WORKS FOR THIS ONE 
ordinalize<-function(z,threshold){ 
  oo<-function(zz){
    ordinal.value<-1;index<-1
    while(index<=length(threshold) && zz>threshold[index]) {ordinal.value<-ordinal.value+1;index<-index+1}
    return(ordinal.value)
  }
  return(sapply(z,oo))
}


#############################################################################
#############################################################################

#Probit-Cauchit

clm_res<-vector("list",500)
clm2_res<-vector("list",500)
clm3_res<-vector("list",500)
ls_res<-vector("list",500)
ls2_res<-vector("list",500)
ls3_res<-vector("list",500)
ss_res<-vector("list",500)
ss2_res<-vector("list",500)
ss3_res<-vector("list",500)
IQR_clm_res<-vector("list",500)
IQR_ls_res<-vector("list",500)
p_value_clm<-vector("list",500)
p_value_ls<-vector("list",500)
p_value_ss<-vector("list",500)

n <- 500
for (i in 1:10000)
{
  set.seed(i)
  # covariate
  n<-500
  
  alpha<-16;beta_1<--8;beta_2<-1
  thrd<-c(0,4,8,12)
  
  #X<-rnorm(n,mean=3,sd=2)
  X<-runif(n,1,7)
  RES<-rcauchy(500)
  #RES<-rcauchy(500,0.7,0.01)
  #qqnorm(RES,xlim=c(-4,4),ylim=c(-4,4))
  #abline(0,1)
  
  Z<-alpha+beta_1*X+beta_2*X^2+RES
  W<-ordinalize(Z,thrd)
  table(W)
  
  X_1<-X;X_2<-X^2
  
  #lrmfit<-lrm(yc~x,data=data.frame(y=yc,x=x),x=TRUE,y=TRUE)
  # model1<-orm(as.ordered(W-1)~X_1,family=probit,x=TRUE,y=TRUE)
  # model2<-orm(as.ordered(W-1)~X_1,family=cauchit,x=TRUE,y=TRUE,linear.predictors=TRUE)
  # model3<-orm(as.ordered(W-1)~X_1,family=logistic,x=TRUE,y=TRUE)
  # #Fit for surrogate residuals
  models1<-vglm(formula=as.ordered(W-1)~X_1+X_2,family = cumulative(link =probit,parallel = TRUE))
  models2<-vglm(formula=as.ordered(W-1)~X_1+X_2,family = cumulative(link =cauchit,parallel = TRUE))
  models3<-vglm(formula=as.ordered(W-1)~X_1+X_2,family = cumulative(link =logit,parallel = TRUE))
  
  par(mfrow=c(1,2))
  
  # #D-S residuals
  # clm.residuals = function(obj) {
  #   preds = predict(obj, type="cum.prob")
  #   residuals = runif(length(preds$cprob1))*(preds$cprob1-preds$cprob2) + preds$cprob2
  #   return(qnorm(residuals))}
  # 
  ss_res[[i]]<-resids(models1)
  
  ss2_res[[i]]<-resids(models2)
  
  ss3_res[[i]]<-resids(models3)
  
}
#warnings singularity
#Tests of normality
p_value_clm<-vector("list",500)
p_value_clm2<-vector("list",500)
p_value_clm3<-vector("list",500)
p_value_ls<-vector("list",500)
p_value_ls2<-vector("list",500)
p_value_ls3<-vector("list",500)
p_value_ss<-vector("list",500)
p_value_ss2<-vector("list",500)
p_value_ss3<-vector("list",500)
st_clm<-vector("list",500)
st_clm2<-vector("list",500)
ks_results<-vector("list",500)
ks1_results<-vector("list",500)
ks2_results<-vector("list",500)
ks_ls_results<-vector("list",500)
ks2_ls_results<-vector("list",500)
ks3_ls_results<-vector("list",500)
ks_ss_results<-vector("list",500)
ks2_ss_results<-vector("list",500)
ks3_ss_results<-vector("list",500)
p_values_ks<-vector("list",500)
p_values_ks1<-vector("list",500)
p_values_ks2<-vector("list",500)
p_values_ksls<-vector("list",500)
p_values_ksls2<-vector("list",500)
p_values_ksls3<-vector("list",500)
p_values_ksss<-vector("list",500)
p_values_ksss2<-vector("list",500)
p_values_ksss3<-vector("list",500)

for (i in 1:10000)
{
 
  shapiro.test(ss_res[[i]]) 

  p_value_ss[[i]]<-shapiro.test(ss_res[[i]])$p.value
  p_value_ss2[[i]]<-shapiro.test(ss2_res[[i]])$p.value
  p_value_ss3[[i]]<-shapiro.test(ss3_res[[i]])$p.value
  
  ks_ss_results[[i]]<-ks.test(unlist(ss_res[[i]]),unlist(ss2_res[[i]]))
  ks2_ss_results[[i]]<-ks.test(unlist(ss2_res[[i]]),"punif",0,1) #0
  ks3_ss_results[[i]]<-ks.test(unlist(ss3_res[[i]]),"punif",0,1) #0
  
  p_values_ksss[[i]]<-ks_ss_results[[i]]$p.value
  p_values_ksss2[[i]]<-ks2_ss_results[[i]]$p.value
  p_values_ksss3[[i]]<-ks3_ss_results[[i]]$p.value
  
}
par(mfrow=c(1,1))
hist(unlist(p_values_ksss),main="",xlab="p-values from K-S test for L-S residuals probit-Cauchit",cex.lab=1.5,ylim=c(0,10000))

which(unlist(p_values_ksss)>0.05)
length(which(unlist(p_values_ksss)>0.05))
length(which(unlist(p_values_ksss)>0.05))/10000

#Normal values - Results from Shapiro-Wilk Normality Test. If p>0.05, we  cannot reject  Null hypothesis Normal distrib.

length(which(unlist(p_value_ss)>0.05))
length(which(unlist(p_value_ss)>0.05))/10000
0

#Empirical cumulative distribution function of p-values from Shapiro-Wilk test
#par(mar=c(4.1,4.1,2.0,1.1))
par(mfrow=c(1,3))
plot(ecdf(unlist(p_value_ss3)),main="Logit link",cex.axis=1.5,cex.main=1.5,cex.lab=1.5)
plot(ecdf(unlist(p_value_ss)),main="Probit link",cex.axis=1.5,cex.main=1.5,cex.lab=1.5)
plot(ecdf(unlist(p_value_ss2)),main="Cauchit link",cex.axis=1.5,cex.main=1.5,cex.lab=1.5)

#############################################################################
#############################################################################

#Logit-Cauchit

clm_res<-vector("list",500)
clm2_res<-vector("list",500)
clm3_res<-vector("list",500)
ls_res<-vector("list",500)
ls2_res<-vector("list",500)
ss_res<-vector("list",500)
ss2_res<-vector("list",500)
ss3_res<-vector("list",500)
IQR_clm_res<-vector("list",500)
IQR_ls_res<-vector("list",500)
p_value_clm<-vector("list",500)
p_value_ls<-vector("list",500)
p_value_ss<-vector("list",500)

n <- 500
for (i in 1:10000)
{
  set.seed(i)
  # covariate
  n<-500
  
  alpha<-16;beta_1<--8;beta_2<-1
  thrd<-c(0,4,8,12)
  
  X<-runif(n,1,7)
  RES<-rcauchy(500)
  
  Z<-alpha+beta_1*X+beta_2*(X^2)+RES
  W<-ordinalize(Z,thrd)
  table(W)
  
  X_1<-X;X_2<-X^2
  
  #clm models using rms - orm
  models1<-orm(as.ordered(W-1)~X_1,family=logistic,x=TRUE,y=TRUE)
  models2<-orm(as.ordered(W-1)~X_1,family=cauchit,x=TRUE,y=TRUE,linear.predictors=TRUE)
  models3<-orm(as.ordered(W-1)~X_1,family=probit,x=TRUE,y=TRUE)
  
  ss_res[[i]]<-resids(models1)
  
  ss2_res[[i]]<-resids(models2)
  
  ss3_res[[i]]<-resids(models3)
  
  #Each of ss3_res[[1]] is length 500,  
  #but there are 1...10,000 ss3_res
  
}
#warnings singularity
#Tests of normality
p_value_clm<-vector("list",500)
p_value_clm2<-vector("list",500)
p_value_clm3<-vector("list",500)
p_value_ls<-vector("list",500)
p_value_ls2<-vector("list",500)
p_value_ls3<-vector("list",500)
p_value_ss<-vector("list",10000)
p_value_ss2<-vector("list",10000)
p_value_ss3<-vector("list",10000)
st_clm<-vector("list",500)
st_clm2<-vector("list",500)
ks_results<-vector("list",500)
ks1_results<-vector("list",500)
ks2_results<-vector("list",500)
ks_ss_results<-vector("list",500)
ks2_ss_results<-vector("list",500)
ks3_ss_results<-vector("list",500)
p_values_ks<-vector("list",500)
p_values_ks1<-vector("list",500)
p_values_ks2<-vector("list",500)
p_values_ksss<-vector("list",500)
p_values_ksss2<-vector("list",500)
p_values_ksss3<-vector("list",500)
for (i in 1:10000)
{
  #shapiro.test tests the NULL hypothesis that the samples came from a Normal distribution.
  # shapiro.test(clm_res[[i]])
  shapiro.test(ss_res[[i]]) 
  
  #p-values S-W
  p_value_ss[[i]]<-shapiro.test(ss_res[[i]])$p.value
  p_value_ss2[[i]]<-shapiro.test(ss2_res[[i]])$p.value
  p_value_ss3[[i]]<-shapiro.test(ss3_res[[i]])$p.value
  
  #K-S logit-Cauchit
  ks_ss_results[[i]]<-ks.test(unlist(ss_res[[i]]),unlist(ss2_res[[i]]))
  ks2_ss_results[[i]]<-ks.test(unlist(ss2_res[[i]]),"punif",0,1) #0
  ks3_ss_results[[i]]<-ks.test(unlist(ss3_res[[i]]),"punif",0,1) #0
  
  #p-values K-S
  p_values_ksss[[i]]<-ks_ss_results[[i]]$p.value
  p_values_ksss2[[i]]<-ks2_ss_results[[i]]$p.value
  p_values_ksss3[[i]]<-ks3_ss_results[[i]]$p.value
  
}

#Plot2
par(mfrow=c(1,1))
hist(unlist(p_values_ksss),main="",xlab="p-values from K-S test for Surrogate residuals logit-Cauchit",cex.lab=1.5,ylim=c(0,3000))

which(unlist(p_values_ksss)>0.05)
length(which(unlist(p_values_ksss)>0.05))
length(which(unlist(p_values_ksss)>0.05))/10000

#Normal values - Results from Shapiro-Wilk Normality Test. If p>0.05, we  cannot reject  Null hypothesis Normal distrib.

length(which(unlist(p_value_ss)>0.05))
length(which(unlist(p_value_ss)>0.05))/10000


#Empirical cumulative distribution function of p-values from Shapiro-Wilk test
#par(mar=c(4.1,4.1,2.0,1.1))
#Plot 3
par(mfrow=c(1,3))
plot(ecdf(unlist(p_value_ss)),main="Logistic link",cex.axis=1.5,cex.main=1.5,cex.lab=1.5)
plot(ecdf(unlist(p_value_ss3)),main="Probit link",cex.axis=1.5,cex.main=1.5,cex.lab=1.5)
plot(ecdf(unlist(p_value_ss2)),main="Cauchit link",cex.axis=1.5,cex.main=1.5,cex.lab=1.5)

###########################################################################################
###########################################################################################

#####(c) Unconstrained (-1.5,0,1,3)
ordinalize<-function(z,threshold){ 
  oo<-function(zz){
    ordinal.value<-1;index<-1
    while(index<=length(threshold) && zz>threshold[index]) {ordinal.value<-ordinal.value+1;index<-index+1}
    return(ordinal.value)
  }
  return(sapply(z,oo))
}

#################################################################
#Probit-Cauchit
clm_res<-vector("list",500)
clm2_res<-vector("list",500)
clm3_res<-vector("list",500)
ls_res<-vector("list",500)
ls2_res<-vector("list",500)
ss_res<-vector("list",500)
ss2_res<-vector("list",500)
ss3_res<-vector("list",500)
IQR_clm_res<-vector("list",500)
IQR_ls_res<-vector("list",500)
IQR_ss_res<-vector("list",500)
p_value_clm<-vector("list",500)
p_value_ls<-vector("list",500)
p_value_ss<-vector("list",500)
n <- 500
for (i in 1:10000)
{
  set.seed(i)
  # covariate
  n<-500
  
  alpha<-16;beta_1<--8;beta_2<-1
  thrd<-c(-1.5,0,1,3)

  X<-runif(n,1,7)
  RES<-rcauchy(500)

  Z<-alpha+beta_1*X+beta_2*X^2+RES
  W<-ordinalize(Z,thrd)
  table(W)
  
  X_1<-X;X_2<-X^2
  
  #lrmfit<-lrm(yc~x,data=data.frame(y=yc,x=x),x=TRUE,y=TRUE)
  model1<-orm(as.ordered(W-1)~X_1,family=probit,x=TRUE,y=TRUE)
  model2<-orm(as.ordered(W-1)~X_1,family=cauchit,x=TRUE,y=TRUE,linear.predictors=TRUE)
  model3<-orm(as.ordered(W-1)~X_1,family=logistic,x=TRUE,y=TRUE)
  
  # #Fit for surrogate residuals
  models1<-vglm(formula=as.ordered(W-1)~X_1+X_2,family = cumulative(link =probit,parallel = TRUE))
  models2<-vglm(formula=as.ordered(W-1)~X_1+X_2,family = cumulative(link =cauchit,parallel = TRUE))
  models3<-vglm(formula=as.ordered(W-1)~X_1+X_2,family = cumulative(link =logit,parallel = TRUE))
  
  par(mfrow=c(1,2))
  
  #Surrogate residuals
  ss_res[[i]]<-resids(models1)
  
  ss2_res[[i]]<-resids(models2)
  
  ss3_res[[i]]<-resids(models3)
  
}
#warnings singularity
#Tests of normality
p_value_clm<-vector("list",500)
p_value_clm2<-vector("list",500)
p_value_clm3<-vector("list",500)
p_value_ls<-vector("list",500)
p_value_ls2<-vector("list",500)
p_value_ls3<-vector("list",500)
p_value_ss<-vector("list",500)
p_value_ss2<-vector("list",500)
p_value_ss3<-vector("list",500)
st_clm<-vector("list",500)
st_clm2<-vector("list",500)
ks_results<-vector("list",500)
ks1_results<-vector("list",500)
ks2_results<-vector("list",500)
ks_ls_results<-vector("list",500)
ks2_ls_results<-vector("list",500)
ks3_ls_results<-vector("list",500)
ks_ss_results<-vector("list",500)
ks2_ss_results<-vector("list",500)
ks3_ss_results<-vector("list",500)
p_values_ks<-vector("list",500)
p_values_ks1<-vector("list",500)
p_values_ks2<-vector("list",500)
p_values_ksls<-vector("list",500)
p_values_ksls2<-vector("list",500)
p_values_ksls3<-vector("list",500)
for (i in 1:10000)
{
  #shapiro.test tests the NULL hypothesis that the samples came from a Normal distribution.
  # shapiro.test(clm_res[[i]])
  shapiro.test(ss_res[[i]]) 
  # p_value_clm[[i]]<-shapiro.test(clm_res[[i]])$p.value
  # p_value_clm2[[i]]<-shapiro.test(clm2_res[[i]])$p.value
  # p_value_clm3[[i]]<-shapiro.test(clm3_res[[i]])$p.value
  p_value_ss[[i]]<-shapiro.test(ss_res[[i]])$p.value
  p_value_ss2[[i]]<-shapiro.test(ss2_res[[i]])$p.value
  p_value_ss3[[i]]<-shapiro.test(ss3_res[[i]])$p.value
  # st_clm[[i]]<-shapiro.test(clm_res[[i]])$statistic
  # st_clm2[[i]]<-shapiro.test(clm2_res[[i]])$statistic
  # ks_results[[i]]<-ks.test(unlist(clm_res[[i]]),unlist(clm2_res[[i]]))
  # #ks1_results[[i]]<-ks.test(unlist(clm_res[[i]]),"punif",0,1) #0
  # #ks2_results[[i]]<-ks.test(unlist(clm2_res[[i]]),"punif",0,1) #0
  # ks_results[[i]]<-ks.test(unlist(clm_res[[i]]),unlist(clm2_res[[i]]))
  ks_ss_results[[i]]<-ks.test(unlist(ss_res[[i]]),unlist(ss2_res[[i]]))
  ks2_ss_results[[i]]<-ks.test(unlist(ss2_res[[i]]),"punif",0,1) #0
  ks3_ss_results[[i]]<-ks.test(unlist(ss3_res[[i]]),"punif",0,1) #0
  #p_values_ks[[i]]<-ks_results[[i]]$p.value
  #p_values_ks1[[i]]<-ks1_results[[i]]$p.value
  #p_values_ks2[[i]]<-ks1_results[[i]]$p.value
  p_values_ksss[[i]]<-ks_ss_results[[i]]$p.value
  p_values_ksss2[[i]]<-ks2_ss_results[[i]]$p.value
  p_values_ksss3[[i]]<-ks3_ss_results[[i]]$p.value
  #hist(unlist(p_values_ks[[i]]))
}
par(mfrow=c(1,1))
hist(unlist(p_values_ksss),main="",xlab="p-values from K-S test for Surrogate residuals probit-Cauchit",cex.lab=1.5,ylim=c(0,10000))

which(unlist(p_values_ksss)>0.05)
length(which(unlist(p_values_ksss)>0.05))
length(which(unlist(p_values_ksss)>0.05))/10000

#Normal values - Results from Shapiro-Wilk Normality Test. If p>0.05, we  cannot reject  Null hypothesis Normal distrib.

length(which(unlist(p_value_ss)>0.05))
length(which(unlist(p_value_ss)>0.05))/10000


#Empirical cumulative distribution function of p-values from Shapiro-Wilk test
#par(mar=c(4.1,4.1,2.0,1.1))
par(mfrow=c(1,3))
plot(ecdf(unlist(p_value_ss3)),main="Logit link",cex.axis=1.5,cex.main=1.5,cex.lab=1.5)
plot(ecdf(unlist(p_value_ss)),main="Probit link",cex.axis=1.5,cex.main=1.5,cex.lab=1.5)
plot(ecdf(unlist(p_value_ss2)),main="Cauchit link",cex.axis=1.5,cex.main=1.5,cex.lab=1.5)

#############################################################################
#############################################################################

#Logit-Cauchit

clm_res<-vector("list",500)
clm2_res<-vector("list",500)
clm3_res<-vector("list",500)
ls_res<-vector("list",500)
ls2_res<-vector("list",500)
ss_res<-vector("list",500)
ss2_res<-vector("list",500)
ss3_res<-vector("list",500)
IQR_clm_res<-vector("list",500)
IQR_ls_res<-vector("list",500)
p_value_clm<-vector("list",500)
p_value_ls<-vector("list",500)
p_value_ss<-vector("list",500)

n <- 500
for (i in 1:10000)
{
  set.seed(i)
  # covariate
  n<-500
  
  alpha<-16;beta_1<--8;beta_2<-1
  thrd<-c(-1.5,0,1,3)
  
  X<-runif(n,1,7)
  RES<-rcauchy(500)
  
  Z<-alpha+beta_1*X+beta_2*(X^2)+RES
  W<-ordinalize(Z,thrd)
  table(W)
  
  X_1<-X;X_2<-X^2
  
  #clm models using rms - orm
  models1<-orm(as.ordered(W-1)~X_1,family=logistic,x=TRUE,y=TRUE)
  models2<-orm(as.ordered(W-1)~X_1,family=cauchit,x=TRUE,y=TRUE,linear.predictors=TRUE)
  models3<-orm(as.ordered(W-1)~X_1,family=probit,x=TRUE,y=TRUE)
  
  ss_res[[i]]<-resids(models1)
  
  ss2_res[[i]]<-resids(models2)
  
  ss3_res[[i]]<-resids(models3)
  
  #Each of ss3_res[[1]] is length 500,  
  #but there are 1...10,000 ss3_res
  
}
#warnings singularity
#Tests of normality
p_value_clm<-vector("list",500)
p_value_clm2<-vector("list",500)
p_value_clm3<-vector("list",500)
p_value_ls<-vector("list",500)
p_value_ls2<-vector("list",500)
p_value_ls3<-vector("list",500)
p_value_ss<-vector("list",10000)
p_value_ss2<-vector("list",10000)
p_value_ss3<-vector("list",10000)
st_clm<-vector("list",500)
st_clm2<-vector("list",500)
ks_results<-vector("list",500)
ks1_results<-vector("list",500)
ks2_results<-vector("list",500)
ks_ss_results<-vector("list",500)
ks2_ss_results<-vector("list",500)
ks3_ss_results<-vector("list",500)
p_values_ks<-vector("list",500)
p_values_ks1<-vector("list",500)
p_values_ks2<-vector("list",500)
p_values_ksss<-vector("list",500)
p_values_ksss2<-vector("list",500)
p_values_ksss3<-vector("list",500)
for (i in 1:10000)
{
  #shapiro.test tests the NULL hypothesis that the samples came from a Normal distribution.
  # shapiro.test(clm_res[[i]])
  shapiro.test(ss_res[[i]]) 
  
  #p-values S-W
  p_value_ss[[i]]<-shapiro.test(ss_res[[i]])$p.value
  p_value_ss2[[i]]<-shapiro.test(ss2_res[[i]])$p.value
  p_value_ss3[[i]]<-shapiro.test(ss3_res[[i]])$p.value
  
  #K-S logit-Cauchit
  ks_ss_results[[i]]<-ks.test(unlist(ss_res[[i]]),unlist(ss2_res[[i]]))
  ks2_ss_results[[i]]<-ks.test(unlist(ss2_res[[i]]),"punif",0,1) #0
  ks3_ss_results[[i]]<-ks.test(unlist(ss3_res[[i]]),"punif",0,1) #0
  
  #p-values K-S
  p_values_ksss[[i]]<-ks_ss_results[[i]]$p.value
  p_values_ksss2[[i]]<-ks2_ss_results[[i]]$p.value
  p_values_ksss3[[i]]<-ks3_ss_results[[i]]$p.value
  
}

#Plot2
par(mfrow=c(1,1))
hist(unlist(p_values_ksss),main="",xlab="p-values from K-S test for Surrogate residuals logit-Cauchit",cex.lab=1.5,ylim=c(0,4000))

which(unlist(p_values_ksss)>0.05)
length(which(unlist(p_values_ksss)>0.05))
length(which(unlist(p_values_ksss)>0.05))/10000

#Normal values - Results from Shapiro-Wilk Normality Test. If p>0.05, we  cannot reject  Null hypothesis Normal distrib.

length(which(unlist(p_value_ss)>0.05))
length(which(unlist(p_value_ss)>0.05))/10000


#Empirical cumulative distribution function of p-values from Shapiro-Wilk test
#par(mar=c(4.1,4.1,2.0,1.1))
#Plot 3
par(mfrow=c(1,3))
plot(ecdf(unlist(p_value_ss)),main="Logistic link",cex.axis=1.5,cex.main=1.5,cex.lab=1.5)
plot(ecdf(unlist(p_value_ss3)),main="Probit link",cex.axis=1.5,cex.main=1.5,cex.lab=1.5)
plot(ecdf(unlist(p_value_ss2)),main="Cauchit link",cex.axis=1.5,cex.main=1.5,cex.lab=1.5)

###########################################################################################
###########################################################################################


#####(d) Symmetric (-36,-6,34,64)
ordinalize<-function(z,threshold){ 
  oo<-function(zz){
    ordinal.value<-1;index<-1
    while(index<=length(threshold) && zz>threshold[index]) {ordinal.value<-ordinal.value+1;index<-index+1}
    return(ordinal.value)
  }
  return(sapply(z,oo))
}


#############################################################################
#############################################################################

#Probit-Cauchit

clm_res<-vector("list",500)
clm2_res<-vector("list",500)
clm3_res<-vector("list",500)
ls_res<-vector("list",500)
ls2_res<-vector("list",500)
ss_res<-vector("list",500)
ss2_res<-vector("list",500)
ss3_res<-vector("list",500)
IQR_clm_res<-vector("list",500)
IQR_ls_res<-vector("list",500)
p_value_clm<-vector("list",500)
p_value_ls<-vector("list",500)
p_value_ss<-vector("list",500)

n <- 500
for (i in 1:10000)
{
  set.seed(i)
  # covariate
  n<-500
  
  alpha<-16;beta_1<--8;beta_2<-1
  thrd<-c(-36,-6,34,64)
  
  #X<-rnorm(n,mean=3,sd=2)
  X<-runif(n,1,7)
  RES<-rcauchy(500)
  #RES<-rcauchy(500,0.7,0.01)
  #qqnorm(RES,xlim=c(-4,4),ylim=c(-4,4))
  #abline(0,1)
  
  Z<-alpha+beta_1*X+beta_2*X^2+RES
  W<-ordinalize(Z,thrd)
  table(W)
  
  X_1<-X;X_2<-X^2
  
  #lrmfit<-lrm(yc~x,data=data.frame(y=yc,x=x),x=TRUE,y=TRUE)
  model1<-orm(as.ordered(W-1)~X_1,family=probit,x=TRUE,y=TRUE)
  model2<-orm(as.ordered(W-1)~X_1,family=cauchit,x=TRUE,y=TRUE,linear.predictors=TRUE)
  model3<-orm(as.ordered(W-1)~X_1,family=logistic,x=TRUE,y=TRUE)
  
  #Fit for surrogate residuals
  models1<-vglm(formula=as.ordered(W-1)~X_1+X_2,family = cumulative(link =probit,parallel = TRUE))
  models2<-vglm(formula=as.ordered(W-1)~X_1+X_2,family = cumulative(link =cauchit,parallel = TRUE))
  models3<-vglm(formula=as.ordered(W-1)~X_1+X_2,family = cumulative(link =logit,parallel = TRUE))
  
  par(mfrow=c(1,2))
  
  # #D-S residuals
  # clm.residuals = function(obj) {
  #   preds = predict(obj, type="cum.prob")
  #   residuals = runif(length(preds$cprob1))*(preds$cprob1-preds$cprob2) + preds$cprob2
  #   return(qnorm(residuals))}
  # 
  ss_res[[i]]<-resids(models1)
  
  ss2_res[[i]]<-resids(models2)
  
  ss3_res[[i]]<-resids(models3)
  
}
#warnings singularity
#Tests of normality
p_value_clm<-vector("list",500)
p_value_clm2<-vector("list",500)
p_value_clm3<-vector("list",500)
p_value_ls<-vector("list",500)
p_value_ls2<-vector("list",500)
p_value_ls3<-vector("list",500)
p_value_ss<-vector("list",500)
p_value_ss2<-vector("list",500)
p_value_ss3<-vector("list",500)
st_clm<-vector("list",500)
st_clm2<-vector("list",500)
ks_results<-vector("list",500)
ks1_results<-vector("list",500)
ks2_results<-vector("list",500)
ks_ss_results<-vector("list",500)
ks2_ss_results<-vector("list",500)
ks3_ss_results<-vector("list",500)
p_values_ks<-vector("list",500)
p_values_ks1<-vector("list",500)
p_values_ks2<-vector("list",500)
p_values_ksss<-vector("list",500)
p_values_ksss2<-vector("list",500)
p_values_ksss3<-vector("list",500)
for (i in 1:10000)
{
  #shapiro.test tests the NULL hypothesis that the samples came from a Normal distribution.
  # shapiro.test(clm_res[[i]])
  shapiro.test(ss_res[[i]]) 
  # p_value_clm[[i]]<-shapiro.test(clm_res[[i]])$p.value
  # p_value_clm2[[i]]<-shapiro.test(clm2_res[[i]])$p.value
  # p_value_clm3[[i]]<-shapiro.test(clm3_res[[i]])$p.value
  p_value_ss[[i]]<-shapiro.test(ss_res[[i]])$p.value
  p_value_ss2[[i]]<-shapiro.test(ss2_res[[i]])$p.value
  p_value_ss3[[i]]<-shapiro.test(ss3_res[[i]])$p.value
  # st_clm[[i]]<-shapiro.test(clm_res[[i]])$statistic
  # st_clm2[[i]]<-shapiro.test(clm2_res[[i]])$statistic
  # ks_results[[i]]<-ks.test(unlist(clm_res[[i]]),unlist(clm2_res[[i]]))
  # #ks1_results[[i]]<-ks.test(unlist(clm_res[[i]]),"punif",0,1) #0
  # #ks2_results[[i]]<-ks.test(unlist(clm2_res[[i]]),"punif",0,1) #0
  # ks_results[[i]]<-ks.test(unlist(clm_res[[i]]),unlist(clm2_res[[i]]))
  ks_ss_results[[i]]<-ks.test(unlist(ss_res[[i]]),unlist(ss2_res[[i]]))
  ks2_ss_results[[i]]<-ks.test(unlist(ss2_res[[i]]),"punif",0,1) #0
  ks3_ss_results[[i]]<-ks.test(unlist(ss3_res[[i]]),"punif",0,1) #0
  #p_values_ks[[i]]<-ks_results[[i]]$p.value
  #p_values_ks1[[i]]<-ks1_results[[i]]$p.value
  #p_values_ks2[[i]]<-ks1_results[[i]]$p.value
  p_values_ksss[[i]]<-ks_ss_results[[i]]$p.value
  p_values_ksss2[[i]]<-ks2_ss_results[[i]]$p.value
  p_values_ksss3[[i]]<-ks3_ss_results[[i]]$p.value
  #hist(unlist(p_values_ks[[i]]))
}

#Plot2
par(mfrow=c(1,1))
hist(unlist(p_values_ksss),main="",xlab="p-values from K-S test for Surrogate residuals probit-Cauchit",cex.lab=1.5,ylim=c(0,10000))

which(unlist(p_values_ksss)>0.05)
length(which(unlist(p_values_ksss)>0.05))
length(which(unlist(p_values_ksss)>0.05))/10000

#Normal values - Results from Shapiro-Wilk Normality Test. If p>0.05, we  cannot reject  Null hypothesis Normal distrib.

length(which(unlist(p_value_ss)>0.05))
length(which(unlist(p_value_ss)>0.05))/10000


#Empirical cumulative distribution function of p-values from Shapiro-Wilk test
#par(mar=c(4.1,4.1,2.0,1.1))
#Plot 3
par(mfrow=c(1,3))
plot(ecdf(unlist(p_value_ss3)),main="Logit link",cex.axis=1.5,cex.main=1.5,cex.lab=1.5)
plot(ecdf(unlist(p_value_ss)),main="Probit link",cex.axis=1.5,cex.main=1.5,cex.lab=1.5)
plot(ecdf(unlist(p_value_ss2)),main="Cauchit link",cex.axis=1.5,cex.main=1.5,cex.lab=1.5)

#############################################################################
#############################################################################

#Logit-Cauchit

clm_res<-vector("list",500)
clm2_res<-vector("list",500)
clm3_res<-vector("list",500)
ls_res<-vector("list",500)
ls2_res<-vector("list",500)
ss_res<-vector("list",500)
ss2_res<-vector("list",500)
ss3_res<-vector("list",500)
IQR_clm_res<-vector("list",500)
IQR_ls_res<-vector("list",500)
p_value_clm<-vector("list",500)
p_value_ls<-vector("list",500)
p_value_ss<-vector("list",500)

n <- 500
for (i in 1:10000)
{
  set.seed(i)
  # covariate
  n<-500
  
  alpha<-16;beta_1<--8;beta_2<-1
  thrd<-c(-36,-6,34,64)
  
  X<-runif(n,1,7)
  RES<-rcauchy(500)
  
  Z<-alpha+beta_1*X+beta_2*(X^2)+RES
  W<-ordinalize(Z,thrd)
  table(W)
  
  X_1<-X;X_2<-X^2
  
  #clm models using rms - orm
  models1<-orm(as.ordered(W-1)~X_1,family=logistic,x=TRUE,y=TRUE)
  models2<-orm(as.ordered(W-1)~X_1,family=cauchit,x=TRUE,y=TRUE,linear.predictors=TRUE)
  models3<-orm(as.ordered(W-1)~X_1,family=probit,x=TRUE,y=TRUE)
  
  ss_res[[i]]<-resids(models1)
  
  ss2_res[[i]]<-resids(models2)
  
  ss3_res[[i]]<-resids(models3)
  
  #Each of ss3_res[[1]] is length 500,  
  #but there are 1...10,000 ss3_res
  
}
#warnings singularity
#Tests of normality
p_value_clm<-vector("list",500)
p_value_clm2<-vector("list",500)
p_value_clm3<-vector("list",500)
p_value_ls<-vector("list",500)
p_value_ls2<-vector("list",500)
p_value_ls3<-vector("list",500)
p_value_ss<-vector("list",10000)
p_value_ss2<-vector("list",10000)
p_value_ss3<-vector("list",10000)
st_clm<-vector("list",500)
st_clm2<-vector("list",500)
ks_results<-vector("list",500)
ks1_results<-vector("list",500)
ks2_results<-vector("list",500)
ks_ss_results<-vector("list",500)
ks2_ss_results<-vector("list",500)
ks3_ss_results<-vector("list",500)
p_values_ks<-vector("list",500)
p_values_ks1<-vector("list",500)
p_values_ks2<-vector("list",500)
p_values_ksss<-vector("list",500)
p_values_ksss2<-vector("list",500)
p_values_ksss3<-vector("list",500)
for (i in 1:10000)
{
  #shapiro.test tests the NULL hypothesis that the samples came from a Normal distribution.
  # shapiro.test(clm_res[[i]])
  shapiro.test(ss_res[[i]]) 

  #p-values S-W
  p_value_ss[[i]]<-shapiro.test(ss_res[[i]])$p.value
  p_value_ss2[[i]]<-shapiro.test(ss2_res[[i]])$p.value
  p_value_ss3[[i]]<-shapiro.test(ss3_res[[i]])$p.value

  #K-S logit-Cauchit
  ks_ss_results[[i]]<-ks.test(unlist(ss_res[[i]]),unlist(ss2_res[[i]]))
  ks2_ss_results[[i]]<-ks.test(unlist(ss2_res[[i]]),"punif",0,1) #0
  ks3_ss_results[[i]]<-ks.test(unlist(ss3_res[[i]]),"punif",0,1) #0

  #p-values K-S
  p_values_ksss[[i]]<-ks_ss_results[[i]]$p.value
  p_values_ksss2[[i]]<-ks2_ss_results[[i]]$p.value
  p_values_ksss3[[i]]<-ks3_ss_results[[i]]$p.value

}

#Plot2
par(mfrow=c(1,1))
hist(unlist(p_values_ksss),main="",xlab="p-values from K-S test for Surrogate residuals logit-Cauchit",cex.lab=1.5,ylim=c(0,3000))

which(unlist(p_values_ksss)>0.05)
length(which(unlist(p_values_ksss)>0.05))
length(which(unlist(p_values_ksss)>0.05))/10000

#Normal values - Results from Shapiro-Wilk Normality Test. If p>0.05, we  cannot reject  Null hypothesis Normal distrib.

length(which(unlist(p_value_ss)>0.05))
length(which(unlist(p_value_ss)>0.05))/10000


#Empirical cumulative distribution function of p-values from Shapiro-Wilk test
#par(mar=c(4.1,4.1,2.0,1.1))
#Plot 3
par(mfrow=c(1,3))
plot(ecdf(unlist(p_value_ss)),main="Logistic link",cex.axis=1.5,cex.main=1.5,cex.lab=1.5)
plot(ecdf(unlist(p_value_ss3)),main="Probit link",cex.axis=1.5,cex.main=1.5,cex.lab=1.5)
plot(ecdf(unlist(p_value_ss2)),main="Cauchit link",cex.axis=1.5,cex.main=1.5,cex.lab=1.5)



############################
# Scenario 3. Quadratic term
############################
##############
# Subscenario 3.1. Q-Q-Q
##############
#QQQ logit
##############
#######################################################################################################
######################################################################################################
library("ordinal")
library("tmvtnorm")
library("VGAM")
library("rms")
###############################################################
### The function used to ordinalize a continous variable
### Ordinal value: 1,2,3...
### Inputs: 
### 1. "z" is a vector to be ordinalized; 
### 2. "threshold" is a vector specifying the cut-off points
### Output: the returned value is also a vector
###############################################################
ordinalize<-function(z,threshold){ 
  oo<-function(zz){
    ordinal.value<-1;index<-1
    while(index<=length(threshold) && zz>threshold[index]) {ordinal.value<-ordinal.value+1;index<-index+1}
    return(ordinal.value)
  }
  return(sapply(z,oo))
}

xp_value_sur<-vector("list",10000)
x2p_value_sur<-vector("list",10000)

ls_res<-vector("list",500)
xp_value_ls<-vector("list",10000)
x2p_value_ls<-vector("list",10000)

residfit_ds<-vector("list",500)

clm_res<-vector("list",500)
xp_value_ds<-vector("list",10000)
x2p_value_ds<-vector("list",10000)

residfit_ls<-vector("list",500)


count_ls<-vector("list",500)
count_ds<-vector("list",500)
count_sur<-vector("list",500)

count_ls2<-vector("list",500)
count_ds2<-vector("list",500)
count_sur2<-vector("list",500)

for(j in 1:10000){
  set.seed(j)
  #########################################################################
  ### Simulate latent variable Z from a quadratic function of X plus noise
  ### The ordinal outcome W is obtained by discretizing Z
  ########################################################################
  n<-500
  
  alpha<-16;beta_1<--8;beta_2<-1
  thrd<-c(0,4,8)
  
  #X<-rnorm(n,mean=3,sd=2)
  X<-runif(n,1,7)
  RES<-rnorm(n)
  Z<-alpha+beta_1*X+beta_2*(X^2)+RES
  W<-ordinalize(Z,thrd)
  table(W)
  

  ################################################################
  ### Model diagnosis when the model is specified correctly
  ###############################################################
  X_1<-X;X_2<-X^2
  model<-vglm(formula=(W-1)~X_1+X_2,family = cumulative(link = logit,parallel = TRUE))
  response<-as.ordered(W-1)
  model_c<-clm(response~X_1+X_2,link="logit")
  model_l<-lrm(response~X_1+X_2,x=TRUE,y=TRUE)
  #as.numeric(coef(summary(model))[,4][4]) p-value X1
  #as.numeric(coef(summary(model))[,4][5]) p-value X2
  alpha.hat<--coef(model)[1];beta_1.hat<--coef(model)[4];beta_2.hat<--coef(model)[5]
  thrd.hat<-c(0,coef(model)[2]-coef(model)[1],coef(model)[3]-coef(model)[1])

  #####Surrogate residual
  residual.bootstrap<-function(w,x){
    cc<-c(-Inf,thrd.hat,Inf)
    res<-rtmvnorm(1,algorithm="gibbs",mean=(alpha.hat+beta_1.hat*x+beta_2.hat*x^2),sigma=1,lower=cc[w],upper=cc[w+1])-(alpha.hat+beta_1.hat*x+beta_2.hat*x^2)
  }
 
  
  res.boot<-rep(NA,n)
  for(i in 1:n){
  res.boot[i]<-residual.bootstrap(W[i],X[i])
  residfit <- lm(res.boot~X_1+X_2)
  xp_value_sur[[i]]<-anova(residfit)$'Pr(>F)'[2]
  x2p_value_sur[[i]]<-anova(residfit)$'Pr(>F)'[1]
  }
  
  
  
  ##### Li-Shepherd residual
  ls_res[[j]]<-residuals(model_l,type="li.shepherd")
  # width<-0.45
  # res.LS<-residual.LS(W,X)
  # ls_res[[j]]<-residual.LS(W,X)
  # residual.LS<-function(w,x){
  #   cc<-c(-Inf,thrd.hat,Inf)
  #   res<-pnorm(cc[w+1]-(alpha.hat+beta_1.hat*x+beta_2.hat*(x^2)))+pnorm(cc[w]-(alpha.hat+beta_1.hat*x+beta_2.hat*(x^2)))-1
  #   return(res)
  # }
  residfit_ls[[j]] <- lm(ls_res[[j]]~X_1+X_2)
  xp_value_ls[[j]]<-anova(residfit_ls[[j]])$'Pr(>F)'[2]
  x2p_value_ls[[j]]<-anova(residfit_ls[[j]])$'Pr(>F)'[1]
  
  
  clm.residuals = function(obj) {
    preds = predict(obj, type="cum.prob")
    residuals = runif(length(preds$cprob1))*(preds$cprob1-preds$cprob2) + preds$cprob2
    return(qnorm(residuals))}
  
  clm_res[[j]]<-clm.residuals(model_c)
  residfit_ds[[j]]<- lm(clm_res[[j]]~X_1+X_2)
  xp_value_ds[[j]]<-anova(residfit_ds[[j]])$'Pr(>F)'[2]
  x2p_value_ds[[j]]<-anova(residfit_ds[[j]])$'Pr(>F)'[1]
  
  ##### Figure 1: SBS and surrogate residual when the model is correct
  par(mfrow=c(3,3))
  # 
  plot(X_1,ls_res[[j]], ylim=c(-1,1), xlab="X",ylab="L-S residuals",main="(a)",cex.lab=1.5)
  abline(h=0,lty=2,lwd=1)
  # 
  plot(X_2,ls_res[[j]], ylim=c(-1,1), xlab=expression(X^2),ylab="L-S residuals",main="(b)",cex.lab=1.5)
  abline(h=0,lty=2,lwd=1)
  # 
  sample.ref<-runif(10000,min=-1,max=1)
  qqplot(sample.ref,ls_res[[j]],main="(c)",ylab="L-S residuals",xlab="U(-1,1) distribution",cex.lab=1.5)
  abline(0,1,col="red",lwd=1)
  # 
  plot(clm.residuals(model_c)~X_1,ylab="D-S residuals",cex.lab=1.5,main="(d)",xlab="X")
  abline(h=0,col="black",lty=2,lwd=1)
  plot(clm.residuals(model_c)~X_2,ylab="D-S residuals",cex.lab=1.5,main="(e)",xlab=expression(X^2))
  abline(h=0,col="black",lty=2,lwd=1)
  qqnorm(clm.residuals(model_c),ylab="D-S residuals",xlab="Normal distribution",cex.lab=1.5,main="(f)")
  qqline(clm.residuals(model_c),col="red",lwd=1)
  # 
  plot(X_1,res.boot, ylim=c(-3,3),xlab="X",ylab="Surrogate residuals",main="(g)",cex.lab=1.5)
  abline(h=0,lty=2,lwd=1)
  #
  plot(X_1,res.boot,ylim=c(-3,3),xlab=expression(X^2),ylab="Surrogate residuals",main="(h)",cex.lab=1.5)
  abline(h=0,lty=2,lwd=1)
  #
 #index<-which(prob<0.8)
  qqplot(RES,res.boot, xlab="Normal distribution",ylab="Surrogate residuals",main="(i)",cex.lab=1.5)
  abline(0,1,col="red",lwd=1)
  
  par(mfrow=c(3,2))
  # 
  # hist(unlist(xp_value_ls),xlab="p-values X term",main="",ylim=c(0,140),xlim=c(0,1),breaks=c(0,0.8,0.9,1.0),freq=TRUE,cex.lab=1.5)
  # hist(unlist(x2p_value_ls[[j]]), xlab=expression(p~-~values~ X^2~term),main="",ylim=c(0,140),xlim=c(0,1),breaks=c(0,0.8,0.9,1.0),freq=TRUE,cex.lab=1.5)
  # 
  # hist(unlist(xp_value_ds[[j]]),xlab="p-values X term",main="",ylim=c(0,140),xlim=c(0,1),cex.lab=1.5)
  # hist(unlist(x2p_value_ds[[j]]), xlab=expression(p~-~values~ X^2~term),main="",ylim=c(0,140),xlim=c(0,1),cex.lab=1.5)
  # 
  # #surrogate all well
  # hist(unlist(xp_value_sur),xlab="p-values X term",main="",ylim=c(0,140),xlim=c(0,1),cex.lab=1.5,freq=TRUE)
  # hist(unlist(x2p_value_sur), xlab=expression(p~-~values~ X^2~term),main="",ylim=c(0,140),xlim=c(0,1),cex.lab=1.5,freq=TRUE)
  # 
  # mtext("(a) L-S residuals", side=3,line=-3,outer=TRUE)
  # mtext("(b) D-S residuals", side=3,line=-21,outer=TRUE)
  # mtext("(c) Surrogate residuals", side=3,line=-40,outer=TRUE)
  
  count_ls[[j]]<-length(xp_value_ls[xp_value_ls[[j]]<=0.05])
  count_ds[[j]]<-length(xp_value_ds[xp_value_ds[[j]]<=0.05])
  count_sur[[j]]<-length(xp_value_sur[xp_value_sur[[j]]<=0.05])
  count_ls2[[j]]<-length(x2p_value_ls[x2p_value_ls[[j]]<=0.05])
  count_ds2[[j]]<-length(x2p_value_ds[x2p_value_ds[[j]]<=0.05])
  count_sur2[[j]]<-length(x2p_value_sur[x2p_value_sur[[j]]<=0.05])
}

table(unlist(count_ls))
# 0 
# 10000 
table(unlist(count_ds))
# 0 10000 
# 9944    56 
table(unlist(count_sur))
# 0 10000 
# 9981    19 

table(unlist(count_ls2))
# 0 
# 10000 

table(unlist(count_ds2))
# 0 10000 
# 9923    77 
table(unlist(count_sur2))
# 0 10000 
# 9981    19 

par(mfrow=c(3,2))

hist(unlist(xp_value_ls),xlab="p-values X term",main="",ylim=c(0,10000),xlim=c(0,1),breaks=c(0,0.8,0.9,1.0),freq=TRUE,cex.lab=1.5)
hist(unlist(x2p_value_ls), xlab=expression(p~-~values~ X^2~term),main="",ylim=c(0,10000),xlim=c(0,1),breaks=c(0,0.8,0.9,1.0),freq=TRUE,cex.lab=1.5)

hist(unlist(xp_value_ds),xlab="p-values X term",main="",ylim=c(0,10000),xlim=c(0,1),cex.lab=1.5)
hist(unlist(x2p_value_ds), xlab=expression(p~-~values~ X^2~term),main="",ylim=c(0,10000),xlim=c(0,1),cex.lab=1.5)

#surrogate all well
hist(unlist(xp_value_sur),xlab="p-values X term",main="",ylim=c(0,10000),xlim=c(0,1),cex.lab=1.5,freq=TRUE)
hist(unlist(x2p_value_sur), xlab=expression(p~-~values~ X^2~term),main="",ylim=c(0,10000),xlim=c(0,1),cex.lab=1.5,freq=TRUE)

mtext("(a) L-S residuals", side=3,line=-1.5,outer=TRUE)
mtext("(b) D-S residuals", side=3,line=-22,outer=TRUE)
mtext("(c) Surrogate residuals", side=3,line=-44.5,outer=TRUE)


length(xp_value_ls[xp_value_ls<=0.05]) 
#0
length(x2p_value_ls[x2p_value_ls<=0.05]) 
#0

length(xp_value_ds[xp_value_ds<=0.05]) 
#56
length(x2p_value_ds[x2p_value_ds<=0.05])
#77

length(xp_value_sur[xp_value_sur<=0.05]) 
length(x2p_value_sur[x2p_value_sur<=0.05]) 
length(xp_value_sur[xp_value_sur<=0.05]) #116 #83 FOR 10000
#Error: (list) object cannot be coerced to type 'double'
length(x2p_value_sur[x2p_value_sur<=0.05]) #4  #11 FOR 10000

#Cumulative process
library(timereg)

############################
#Subscenario 3.2. Q-Q-L
############################
##############
#QQL logit
##############
library("ordinal")
library("tmvtnorm")
library("VGAM")
library("rms")
###############################################################
### The function used to ordinalize a continous variable
### Ordinal value: 1,2,3...
### Inputs: 
### 1. "z" is a vector to be ordinalized; 
### 2. "threshold" is a vector specifying the cut-off points
### Output: the returned value is also a vector
###############################################################
ordinalize<-function(z,threshold){ 
  oo<-function(zz){
    ordinal.value<-1;index<-1
    while(index<=length(threshold) && zz>threshold[index]) {ordinal.value<-ordinal.value+1;index<-index+1}
    return(ordinal.value)
  }
  return(sapply(z,oo))
}

xp_value_sur<-vector("list",10000)
x2p_value_sur<-vector("list",10000)

ls_res<-vector("list",10000)
xp_value_ls<-vector("list",10000)
x2p_value_ls<-vector("list",10000)

residfit_ds<-vector("list",500)

clm_res<-vector("list",500)
xp_value_ds<-vector("list",10000)
x2p_value_ds<-vector("list",10000)

residfit_ls<-vector("list",500)


count_ls<-vector("list",10000)
count_ds<-vector("list",10000)
count_sur<-vector("list",10000)

count_ls2<-vector("list",10000)
count_ds2<-vector("list",10000)
count_sur2<-vector("list",10000)

for(j in 1:10000){
  set.seed(j)
  #########################################################################
  ### Simulate latent variable Z from a quadratic function of X plus noise
  ### The ordinal outcome W is obtained by discretizing Z
  ########################################################################
  n<-500
  
  alpha<-16;beta_1<--8;beta_2<-1
  thrd<-c(0,4,8)
  
  #X<-rnorm(n,mean=3,sd=2)
  X<-runif(n,1,7)
  RES<-rnorm(n)
  Z<-alpha+beta_1*X+beta_2*(X^2)+RES
  W<-ordinalize(Z,thrd)
  table(W)
  
  #par(mfrow=c(1,2),oma = c(0,0,3,0))
  #par(mfrow=c(1,2))
  #plot(X,Z,main="(a) Latent variable Z")
  
  ################################################################
  ### Model diagnosis when the model is specified correctly
  ###############################################################
  X_1<-X;X_2<-X^2
  model<-vglm(formula=(W-1)~X_1+X_2,family = cumulative(link = logit,parallel = TRUE))
  response<-as.ordered(W-1)
  model_c<-clm(response~X_1+X_2,link="logit")
  model_l<-lrm(response~X_1+X_2,x=TRUE,y=TRUE)
  #as.numeric(coef(summary(model))[,4][4]) p-value X1
  #as.numeric(coef(summary(model))[,4][5]) p-value X2
  alpha.hat<--coef(model)[1];beta_1.hat<--coef(model)[4];beta_2.hat<--coef(model)[5]
  thrd.hat<-c(0,coef(model)[2]-coef(model)[1],coef(model)[3]-coef(model)[1])

  #####Surrogate residual
  residual.bootstrap<-function(w,x){
    cc<-c(-Inf,thrd.hat,Inf)
    res<-rtmvnorm(1,algorithm="gibbs",mean=(alpha.hat+beta_1.hat*x+beta_2.hat*x^2),sigma=1,lower=cc[w],upper=cc[w+1])-(alpha.hat+beta_1.hat*x+beta_2.hat*x^2)
  }
 
  
  res.boot<-rep(NA,n)
  for(i in 1:n){
  res.boot[i]<-residual.bootstrap(W[i],X[i])
  residfit <- lm(res.boot~X_1)
  #xp_value_sur[[i]]<-anova(residfit)$'Pr(>F)'[2]
  xp_value_sur[[i]]<-anova(residfit)$'Pr(>F)'[1]
  }
  
  
  ##### Li-Shepherd residual
  ls_res[[j]]<-residuals(model_l,type="li.shepherd")
  # width<-0.45
  # res.LS<-residual.LS(W,X)
  # ls_res[[j]]<-residual.LS(W,X)
  # residual.LS<-function(w,x){
  #   cc<-c(-Inf,thrd.hat,Inf)
  #   res<-pnorm(cc[w+1]-(alpha.hat+beta_1.hat*x+beta_2.hat*(x^2)))+pnorm(cc[w]-(alpha.hat+beta_1.hat*x+beta_2.hat*(x^2)))-1
  #   return(res)
  # }
  residfit_ls[[j]] <- lm(ls_res[[j]]~X_1)
  #xp_value_ls[[j]]<-anova(residfit_ls[[j]])$'Pr(>F)'[2]
  xp_value_ls[[j]]<-anova(residfit_ls[[j]])$'Pr(>F)'[1]
  
  
  clm.residuals = function(obj) {
    preds = predict(obj, type="cum.prob")
    residuals = runif(length(preds$cprob1))*(preds$cprob1-preds$cprob2) + preds$cprob2
    return(qnorm(residuals))}
  
  clm_res[[j]]<-clm.residuals(model_c)
  residfit_ds[[j]]<- lm(clm_res[[j]]~X_1)
  #xp_value_ds[[j]]<-anova(residfit_ds[[j]])$'Pr(>F)'[2]
  xp_value_ds[[j]]<-anova(residfit_ds[[j]])$'Pr(>F)'[1]
  
  ##### Figure 1: SBS and surrogate residual when the model is correct
  par(mfrow=c(3,3))
  # 
  plot(X_1,ls_res[[j]], ylim=c(-1,1), xlab="X",ylab="L-S residuals",main="(a)",cex.lab=1.5)
  abline(h=0,lty=2,lwd=1)
  # 
  plot(X_2,ls_res[[j]], ylim=c(-1,1), xlab=expression(X^2),ylab="L-S residuals",main="(b)",cex.lab=1.5)
  abline(h=0,lty=2,lwd=1)
  # 
  sample.ref<-runif(10000,min=-1,max=1)
  qqplot(sample.ref,ls_res[[j]],main="(c)",ylab="L-S residuals",xlab="U(-1,1) distribution",cex.lab=1.5)
  abline(0,1,col="red",lwd=1)
  # 
  plot(clm.residuals(model_c)~X_1,ylab="D-S residuals",cex.lab=1.5,main="(d)",xlab="X")
  abline(h=0,col="black",lty=2,lwd=1)
  plot(clm.residuals(model_c)~X_2,ylab="D-S residuals",cex.lab=1.5,main="(e)",xlab=expression(X^2))
  abline(h=0,col="black",lty=2,lwd=1)
  qqnorm(clm.residuals(model_c),ylab="D-S residuals",xlab="Normal distribution",cex.lab=1.5,main="(f)")
  qqline(clm.residuals(model_c),col="red",lwd=1)
  # 
  plot(X_1,res.boot, ylim=c(-3,3),xlab="X",ylab="Surrogate residuals",main="(g)",cex.lab=1.5)
  abline(h=0,lty=2,lwd=1)
  #
  plot(X_1,res.boot,ylim=c(-3,3),xlab=expression(X^2),ylab="Surrogate residuals",main="(h)",cex.lab=1.5)
  abline(h=0,lty=2,lwd=1)
  #
 #index<-which(prob<0.8)
  qqplot(RES,res.boot, xlab="Normal distribution",ylab="Surrogate residuals",main="(i)",cex.lab=1.5)
  abline(0,1,col="red",lwd=1)
  
  par(mfrow=c(3,2))
  # 
  # hist(unlist(xp_value_ls),xlab="p-values X term",main="",ylim=c(0,140),xlim=c(0,1),breaks=c(0,0.8,0.9,1.0),freq=TRUE,cex.lab=1.5)
  # hist(unlist(x2p_value_ls[[j]]), xlab=expression(p~-~values~ X^2~term),main="",ylim=c(0,140),xlim=c(0,1),breaks=c(0,0.8,0.9,1.0),freq=TRUE,cex.lab=1.5)
  # 
  # hist(unlist(xp_value_ds[[j]]),xlab="p-values X term",main="",ylim=c(0,140),xlim=c(0,1),cex.lab=1.5)
  # hist(unlist(x2p_value_ds[[j]]), xlab=expression(p~-~values~ X^2~term),main="",ylim=c(0,140),xlim=c(0,1),cex.lab=1.5)
  # 
  # #surrogate all well
  # hist(unlist(xp_value_sur),xlab="p-values X term",main="",ylim=c(0,140),xlim=c(0,1),cex.lab=1.5,freq=TRUE)
  # hist(unlist(x2p_value_sur), xlab=expression(p~-~values~ X^2~term),main="",ylim=c(0,140),xlim=c(0,1),cex.lab=1.5,freq=TRUE)
  # 
  # mtext("(a) L-S residuals", side=3,line=-3,outer=TRUE)
  # mtext("(b) D-S residuals", side=3,line=-21,outer=TRUE)
  # mtext("(c) Surrogate residuals", side=3,line=-40,outer=TRUE)
  
  count_ls[[j]]<-length(xp_value_ls[xp_value_ls[[j]]<=0.05])
  count_ds[[j]]<-length(xp_value_ds[xp_value_ds[[j]]<=0.05])
  count_sur[[j]]<-length(xp_value_sur[xp_value_sur[[j]]<=0.05])
  #count_ls2[[j]]<-length(x2p_value_ls[x2p_value_ls[[j]]<=0.05])
  #count_ds2[[j]]<-length(x2p_value_ds[x2p_value_ds[[j]]<=0.05])
  #count_sur2[[j]]<-length(x2p_value_sur[x2p_value_sur[[j]]<=0.05])
}

table(unlist(count_ls))
table(unlist(count_ds))
table(unlist(count_sur))

par(mfrow=c(3,1))

hist(unlist(xp_value_ls),xlab="p-values X term",main="",ylim=c(0,10000),xlim=c(0,1),breaks=c(0,0.8,0.9,1.0),freq=TRUE,cex.lab=1.5)
hist(unlist(xp_value_ds),xlab="p-values X term",main="",ylim=c(0,10000),xlim=c(0,1),cex.lab=1.5)
hist(unlist(xp_value_sur),xlab="p-values X term",main="",ylim=c(0,10000),xlim=c(0,1),cex.lab=1.5)

mtext("(a) L-S residuals", side=3,line=-3,outer=TRUE)
mtext("(b) D-S residuals", side=3,line=-26,outer=TRUE)
mtext("(c) Surrogate residuals", side=3,line=-48,outer=TRUE)


length(xp_value_ls[xp_value_ls<=0.05]) #0
length(xp_value_ds[xp_value_ds<=0.05])
length(xp_value_sur[xp_value_sur<=0.05])


#QQL probit
#######################################################
library("ordinal")
library("tmvtnorm")
library("VGAM")
library("rms")
###############################################################
### The function used to ordinalize a continous variable
### Ordinal value: 1,2,3...
### Inputs: 
### 1. "z" is a vector to be ordinalized; 
### 2. "threshold" is a vector specifying the cut-off points
### Output: the returned value is also a vector
###############################################################
ordinalize<-function(z,threshold){ 
  oo<-function(zz){
    ordinal.value<-1;index<-1
    while(index<=length(threshold) && zz>threshold[index]) {ordinal.value<-ordinal.value+1;index<-index+1}
    return(ordinal.value)
  }
  return(sapply(z,oo))
}

xp_value_sur<-vector("list",10000)
x2p_value_sur<-vector("list",10000)

ls_res<-vector("list",10000)
xp_value_ls<-vector("list",10000)
x2p_value_ls<-vector("list",10000)

residfit_ds<-vector("list",10000)

clm_res<-vector("list",10000)
xp_value_ds<-vector("list",10000)
x2p_value_ds<-vector("list",10000)

residfit_ls<-vector("list",10000)


count_ls<-vector("list",10000)
count_ds<-vector("list",10000)
count_sur<-vector("list",10000)

count_ls2<-vector("list",10000)
count_ds2<-vector("list",10000)
count_sur2<-vector("list",10000)

for(j in 1:10000){
  set.seed(j)
  #########################################################################
  ### Simulate latent variable Z from a quadratic function of X plus noise
  ### The ordinal outcome W is obtained by discretizing Z
  ########################################################################
  n<-500
  
  alpha<-16;beta_1<--8;beta_2<-1
  thrd<-c(0,4,8)
  
  #X<-rnorm(n,mean=3,sd=2)
  X<-runif(n,1,7)
  RES<-rnorm(n)
  Z<-alpha+beta_1*X+beta_2*(X^2)+RES
  W<-ordinalize(Z,thrd)
  table(W)
  
  #par(mfrow=c(1,2),oma = c(0,0,3,0))
  #par(mfrow=c(1,2))
  #plot(X,Z,main="(a) Latent variable Z")
  
  ################################################################
  ### Model diagnosis when the model is specified correctly
  ###############################################################
  X_1<-X;X_2<-X^2
  model<-vglm(formula=(W-1)~X_1+X_2,family = cumulative(link = probit,parallel = TRUE))
  response<-as.ordered(W-1)
  model_c<-clm(response~X_1+X_2,link="probit")
  model_l<-orm(response~X_1+X_2,x=TRUE,y=TRUE,family=probit)
  #as.numeric(coef(summary(model))[,4][4]) p-value X1
  #as.numeric(coef(summary(model))[,4][5]) p-value X2
  alpha.hat<--coef(model)[1];beta_1.hat<--coef(model)[4];beta_2.hat<--coef(model)[5]
  thrd.hat<-c(0,coef(model)[2]-coef(model)[1],coef(model)[3]-coef(model)[1])

  #####Surrogate residual
  residual.bootstrap<-function(w,x){
    cc<-c(-Inf,thrd.hat,Inf)
    res<-rtmvnorm(1,algorithm="gibbs",mean=(alpha.hat+beta_1.hat*x+beta_2.hat*x^2),sigma=1,lower=cc[w],upper=cc[w+1])-(alpha.hat+beta_1.hat*x+beta_2.hat*x^2)
  }
 
  
  res.boot<-rep(NA,n)
  for(i in 1:n){
  res.boot[i]<-residual.bootstrap(W[i],X[i])
  residfit <- lm(res.boot~X_1)
  #xp_value_sur[[i]]<-anova(residfit)$'Pr(>F)'[2]
  xp_value_sur[[i]]<-anova(residfit)$'Pr(>F)'[1]
  }
  
  
  
  ##### Li-Shepherd residual
  ls_res[[j]]<-residuals(model_l,type="li.shepherd")
  # width<-0.45
  # res.LS<-residual.LS(W,X)
  # ls_res[[j]]<-residual.LS(W,X)
  # residual.LS<-function(w,x){
  #   cc<-c(-Inf,thrd.hat,Inf)
  #   res<-pnorm(cc[w+1]-(alpha.hat+beta_1.hat*x+beta_2.hat*(x^2)))+pnorm(cc[w]-(alpha.hat+beta_1.hat*x+beta_2.hat*(x^2)))-1
  #   return(res)
  # }
  residfit_ls[[j]] <- lm(ls_res[[j]]~X_1)
  #xp_value_ls[[j]]<-anova(residfit_ls[[j]])$'Pr(>F)'[2]
  xp_value_ls[[j]]<-anova(residfit_ls[[j]])$'Pr(>F)'[1]
  
  
  clm.residuals = function(obj) {
    preds = predict(obj, type="cum.prob")
    residuals = runif(length(preds$cprob1))*(preds$cprob1-preds$cprob2) + preds$cprob2
    return(qnorm(residuals))}
  
  clm_res[[j]]<-clm.residuals(model_c)
  residfit_ds[[j]]<- lm(clm_res[[j]]~X_1)
  #xp_value_ds[[j]]<-anova(residfit_ds[[j]])$'Pr(>F)'[2]
  xp_value_ds[[j]]<-anova(residfit_ds[[j]])$'Pr(>F)'[1]
  
  ##### Figure 1: SBS and surrogate residual when the model is correct
  par(mfrow=c(3,3))
  # 
  plot(X_1,ls_res[[j]], ylim=c(-1,1), xlab="X",ylab="L-S residuals",main="(a)",cex.lab=1.5)
  abline(h=0,lty=2,lwd=1)
  # 
  plot(X_2,ls_res[[j]], ylim=c(-1,1), xlab=expression(X^2),ylab="L-S residuals",main="(b)",cex.lab=1.5)
  abline(h=0,lty=2,lwd=1)
  # 
  sample.ref<-runif(10000,min=-1,max=1)
  qqplot(sample.ref,ls_res[[j]],main="(c)",ylab="L-S residuals",xlab="U(-1,1) distribution",cex.lab=1.5)
  abline(0,1,col="red",lwd=1)
  # 
  plot(clm.residuals(model_c)~X_1,ylab="D-S residuals",cex.lab=1.5,main="(d)",xlab="X")
  abline(h=0,col="black",lty=2,lwd=1)
  plot(clm.residuals(model_c)~X_2,ylab="D-S residuals",cex.lab=1.5,main="(e)",xlab=expression(X^2))
  abline(h=0,col="black",lty=2,lwd=1)
  qqnorm(clm.residuals(model_c),ylab="D-S residuals",xlab="Normal distribution",cex.lab=1.5,main="(f)")
  qqline(clm.residuals(model_c),col="red",lwd=1)
  # 
  plot(X_1,res.boot, ylim=c(-3,3),xlab="X",ylab="Surrogate residuals",main="(g)",cex.lab=1.5)
  abline(h=0,lty=2,lwd=1)
  #
  plot(X_1,res.boot,ylim=c(-3,3),lxlab=expression(X^2),ylab="Surrogate residuals",main="(h)",cex.lab=1.5)
  abline(h=0,lty=2,lwd=1)
  #
 #index<-which(prob<0.8)
  qqplot(RES,res.boot, xlab="Normal distribution",ylab="Surrogate residuals",main="(i)",cex.lab=1.5)
  abline(0,1,col="red",lwd=1)
  
  par(mfrow=c(3,2))
  # 
  # hist(unlist(xp_value_ls),xlab="p-values X term",main="",ylim=c(0,140),xlim=c(0,1),breaks=c(0,0.8,0.9,1.0),freq=TRUE,cex.lab=1.5)
  # hist(unlist(x2p_value_ls[[j]]), xlab=expression(p~-~values~ X^2~term),main="",ylim=c(0,140),xlim=c(0,1),breaks=c(0,0.8,0.9,1.0),freq=TRUE,cex.lab=1.5)
  # 
  # hist(unlist(xp_value_ds[[j]]),xlab="p-values X term",main="",ylim=c(0,140),xlim=c(0,1),cex.lab=1.5)
  # hist(unlist(x2p_value_ds[[j]]), xlab=expression(p~-~values~ X^2~term),main="",ylim=c(0,140),xlim=c(0,1),cex.lab=1.5)
  # 
  # #surrogate all well
  # hist(unlist(xp_value_sur),xlab="p-values X term",main="",ylim=c(0,140),xlim=c(0,1),cex.lab=1.5,freq=TRUE)
  # hist(unlist(x2p_value_sur), xlab=expression(p~-~values~ X^2~term),main="",ylim=c(0,140),xlim=c(0,1),cex.lab=1.5,freq=TRUE)
  # 
  # mtext("(a) L-S residuals", side=3,line=-3,outer=TRUE)
  # mtext("(b) D-S residuals", side=3,line=-21,outer=TRUE)
  # mtext("(c) Surrogate residuals", side=3,line=-40,outer=TRUE)
  
  count_ls[[j]]<-length(xp_value_ls[xp_value_ls[[j]]<=0.05])
  count_ds[[j]]<-length(xp_value_ds[xp_value_ds[[j]]<=0.05])
  count_sur[[j]]<-length(xp_value_sur[xp_value_sur[[j]]<=0.05])
  count_ls2[[j]]<-length(x2p_value_ls[x2p_value_ls[[j]]<=0.05])
  count_ds2[[j]]<-length(x2p_value_ds[x2p_value_ds[[j]]<=0.05])
  count_sur2[[j]]<-length(x2p_value_sur[x2p_value_sur[[j]]<=0.05])
}

table(unlist(count_ls))
# 
# 0 
# 10000
table(unlist(count_ds))
# 
# 0 10000 
#9931    69
table(unlist(count_sur))
# 0 10000 
# 9983    17 

table(unlist(count_ls2))
# 
# 0 
# 10000 

table(unlist(count_ds2))
# 
# 0 
# 10000 

table(unlist(count_sur2))
# 
# 0 
# 10000 

par(mfrow=c(3,1))

hist(unlist(xp_value_ls),xlab="p-values X term",main="",ylim=c(0,10000),xlim=c(0,1),breaks=c(0,0.8,0.9,1.0),freq=TRUE,cex.lab=1.5)

hist(unlist(xp_value_ds),xlab="p-values X term",main="",ylim=c(0,10000),xlim=c(0,1),cex.lab=1.5)

#surrogate all well
hist(unlist(xp_value_sur),xlab="p-values X term",main="",ylim=c(0,10000),xlim=c(0,1),cex.lab=1.5,freq=TRUE)

mtext("(a) L-S residuals", side=3,line=-3,outer=TRUE)
mtext("(b) D-S residuals", side=3,line=-24,outer=TRUE)
mtext("(c) Surrogate residuals", side=3,line=-45,outer=TRUE)


length(xp_value_ls[xp_value_ls<=0.05]) #0
length(x2p_value_ls[x2p_value_ls<=0.05]) #0

length(xp_value_ds[xp_value_ds<=0.05]) #69
length(x2p_value_ds[x2p_value_ds<=0.05]) #Error: (list) object cannot be coerced to type 'double

length(xp_value_sur[xp_value_sur<=0.05]) #Error: (list) object cannot be coerced to type 'double
length(x2p_value_sur[x2p_value_sur<=0.05]) #Error: (list) object cannot be coerced to type 'double

############################
#Subscenario 3.3. L-L-L
##############
##############
#LLL logit
##############
#######################################################################################################
######################################################################################################
library("ordinal")
library("tmvtnorm")
library("VGAM")
library("rms")
###############################################################
### The function used to ordinalize a continous variable
### Ordinal value: 1,2,3...
### Inputs: 
### 1. "z" is a vector to be ordinalized; 
### 2. "threshold" is a vector specifying the cut-off points
### Output: the returned value is also a vector
###############################################################
ordinalize<-function(z,threshold){ 
  oo<-function(zz){
    ordinal.value<-1;index<-1
    while(index<=length(threshold) && zz>threshold[index]) {ordinal.value<-ordinal.value+1;index<-index+1}
    return(ordinal.value)
  }
  return(sapply(z,oo))
}

xp_value_sur<-vector("list",10000)
x2p_value_sur<-vector("list",10000)

ls_res<-vector("list",10000)
xp_value_ls<-vector("list",10000)
x2p_value_ls<-vector("list",10000)

residfit_ds<-vector("list",10000)

clm_res<-vector("list",10000)
xp_value_ds<-vector("list",10000)
x2p_value_ds<-vector("list",10000)

residfit_ls<-vector("list",10000)


count_ls<-vector("list",10000)
count_ds<-vector("list",10000)
count_sur<-vector("list",10000)

count_ls2<-vector("list",10000)
count_ds2<-vector("list",10000)
count_sur2<-vector("list",10000)

for(j in 1: 10000){
  set.seed(j)
  #########################################################################
  ### Simulate latent variable Z from a quadratic function of X plus noise
  ### The ordinal outcome W is obtained by discretizing Z
  ########################################################################
  n<-500
  
  alpha<-16;beta_1<--8;beta_2<-1
  thrd<-c(0,4,8)
  
  #X<-rnorm(n,mean=3,sd=2)
  X<-runif(n,1,7)
  RES<-rnorm(n)
  Z<-alpha+beta_1*X+RES
  W<-ordinalize(Z,thrd)
  table(W)
  
  #par(mfrow=c(1,2),oma = c(0,0,3,0))
  #par(mfrow=c(1,2))
  #plot(X,Z,main="(a) Latent variable Z")
  
  ################################################################
  ### Model diagnosis when the model is specified correctly
  ###############################################################
  X_1<-X;X_2<-X^2
  model<-vglm(formula=(W-1)~X_1,family = cumulative(link =logit,parallel = TRUE))
  response<-as.ordered(W-1)
  model_c<-clm(response~X_1,link="logit")
  model_l<-lrm(response~X_1,x=TRUE,y=TRUE)
  #as.numeric(coef(summary(model))[,4][4]) p-value X1
  #as.numeric(coef(summary(model))[,4][5]) p-value X2
  alpha.hat<--coef(model)[1];beta_1.hat<--coef(model)[3];
  thrd.hat<-c(0,coef(model)[2]-coef(model)[1],coef(model)[3]-coef(model)[1])

  #####Surrogate residual
  residual.bootstrap<-function(w,x){
    cc<-c(-Inf,thrd.hat,Inf)
    res<-rtmvnorm(1,algorithm="gibbs",mean=(alpha.hat+beta_1.hat*x),sigma=1,lower=cc[w],upper=cc[w+1])-(alpha.hat+beta_1.hat*x)
  }
 
  
  res.boot<-rep(NA,n)
  for(i in 1:n){
  res.boot[i]<-residual.bootstrap(W[i],X[i])
  residfit <- lm(res.boot~X_1)
  #xp_value_sur[[i]]<-anova(residfit)$'Pr(>F)'[2]
  xp_value_sur[[i]]<-anova(residfit)$'Pr(>F)'[1]
  }
  
  
  
  ##### Li-Shepherd residual
  ls_res[[j]]<-residuals(model_l,type="li.shepherd")
  # width<-0.45
  # res.LS<-residual.LS(W,X)
  # ls_res[[j]]<-residual.LS(W,X)
  # residual.LS<-function(w,x){
  #   cc<-c(-Inf,thrd.hat,Inf)
  #   res<-pnorm(cc[w+1]-(alpha.hat+beta_1.hat*x+beta_2.hat*(x^2)))+pnorm(cc[w]-(alpha.hat+beta_1.hat*x+beta_2.hat*(x^2)))-1
  #   return(res)
  # }
  residfit_ls[[j]] <- lm(ls_res[[j]]~X_1)
  #xp_value_ls[[j]]<-anova(residfit_ls[[j]])$'Pr(>F)'[2]
  xp_value_ls[[j]]<-anova(residfit_ls[[j]])$'Pr(>F)'[1]
  
  
  clm.residuals = function(obj) {
    preds = predict(obj, type="cum.prob")
    residuals = runif(length(preds$cprob1))*(preds$cprob1-preds$cprob2) + preds$cprob2
    return(qnorm(residuals))}
  
  clm_res[[j]]<-clm.residuals(model_c)
  residfit_ds[[j]]<- lm(clm_res[[j]]~X_1)
xp_value_ds[[j]]<-anova(residfit_ds[[j]])$'Pr(>F)'[1]
  

  count_ls[[j]]<-length(xp_value_ls[xp_value_ls[[j]]<=0.05])
  count_ds[[j]]<-length(xp_value_ds[xp_value_ds[[j]]<=0.05])
  count_sur[[j]]<-length(xp_value_sur[xp_value_sur[[j]]<=0.05])
  #count_ls2[[j]]<-length(x2p_value_ls[x2p_value_ls[[j]]<=0.05])
  #count_ds2[[j]]<-length(x2p_value_ds[x2p_value_ds[[j]]<=0.05])
  #count_sur2[[j]]<-length(x2p_value_sur[x2p_value_sur[[j]]<=0.05])
}

table(unlist(count_ls))
#0 
#500 
table(unlist(count_ds))
#0 
#500 
table(unlist(count_sur))
#0 500 
#481  19 

table(unlist(count_ls2))
#0 
#500 
table(unlist(count_ds2))
#0 
#500 
table(unlist(count_sur2))

par(mfrow=c(3,2))

hist(unlist(xp_value_ls),xlab="p-values X term",main="",ylim=c(0,500),xlim=c(0,1),breaks=c(0,0.8,0.9,1.0),freq=TRUE,cex.lab=1.5)
hist(unlist(x2p_value_ls), xlab=expression(p~-~values~ X^2~term),main="",ylim=c(0,500),xlim=c(0,1),breaks=c(0,0.8,0.9,1.0),freq=TRUE,cex.lab=1.5)

hist(unlist(xp_value_ds),xlab="p-values X term",main="",ylim=c(0,500),xlim=c(0,1),cex.lab=1.5)
hist(unlist(x2p_value_ds), xlab=expression(p~-~values~ X^2~term),main="",ylim=c(0,500),xlim=c(0,1),cex.lab=1.5)

#surrogate all well
hist(unlist(xp_value_sur),xlab="p-values X term",main="",ylim=c(0,500),xlim=c(0,1),cex.lab=1.5,freq=TRUE)
hist(unlist(x2p_value_sur), xlab=expression(p~-~values~ X^2~term),main="",ylim=c(0,500),xlim=c(0,1),cex.lab=1.5,freq=TRUE)

mtext("(a) L-S residuals", side=3,line=-3,outer=TRUE)
mtext("(b) D-S residuals", side=3,line=-24,outer=TRUE)
mtext("(c) Surrogate residuals", side=3,line=-45,outer=TRUE)


length(xp_value_ls[xp_value_ls<=0.05]) #0
length(x2p_value_ls[x2p_value_ls<=0.05]) #0

length(xp_value_ds[xp_value_ds<=0.05]) #0
length(x2p_value_ds[x2p_value_ds<=0.05]) #3

length(xp_value_sur[xp_value_sur<=0.05]) #116
length(x2p_value_sur[x2p_value_sur<=0.05]) #4

############################
#Subscenario 3.4. Q-L-Q
############################
#Example
#######################################################################################################
######################################################################################################
library("tmvtnorm")
library("VGAM")
library("ordinal")
library("rms")
set.seed(977)
###############################################################
### The function used to ordinalize a continous variable
### Ordinal value: 1,2,3...
### Inputs: 
### 1. "z" is a vector to be ordinalized; 
### 2. "threshold" is a vector specifying the cut-off points
### Output: the returned value is also a vector
###############################################################
ordinalize<-function(z,threshold){ 
  oo<-function(zz){
    ordinal.value<-1;index<-1
    while(index<=length(threshold) && zz>threshold[index]) {ordinal.value<-ordinal.value+1;index<-index+1}
    return(ordinal.value)
  }
  return(sapply(z,oo))
}

#########################################################################
### Simulate latent variable Z from a quadratic function of X plus noise
### The ordinal outcome W is obtained by discretizing Z
########################################################################
n<-2000

alpha<-16;beta_1<--8;beta_2<-1
thrd<-c(0,4,8)

X<-rnorm(n,mean=3,sd=2)
#X<-runif(n,1,7)
RES<-rnorm(n)
Z<-alpha+beta_1*X+RES
W<-ordinalize(Z,thrd)
table(W)

#par(mfrow=c(1,2),oma = c(0,0,3,0))
#par(mfrow=c(1,2))
#plot(X,Z,main="(a) Latent variable Z")

################################################################
### Model diagnosis when the model is specified correctly
###############################################################
X_1<-X
model<-vglm(formula=W~X_1,family = cumulative(link =logit,parallel = TRUE))
response<-as.ordered(W)
model_c<-clm(response~X_1,link="logit")
model_l<-orm(response~X_1,x=TRUE,y=TRUE)
model_l2<-orm(response~X_1,x=TRUE,y=TRUE)
#as.numeric(coef(summary(model))[,4][4]) p-value X1
#as.numeric(coef(summary(model))[,4][5]) p-value X2
alpha.hat<--coef(model)[1];beta_1.hat<--coef(model)[3];
thrd.hat<-c(0,coef(model)[2]-coef(model)[1],coef(model)[3]-coef(model)[1])


#Deviance
model<-orm(response~as.numeric(X_1),x=TRUE,y=TRUE)
hist(resid(model, type="deviance"))
#Warning message:
#In residuals.lrm(object = list(freq = c(1407L, 147L, 119L, 327L),  :
#using first intercept and y>=2 to compute residuals or test GOF
#####################################################################################
#####################################################################################
#L-S
#####################################################################################
#####################################################################################

##### Li-Shepherd residual
width<-0.45

model<-vglm(formula=W~X,family = cumulative(link = logit,parallel = TRUE))
alpha.hat<--coef(model)[1];
beta_1.hat<--coef(model)[3];
thrd.hat<-c(0,coef(model)[2]-coef(model)[1],coef(model)[3]-coef(model)[1])


residual.LS<-function(w,x){
cc<-c(-Inf,thrd.hat,Inf)
res<-pnorm(cc[w+1]-(alpha.hat+beta_1.hat*x)+pnorm(cc[w]-(alpha.hat+beta_1.hat*x)))-1
return(res)
}


par(mfrow=c(1,2))
#PO
#model<-orm(response~X_1,x=TRUE,y=TRUE)
#hist(resid(model, type="li.shepherd"),main="",xlab="POM L-S residuals",xlim=c(-1,1))
#abline(v=0,col="red")
#or:
#library(MASS)
#library(PResiduals)
#mod<-polr(response~X_1,method="logistic")
#hist(presid(mod))
#PPO



model<-vglm(formula=W~X,family = cumulative(link = logit,parallel = TRUE))

alpha.hat<--coef(model)[1];beta.hat<--coef(model)[4]
thrd.hat<-c(0,coef(model)[2]-coef(model)[1],coef(model)[3]-coef(model)[1])

residual.LS<-function(w,x){
  cc<-c(-Inf,thrd.hat,Inf)
  res<-pnorm(cc[w+1]-(alpha.hat+beta.hat*x))+pnorm(cc[w]-(alpha.hat+beta.hat*x))-1
  return(res)
}

res.LS<-residual.LS(W,X)
hist(res.LS,main="",xlab="POM L-S residuals",xlim=c(-1,1),ylim=c(0,1500),breaks=c(-1,-0.90,-0.80,-0.70,-0.60,-0.50,-0.40,-0.30,-0.20,-0.10,0,0.10,0.20,0.30,0.40,0.50,0.60,0.70,0.80,0.90,1))
abline(v=0,col="red")

model2<-vglm(formula=W~X,family = cumulative(link = logit,parallel = FALSE))

alpha.hat<--coef(model2)[1];beta.hat<--coef(model2)[4]
thrd.hat<-c(0,coef(model2)[2]-coef(model2)[1],coef(model2)[3]-coef(model2)[1])

residual.LS<-function(w,x){
  cc<-c(-Inf,thrd.hat,Inf)
  res<-pnorm(cc[w+1]-(alpha.hat+beta.hat*x))+pnorm(cc[w]-(alpha.hat+beta.hat*x))-1
  return(res)
}

res.LS2<-residual.LS(W,X)
hist(res.LS2,main="",xlab="PPOM L-S residuals",xlim=c(-1,1),ylim=c(0,1500),breaks=c(-1,-0.90,-0.80,-0.70,-0.60,-0.50,-0.40,-0.30,-0.20,-0.10,0,0.10,0.20,0.30,0.40,0.50,0.60,0.70,0.80,0.90,1))
abline(v=0,col="red")
#####################################################################################
#####################################################################################
#D-S
#####################################################################################
#####################################################################################

#POM
model_c<-clm(as.ordered(W)~X_1,link="logit")
#Without as.ordered() Error: response in 'formula' needs to be a factor
#PPOM
model_c2<-clm(as.ordered(W)~X_1,link="logit",nominal=~X_1)
#Without as.ordered() Error: response in 'formula' needs to be a factor
clm.residuals = function(obj) {
  preds = predict(obj, type="cum.prob")
  residuals = runif(length(preds$cprob1))*(preds$cprob1-preds$cprob2) + preds$cprob2
  return(qnorm(residuals))}


par(mfrow=c(1,2))
#PO
hist(clm.residuals(model_c),main="",xlab="POM D-S residuals",xlim=c(-4,4))
abline(v=0,col="red")
#POM
hist(clm.residuals(model_c2),main="",xlab="PPOM D-S residuals",xlim=c(-4,4))
abline(v=0,col="red")
#Slightly less symmetric, consequence of wrong model or properties don't necessarily hold for PPO?


#####################################################################################
#####################################################################################
#Surrogate
#####################################################################################
#####################################################################################
library(sure)
set.seed(977)
modelpo<-vglm(formula=W~X_1,family = cumulative(link =logit,parallel = TRUE))
modelppo<-vglm(formula=W~X_1,family = cumulative(link =logit,parallel = FALSE))
par(mfrow=c(1,2))
hist(resids(modelpo),xlim=c(-10,10),main="",xlab="POM Surrogate residuals")
abline(v=0,col="red")
hist(resids(modelppo),xlim=c(-10,10),main="",xlab="PPOM Surrogate residuals")
abline(v=0,col="red")
plot(resids(modelpo)~X,ylab="PO surrogate residuals")
plot(resids(modelppo)~X,ylab="PPO surrogate residuals")



####FROM POM AND PPOM
# Simulate data from both a proportional odds and a non-proportional
# odds population model.  Check how 3 kinds of residuals detect
# non-prop. odds
set.seed(71)
n <- 400
x <- rnorm(n)

par(mfrow=c(2,3))
for(j in 1:2) {     # 1: prop.odds   2: non-prop. odds
  if(j==1) 
    L <- matrix(c(1.4,.4,-.1,-.5,-.9),nrow=n,ncol=5,byrow=TRUE) + x/2 else {
      # Slopes and intercepts for cutoffs of 1:5 :
      slopes <- c(.7,.5,.3,.3,0)
      ints   <- c(2.5,1.2,0,-1.2,-2.5)
      L <- matrix(ints,nrow=n,ncol=5,byrow=TRUE)+
        matrix(slopes,nrow=n,ncol=5,byrow=TRUE)*x
    }
  p <- plogis(L)
  # Cell probabilities
  p <- cbind(1-p[,1],p[,1]-p[,2],p[,2]-p[,3],p[,3]-p[,4],p[,4]-p[,5],p[,5])
  # Cumulative probabilities from left to right
  cp  <- matrix(cumsum(t(p)) - rep(0:(n-1), rep(6,n)), byrow=TRUE, ncol=6)
  y   <- (cp < runif(n)) %*% rep(1,6)
  
  
  f <- lrm(y ~ x, x=TRUE, y=TRUE)
  for(cutoff in 1:5)print(lrm(y>=cutoff ~ x)$coef)
  
  
  print(resid(f,'gof'))
  resid(f, 'score', pl=TRUE)
  # Note that full ordinal model score residuals exhibit a
  # U-shaped pattern even under prop. odds
  ti <- if(j==2) 'Non-Proportional Odds\nSlopes=.7 .5 .3 .3 0' else
    'True Proportional Odds\nOrdinal Model Score Residuals'
  title(ti)
  resid(f, 'score.binary', pl=TRUE)
  if(j==1) ti <- 'True Proportional Odds\nBinary Score Residuals'
  title(ti)
  resid(f, 'partial', pl=TRUE)
  if(j==1) ti <- 'True Proportional Odds\nPartial Residuals'
  title(ti)
}
par(mfrow=c(1,1))
#LLL probit
#######################################################################################################
######################################################################################################
library("ordinal")
library("tmvtnorm")
library("VGAM")
library("rms")
###############################################################
### The function used to ordinalize a continous variable
### Ordinal value: 1,2,3...
### Inputs: 
### 1. "z" is a vector to be ordinalized; 
### 2. "threshold" is a vector specifying the cut-off points
### Output: the returned value is also a vector
###############################################################
ordinalize<-function(z,threshold){ 
  oo<-function(zz){
    ordinal.value<-1;index<-1
    while(index<=length(threshold) && zz>threshold[index]) {ordinal.value<-ordinal.value+1;index<-index+1}
    return(ordinal.value)
  }
  return(sapply(z,oo))
}

xp_value_sur<-vector("list",10000)
x2p_value_sur<-vector("list",10000)

ls_res<-vector("list",10000)
xp_value_ls<-vector("list",10000)
x2p_value_ls<-vector("list",10000)

residfit_ds<-vector("list",10000)

clm_res<-vector("list",10000)
xp_value_ds<-vector("list",10000)
x2p_value_ds<-vector("list",10000)

residfit_ls<-vector("list",10000)


count_ls<-vector("list",10000)
count_ds<-vector("list",10000)
count_sur<-vector("list",10000)

count_ls2<-vector("list",10000)
count_ds2<-vector("list",10000)
count_sur2<-vector("list",10000)

for(j in 1:10000){
  set.seed(j)
  #########################################################################
  ### Simulate latent variable Z from a quadratic function of X plus noise
  ### The ordinal outcome W is obtained by discretizing Z
  ########################################################################
  n<-500
  
  alpha<-16;beta_1<--8;beta_2<-1
  thrd<-c(0,4,8)
  
  #X<-rnorm(n,mean=3,sd=2)
  X<-runif(n,1,7)
  RES<-rnorm(n)
  Z<-alpha+beta_1*X+RES
  W<-ordinalize(Z,thrd)
  table(W)
  
  #par(mfrow=c(1,2),oma = c(0,0,3,0))
  #par(mfrow=c(1,2))
  #plot(X,Z,main="(a) Latent variable Z")
  
  ################################################################
  ### Model diagnosis when the model is specified correctly
  ###############################################################
  X_1<-X;X_2<-X^2
  model<-vglm(formula=W-1~X_1,family = cumulative(link =probit,parallel = TRUE))
  response<-as.ordered(W-1)
  model_c<-clm(response~X_1,link="probit")
  model_l<-orm(response~X_1,x=TRUE,y=TRUE,family=probit)
  #as.numeric(coef(summary(model))[,4][4]) p-value X1
  #as.numeric(coef(summary(model))[,4][5]) p-value X2
  alpha.hat<--coef(model)[1];beta_1.hat<--coef(model)[3];
  thrd.hat<-c(0,coef(model)[2]-coef(model)[1],coef(model)[3]-coef(model)[1])

  #####Surrogate residual
  residual.bootstrap<-function(w,x){
    cc<-c(-Inf,thrd.hat,Inf)
    res<-rtmvnorm(1,algorithm="gibbs",mean=(alpha.hat+beta_1.hat*x),sigma=1,lower=cc[w],upper=cc[w+1])-(alpha.hat+beta_1.hat*x)
  }
 
  
  res.boot<-rep(NA,n)
  for(i in 1:n){
  res.boot[i]<-residual.bootstrap(W[i],X[i])
  residfit <- lm(res.boot~X_1)
  #xp_value_sur[[i]]<-anova(residfit)$'Pr(>F)'[2]
  xp_value_sur[[i]]<-anova(residfit)$'Pr(>F)'[1]
  }
  
  
  
  ##### Li-Shepherd residual
  ls_res[[j]]<-residuals(model_l,type="li.shepherd")
  # width<-0.45
  # res.LS<-residual.LS(W,X)
  # ls_res[[j]]<-residual.LS(W,X)
  # residual.LS<-function(w,x){
  #   cc<-c(-Inf,thrd.hat,Inf)
  #   res<-pnorm(cc[w+1]-(alpha.hat+beta_1.hat*x+beta_2.hat*(x^2)))+pnorm(cc[w]-(alpha.hat+beta_1.hat*x+beta_2.hat*(x^2)))-1
  #   return(res)
  # }
  residfit_ls[[j]] <- lm(ls_res[[j]]~X_1)
  #xp_value_ls[[j]]<-anova(residfit_ls[[j]])$'Pr(>F)'[2]
  xp_value_ls[[j]]<-anova(residfit_ls[[j]])$'Pr(>F)'[1]
  
  
  clm.residuals = function(obj) {
    preds = predict(obj, type="cum.prob")
    residuals = runif(length(preds$cprob1))*(preds$cprob1-preds$cprob2) + preds$cprob2
    return(qnorm(residuals))}
  
  clm_res[[j]]<-clm.residuals(model_c)
  residfit_ds[[j]]<- lm(clm_res[[j]]~X_1)
  #xp_value_ds[[j]]<-anova(residfit_ds[[j]])$'Pr(>F)'[2]
  xp_value_ds[[j]]<-anova(residfit_ds[[j]])$'Pr(>F)'[1]
  
  ##### Figure 1: SBS and surrogate residual when the model is correct
 #  par(mfrow=c(3,3))
 #  # 
 #  plot(X_1,ls_res[[j]], ylim=c(-1,1), xlab="X",ylab="L-S residuals",main="(a)",cex.lab=1.5)
 #  abline(h=0,lty=2,lwd=1)
 #  # 
 #  plot(X_2,ls_res[[j]], ylim=c(-1,1), xlab=expression(X^2),ylab="L-S residuals",main="(b)",cex.lab=1.5)
 #  abline(h=0,lty=2,lwd=1)
 #  # 
 #  sample.ref<-runif(10000,min=-1,max=1)
 #  qqplot(sample.ref,ls_res[[j]],main="(c)",ylab="L-S residuals",xlab="U(-1,1) distribution",cex.lab=1.5)
 #  abline(0,1,col="red",lwd=1)
 #  # 
 #  plot(clm.residuals(model_c)~X_1,ylab="D-S residuals",cex.lab=1.5,main="(d)",xlab="X")
 #  abline(h=0,col="black",lty=2,lwd=1)
 #  plot(clm.residuals(model_c)~X_2,ylab="D-S residuals",cex.lab=1.5,main="(e)",xlab=expression(X^2))
 #  abline(h=0,col="black",lty=2,lwd=1)
 #  qqnorm(clm.residuals(model_c),ylab="D-S residuals",xlab="Normal distribution",cex.lab=1.5,main="(f)")
 #  qqline(clm.residuals(model_c),col="red",lwd=1)
 #  # 
 #  plot(X_1,res.boot, ylim=c(-3,3),xlab="X",ylab="Surrogate residuals",main="(g)",cex.lab=1.5)
 #  abline(h=0,lty=2,lwd=1)
 #  #
 #  plot(X_1,res.boot,ylim=c(-3,3),lxlab=expression(X^2),ylab="Surrogate residuals",main="(h)",cex.lab=1.5)
 #  abline(h=0,lty=2,lwd=1)
 #  #
 # #index<-which(prob<0.8)
 #  qqplot(RES,res.boot, xlab="Normal distribution",ylab="Surrogate residuals",main="(i)",cex.lab=1.5)
 #  abline(0,1,col="red",lwd=1)
  
  par(mfrow=c(3,2))
  # 
  # hist(unlist(xp_value_ls),xlab="p-values X term",main="",ylim=c(0,140),xlim=c(0,1),breaks=c(0,0.8,0.9,1.0),freq=TRUE,cex.lab=1.5)
  # hist(unlist(x2p_value_ls[[j]]), xlab=expression(p~-~values~ X^2~term),main="",ylim=c(0,140),xlim=c(0,1),breaks=c(0,0.8,0.9,1.0),freq=TRUE,cex.lab=1.5)
  # 
  # hist(unlist(xp_value_ds[[j]]),xlab="p-values X term",main="",ylim=c(0,140),xlim=c(0,1),cex.lab=1.5)
  # hist(unlist(x2p_value_ds[[j]]), xlab=expression(p~-~values~ X^2~term),main="",ylim=c(0,140),xlim=c(0,1),cex.lab=1.5)
  # 
  # #surrogate all well
  # hist(unlist(xp_value_sur),xlab="p-values X term",main="",ylim=c(0,140),xlim=c(0,1),cex.lab=1.5,freq=TRUE)
  # hist(unlist(x2p_value_sur), xlab=expression(p~-~values~ X^2~term),main="",ylim=c(0,140),xlim=c(0,1),cex.lab=1.5,freq=TRUE)
  # 
  # mtext("(a) L-S residuals", side=3,line=-3,outer=TRUE)
  # mtext("(b) D-S residuals", side=3,line=-21,outer=TRUE)
  # mtext("(c) Surrogate residuals", side=3,line=-40,outer=TRUE)
  
  count_ls[[j]]<-length(xp_value_ls[xp_value_ls[[j]]<=0.05])
  count_ds[[j]]<-length(xp_value_ds[xp_value_ds[[j]]<=0.05])
  count_sur[[j]]<-length(xp_value_sur[xp_value_sur[[j]]<=0.05])
  #count_ls2[[j]]<-length(x2p_value_ls[x2p_value_ls[[j]]<=0.05])
  #count_ds2[[j]]<-length(x2p_value_ds[x2p_value_ds[[j]]<=0.05])
  #count_sur2[[j]]<-length(x2p_value_sur[x2p_value_sur[[j]]<=0.05])
}

table(unlist(count_ls))
#0 
#500 
table(unlist(count_ds))
#0 
#500 
table(unlist(count_sur))
#0 500 
#481  19 



par(mfrow=c(3,1))

hist(unlist(xp_value_ls),xlab="p-values X term",main="",ylim=c(0,10000),xlim=c(0,1),breaks=c(0,0.8,0.9,1.0),freq=TRUE,cex.lab=1.5)

hist(unlist(xp_value_ds),xlab="p-values X term",main="",ylim=c(0,10000),xlim=c(0,1),cex.lab=1.5)

#surrogate all well
hist(unlist(xp_value_sur),xlab="p-values X term",main="",ylim=c(0,10000),xlim=c(0,1),cex.lab=1.5,freq=TRUE)


mtext("(a) L-S residuals", side=3,line=-3,outer=TRUE)
mtext("(b) D-S residuals", side=3,line=-24,outer=TRUE)
mtext("(c) Surrogate residuals", side=3,line=-45,outer=TRUE)


length(xp_value_ls[xp_value_ls<=0.05]) #0


length(xp_value_ds[xp_value_ds<=0.05]) #0

length(xp_value_sur[xp_value_sur<=0.05]) #116



#QLQ PROBIT

library("ordinal")
library("tmvtnorm")
library("VGAM")
library("rms")
ordinalize<-function(z,threshold){ 
  oo<-function(zz){
    ordinal.value<-1;index<-1
    while(index<=length(threshold) && zz>threshold[index]) {ordinal.value<-ordinal.value+1;index<-index+1}
    return(ordinal.value)
  }
  return(sapply(z,oo))
}

xp_value_sur<-vector("list",10000)
x2p_value_sur<-vector("list",10000)

ls_res<-vector("list",10000)
xp_value_ls<-vector("list",10000)
x2p_value_ls<-vector("list",10000)

residfit_ds<-vector("list",10000)

clm_res<-vector("list",10000)
xp_value_ds<-vector("list",10000)
x2p_value_ds<-vector("list",10000)

residfit_ls<-vector("list",10000)


count_ls<-vector("list",10000)
count_ds<-vector("list",10000)
count_sur<-vector("list",10000)

count_ls2<-vector("list",10000)
count_ds2<-vector("list",10000)
count_sur2<-vector("list",10000)

for(j in 1:10000){
  set.seed(j)
  #########################################################################
  ### Simulate latent variable Z from a quadratic function of X plus noise
  ### The ordinal outcome W is obtained by discretizing Z
  ########################################################################
  n<-500
  
  alpha<-16;beta_1<--8;beta_2<-1
  thrd<-c(0,4,8)
  
  X<-runif(n,1,7)
  RES<-rnorm(n)
  Z<-alpha+beta_1*X+beta_2*(X^2)+RES
  W<-ordinalize(Z,thrd)
  table(W)
  
  ################################################################
  ### Model diagnosis when the model is specified correctly
  ###############################################################
  X_1<-X;X_2<-X^2
  model<-vglm(formula=(W-1)~X_1,family = cumulative(link = probit,parallel = TRUE))
  response<-as.ordered(W-1)
  model_c<-clm(response~X_1,link="probit")
  model_l<-orm(response~X_1,x=TRUE,y=TRUE,family=probit)
  alpha.hat<--coef(model)[1];beta_1.hat<--coef(model)[4];beta_2.hat<--coef(model)[5]
  thrd.hat<-c(0,coef(model)[2]-coef(model)[1],coef(model)[3]-coef(model)[1])

  #####Surrogate residual 
  residual.bootstrap<-function(w,x){
    cc<-c(-Inf,thrd.hat,Inf)
    res<-rtmvnorm(1,algorithm="gibbs",mean=(alpha.hat+beta_1.hat*x),sigma=1,lower=cc[w],upper=cc[w+1])-(alpha.hat+beta_1.hat*x)
  }
  res.boot<-rep(NA,n)
  for(i in 1:n){
  res.boot[i]<-residual.bootstrap(W[i],X[i])
  residfit <- lm(res.boot~X_1+X_2)
  xp_value_sur[[i]]<-anova(residfit)$'Pr(>F)'[2]
  x2p_value_sur[[i]]<-anova(residfit)$'Pr(>F)'[1]
  }

 
  ##### Li-Shepherd residual
  ls_res[[j]]<-residuals(model_l,type="li.shepherd")
  residfit_ls[[j]] <- lm(ls_res[[j]]~X_1+X_2)
  xp_value_ls[[j]]<-anova(residfit_ls[[j]])$'Pr(>F)'[2]
  x2p_value_ls[[j]]<-anova(residfit_ls[[j]])$'Pr(>F)'[1]
  
  
  clm.residuals = function(obj) {
    preds = predict(obj, type="cum.prob")
    residuals = runif(length(preds$cprob1))*(preds$cprob1-preds$cprob2) + preds$cprob2
    return(qnorm(residuals))}
  
  clm_res[[j]]<-clm.residuals(model_c)
  residfit_ds[[j]]<- lm(clm_res[[j]]~X_1+X_2)
  xp_value_ds[[j]]<-anova(residfit_ds[[j]])$'Pr(>F)'[2]
  x2p_value_ds[[j]]<-anova(residfit_ds[[j]])$'Pr(>F)'[1]
  
  ##### Figure 1: SBS and surrogate residual when the model is correct
  par(mfrow=c(3,3))
  # 
  plot(X_1,ls_res[[j]], ylim=c(-1,1), xlab="X",ylab="L-S residuals",main="(a)",cex.lab=1.5)
  abline(h=0,lty=2,lwd=1)
  # 
  plot(X_2,ls_res[[j]], ylim=c(-1,1), xlab=expression(X^2),ylab="L-S residuals",main="(b)",cex.lab=1.5)
  abline(h=0,lty=2,lwd=1)
  # 
  sample.ref<-runif(10000,min=-1,max=1)
  qqplot(sample.ref,ls_res[[j]],main="(c)",ylab="L-S residuals",xlab="U(-1,1) distribution",cex.lab=1.5)
  abline(0,1,col="red",lwd=1)
  # 
  plot(clm.residuals(model_c)~X_1,ylab="D-S residuals",cex.lab=1.5,main="(d)",xlab="X")
  abline(h=0,col="black",lty=2,lwd=1)
  plot(clm.residuals(model_c)~X_2,ylab="D-S residuals",cex.lab=1.5,main="(e)",xlab=expression(X^2))
  abline(h=0,col="black",lty=2,lwd=1)
  qqnorm(clm.residuals(model_c),ylab="D-S residuals",xlab="Normal distribution",cex.lab=1.5,main="(f)")
  qqline(clm.residuals(model_c),col="red",lwd=1)
  # 
  plot(X_1,res.boot, ylim=c(-3,3),xlab="X",ylab="Surrogate residuals",main="(g)",cex.lab=1.5)
  abline(h=0,lty=2,lwd=1)
  #
  plot(X_2,res.boot,ylim=c(-3,3),xlab=expression(X^2),ylab="Surrogate residuals",main="(h)",cex.lab=1.5)
  abline(h=0,lty=2,lwd=1)
  #
 #index<-which(prob<0.8)
  qqplot(RES,res.boot, xlab="Normal distribution",ylab="Surrogate residuals",main="(i)",cex.lab=1.5)
  abline(0,1,col="red",lwd=1)
  
  
  count_ls[[j]]<-length(xp_value_ls[xp_value_ls[[j]]<=0.05])
  count_ds[[j]]<-length(xp_value_ds[xp_value_ds[[j]]<=0.05])
  count_sur[[j]]<-length(xp_value_sur[xp_value_sur[[j]]<=0.05])
  count_ls2[[j]]<-length(x2p_value_ls[x2p_value_ls[[j]]<=0.05])
  count_ds2[[j]]<-length(x2p_value_ds[x2p_value_ds[[j]]<=0.05])
  count_sur2[[j]]<-length(x2p_value_sur[x2p_value_sur[[j]]<=0.05])
}

table(unlist(count_ls))
#0 
#500 
table(unlist(count_ds))
#0 
#500 
table(unlist(count_sur))
#0 500 
#481  19 

# table(unlist(count_ls2))
# #0 
# #500 
# table(unlist(count_ds2))
# #0 
# #500 
# table(unlist(count_sur2))

par(mfrow=c(3,2))

hist(unlist(xp_value_ls),xlab="p-values X term",main="",ylim=c(0,10000),xlim=c(0,1),breaks=c(0,0.8,0.9,1.0),freq=TRUE,cex.lab=1.5)
hist(unlist(x2p_value_ls), xlab=expression(p~-~values~ X^2~term),main="",ylim=c(0,10000),xlim=c(0,1),breaks=c(0,0.8,0.9,1.0),freq=TRUE,cex.lab=1.5)

hist(unlist(xp_value_ds),xlab="p-values X term",main="",ylim=c(0,10000),xlim=c(0,1),cex.lab=1.5)
hist(unlist(x2p_value_ds), xlab=expression(p~-~values~ X^2~term),main="",ylim=c(0,10000),xlim=c(0,1),cex.lab=1.5)

#surrogate all well
hist(unlist(xp_value_sur),xlab="p-values X term",main="",ylim=c(0,10000),xlim=c(0,1),cex.lab=1.5,freq=TRUE)
hist(unlist(x2p_value_sur), xlab=expression(p~-~values~ X^2~term),main="",ylim=c(0,10000),xlim=c(0,1),cex.lab=1.5,freq=TRUE)

mtext("(a) L-S residuals", side=3,line=-2,outer=TRUE)
mtext("(b) D-S residuals", side=3,line=-20,outer=TRUE)
mtext("(c) Surrogate residuals", side=3,line=-39,outer=TRUE)


length(xp_value_ls[xp_value_ls<=0.05]) #10000
length(x2p_value_ls[x2p_value_ls<=0.05]) 

length(xp_value_ds[xp_value_ds<=0.05]) #10000
length(x2p_value_ds[x2p_value_ds<=0.05]) 

length(xp_value_sur[xp_value_sur<=0.05]) #Error: (list) object cannot be coerced to type 'double'
length(x2p_value_sur[x2p_value_sur<=0.05]) 

#######################################################
#Subscenario 3.5.  Q-L-L
#######################################################
##############
#QLL logit
##############
#######################################################################################################
######################################################################################################
library("ordinal")
library("tmvtnorm")
library("VGAM")
library("rms")
###############################################################
### The function used to ordinalize a continous variable
### Ordinal value: 1,2,3...
### Inputs: 
### 1. "z" is a vector to be ordinalized; 
### 2. "threshold" is a vector specifying the cut-off points
### Output: the returned value is also a vector
###############################################################
ordinalize<-function(z,threshold){ 
  oo<-function(zz){
    ordinal.value<-1;index<-1
    while(index<=length(threshold) && zz>threshold[index]) {ordinal.value<-ordinal.value+1;index<-index+1}
    return(ordinal.value)
  }
  return(sapply(z,oo))
}

xp_value_sur<-vector("list",10000)
x2p_value_sur<-vector("list",10000)

ls_res<-vector("list",10000)
xp_value_ls<-vector("list",10000)
x2p_value_ls<-vector("list",10000)

residfit_ds<-vector("list",10000)

clm_res<-vector("list",10000)
xp_value_ds<-vector("list",10000)
x2p_value_ds<-vector("list",10000)

residfit_ls<-vector("list",10000)


count_ls<-vector("list",10000)
count_ds<-vector("list",10000)
count_sur<-vector("list",10000)

count_ls2<-vector("list",10000)
count_ds2<-vector("list",10000)
count_sur2<-vector("list",10000)

for(j in 1:10000){
  set.seed(j)
  #########################################################################
  ### Simulate latent variable Z from a quadratic function of X plus noise
  ### The ordinal outcome W is obtained by discretizing Z
  ########################################################################
  n<-500
  
  alpha<-16;beta_1<--8;beta_2<-1
  thrd<-c(0,4,8)
  
  #X<-rnorm(n,mean=3,sd=2)
  X<-runif(n,1,7)
  RES<-rnorm(n)
  Z<-alpha+beta_1*X+beta_2*(X^2)+RES
  W<-ordinalize(Z,thrd)
  table(W)
  
  #par(mfrow=c(1,2),oma = c(0,0,3,0))
  #par(mfrow=c(1,2))
  #plot(X,Z,main="(a) Latent variable Z")
  
  ################################################################
  ### Model diagnosis when the model is specified correctly
  ###############################################################
  X_1<-X;X_2<-X^2
  model<-vglm(formula=(W-1)~X_1,family = cumulative(link = logit,parallel = TRUE))
  response<-as.ordered(W-1)
  model_c<-clm(response~X_1,link="logit")
  model_l<-lrm(response~X_1,x=TRUE,y=TRUE)
  #as.numeric(coef(summary(model))[,4][4]) p-value X1
  #as.numeric(coef(summary(model))[,4][5]) p-value X2
  alpha.hat<--coef(model)[1];beta_1.hat<--coef(model)[4];beta_2.hat<--coef(model)[5]
  thrd.hat<-c(0,coef(model)[2]-coef(model)[1],coef(model)[3]-coef(model)[1])

  #####Surrogate residual
  residual.bootstrap<-function(w,x){
    cc<-c(-Inf,thrd.hat,Inf)
    res<-rtmvnorm(1,algorithm="gibbs",mean=(alpha.hat+beta_1.hat*x),sigma=1,lower=cc[w],upper=cc[w+1])-(alpha.hat+beta_1.hat*x)
  }
 
  
  res.boot<-rep(NA,n)
  for(i in 1:n){
  res.boot[i]<-residual.bootstrap(W[i],X[i])
  residfit <- lm(res.boot~X_1)
  xp_value_sur[[i]]<-anova(residfit)$'Pr(>F)'[2]
  x2p_value_sur[[i]]<-anova(residfit)$'Pr(>F)'[1]
  }
  
  
  
  ##### Li-Shepherd residual
  ls_res[[j]]<-residuals(model_l,type="li.shepherd")
  # width<-0.45
  # res.LS<-residual.LS(W,X)
  # ls_res[[j]]<-residual.LS(W,X)
  # residual.LS<-function(w,x){
  #   cc<-c(-Inf,thrd.hat,Inf)
  #   res<-pnorm(cc[w+1]-(alpha.hat+beta_1.hat*x+beta_2.hat*(x^2)))+pnorm(cc[w]-(alpha.hat+beta_1.hat*x+beta_2.hat*(x^2)))-1
  #   return(res)
  # }
  residfit_ls[[j]] <- lm(ls_res[[j]]~X_1)
  xp_value_ls[[j]]<-anova(residfit_ls[[j]])$'Pr(>F)'[2]
  x2p_value_ls[[j]]<-anova(residfit_ls[[j]])$'Pr(>F)'[1]
  
  
  clm.residuals = function(obj) {
    preds = predict(obj, type="cum.prob")
    residuals = runif(length(preds$cprob1))*(preds$cprob1-preds$cprob2) + preds$cprob2
    return(qnorm(residuals))}
  
  clm_res[[j]]<-clm.residuals(model_c)
  residfit_ds[[j]]<- lm(clm_res[[j]]~X_1)
  xp_value_ds[[j]]<-anova(residfit_ds[[j]])$'Pr(>F)'[2]
  x2p_value_ds[[j]]<-anova(residfit_ds[[j]])$'Pr(>F)'[1]
  
  ##### Figure 1: SBS and surrogate residual when the model is correct
  par(mfrow=c(3,3))
  # 
  plot(X_1,ls_res[[j]], ylim=c(-1,1), xlab="X",ylab="L-S residuals",main="(a)",cex.lab=1.5)
  abline(h=0,lty=2,lwd=1)
  # 
  plot(X_2,ls_res[[j]], ylim=c(-1,1), xlab=expression(X^2),ylab="L-S residuals",main="(b)",cex.lab=1.5)
  abline(h=0,lty=2,lwd=1)
  # 
  sample.ref<-runif(10000,min=-1,max=1)
  qqplot(sample.ref,ls_res[[j]],main="(c)",ylab="L-S residuals",xlab="U(-1,1) distribution",cex.lab=1.5)
  abline(0,1,col="red",lwd=1)
  # 
  plot(clm.residuals(model_c)~X_1,ylab="D-S residuals",cex.lab=1.5,main="(d)",xlab="X")
  abline(h=0,col="black",lty=2,lwd=1)
  plot(clm.residuals(model_c)~X_2,ylab="D-S residuals",cex.lab=1.5,main="(e)",xlab=expression(X^2))
  abline(h=0,col="black",lty=2,lwd=1)
  qqnorm(clm.residuals(model_c),ylab="D-S residuals",xlab="Normal distribution",cex.lab=1.5,main="(f)")
  qqline(clm.residuals(model_c),col="red",lwd=1)
  # 
  plot(X_1,res.boot, ylim=c(-3,3),xlab="X",ylab="Surrogate residuals",main="(g)",cex.lab=1.5)
  abline(h=0,lty=2,lwd=1)
  #
  plot(X_1,res.boot,ylim=c(-3,3),xlab=expression(X^2),ylab="Surrogate residuals",main="(h)",cex.lab=1.5)
  abline(h=0,lty=2,lwd=1)
  #
 #index<-which(prob<0.8)
  qqplot(RES,res.boot, xlab="Normal distribution",ylab="Surrogate residuals",main="(i)",cex.lab=1.5)
  abline(0,1,col="red",lwd=1)
  
  par(mfrow=c(3,2))
  # 
  # hist(unlist(xp_value_ls),xlab="p-values X term",main="",ylim=c(0,140),xlim=c(0,1),breaks=c(0,0.8,0.9,1.0),freq=TRUE,cex.lab=1.5)
  # hist(unlist(x2p_value_ls[[j]]), xlab=expression(p~-~values~ X^2~term),main="",ylim=c(0,140),xlim=c(0,1),breaks=c(0,0.8,0.9,1.0),freq=TRUE,cex.lab=1.5)
  # 
  # hist(unlist(xp_value_ds[[j]]),xlab="p-values X term",main="",ylim=c(0,140),xlim=c(0,1),cex.lab=1.5)
  # hist(unlist(x2p_value_ds[[j]]), xlab=expression(p~-~values~ X^2~term),main="",ylim=c(0,140),xlim=c(0,1),cex.lab=1.5)
  # 
  # #surrogate all well
  # hist(unlist(xp_value_sur),xlab="p-values X term",main="",ylim=c(0,140),xlim=c(0,1),cex.lab=1.5,freq=TRUE)
  # hist(unlist(x2p_value_sur), xlab=expression(p~-~values~ X^2~term),main="",ylim=c(0,140),xlim=c(0,1),cex.lab=1.5,freq=TRUE)
  # 
  # mtext("(a) L-S residuals", side=3,line=-3,outer=TRUE)
  # mtext("(b) D-S residuals", side=3,line=-21,outer=TRUE)
  # mtext("(c) Surrogate residuals", side=3,line=-40,outer=TRUE)
  
  count_ls[[j]]<-length(xp_value_ls[xp_value_ls[[j]]<=0.05])
  #count_ds[[j]]<-length(xp_value_ds[xp_value_ds[[j]]<=0.05])
  count_sur[[j]]<-length(xp_value_sur[xp_value_sur[[j]]<=0.05])
  #count_ls2[[j]]<-length(x2p_value_ls[x2p_value_ls[[j]]<=0.05])
  count_ds2[[j]]<-length(x2p_value_ds[x2p_value_ds[[j]]<=0.05])
  #count_sur2[[j]]<-length(x2p_value_sur[x2p_value_sur[[j]]<=0.05])
}

table(unlist(count_ls))
#0 
#500 
table(unlist(count_ds))
#0 
#500 
table(unlist(count_sur))
#0 500 
#481  19 

# table(unlist(count_ls2))
# #0 
# #500 
# table(unlist(count_ds2))
# #0 
# #500 
# table(unlist(count_sur2))

par(mfrow=c(3,1))

hist(unlist(xp_value_ls),xlab="p-values X term",main="",ylim=c(0,500),xlim=c(0,1),breaks=c(0,0.8,0.9,1.0),freq=TRUE,cex.lab=1.5)
#hist(unlist(x2p_value_ls), xlab=expression(p~-~values~ X^2~term),main="",ylim=c(0,500),xlim=c(0,1),breaks=c(0,0.8,0.9,1.0),freq=TRUE,cex.lab=1.5)

hist(unlist(xp_value_ds),xlab="p-values X term",main="",ylim=c(0,500),xlim=c(0,1),cex.lab=1.5)
#hist(unlist(x2p_value_ds), xlab=expression(p~-~values~ X^2~term),main="",ylim=c(0,500),xlim=c(0,1),cex.lab=1.5)

#surrogate all well
hist(unlist(xp_value_sur),xlab="p-values X term",main="",ylim=c(0,500),xlim=c(0,1),cex.lab=1.5,freq=TRUE)
#hist(unlist(x2p_value_sur), xlab=expression(p~-~values~ X^2~term),main="",ylim=c(0,500),xlim=c(0,1),cex.lab=1.5,freq=TRUE)

mtext("(a) L-S residuals", side=3,line=-3,outer=TRUE)
mtext("(b) D-S residuals", side=3,line=-24,outer=TRUE)
mtext("(c) Surrogate residuals", side=3,line=-45,outer=TRUE)


length(xp_value_ls[xp_value_ls<=0.05]) #10000
#length(x2p_value_ls[x2p_value_ls<=0.05]) 

length(xp_value_ds[xp_value_ds<=0.05]) #10000
#length(x2p_value_ds[x2p_value_ds<=0.05]) 

length(xp_value_sur[xp_value_sur<=0.05]) #Error: (list) object cannot be coerced to type 'double'
#length(x2p_value_sur[x2p_value_sur<=0.05]) 

###
#QLL probit
#######################################################################################################
######################################################################################################
library("ordinal")
library("tmvtnorm")
library("VGAM")
library("rms")
###############################################################
### The function used to ordinalize a continous variable
### Ordinal value: 1,2,3...
### Inputs: 
### 1. "z" is a vector to be ordinalized; 
### 2. "threshold" is a vector specifying the cut-off points
### Output: the returned value is also a vector
###############################################################
ordinalize<-function(z,threshold){ 
  oo<-function(zz){
    ordinal.value<-1;index<-1
    while(index<=length(threshold) && zz>threshold[index]) {ordinal.value<-ordinal.value+1;index<-index+1}
    return(ordinal.value)
  }
  return(sapply(z,oo))
}

xp_value_sur<-vector("list",500)
x2p_value_sur<-vector("list",500)

ls_res<-vector("list",500)
xp_value_ls<-vector("list",500)
x2p_value_ls<-vector("list",500)

residfit_ds<-vector("list",500)

clm_res<-vector("list",500)
xp_value_ds<-vector("list",500)
x2p_value_ds<-vector("list",500)

residfit_ls<-vector("list",500)


count_ls<-vector("list",500)
count_ds<-vector("list",500)
count_sur<-vector("list",500)

count_ls2<-vector("list",500)
count_ds2<-vector("list",500)
count_sur2<-vector("list",500)

for(j in 498:498){
  set.seed(j)
  #########################################################################
  ### Simulate latent variable Z from a quadratic function of X plus noise
  ### The ordinal outcome W is obtained by discretizing Z
  ########################################################################
  n<-500
  
  alpha<-16;beta_1<--8;beta_2<-1
  thrd<-c(0,4,8)
  
  #X<-rnorm(n,mean=3,sd=2)
  X<-runif(n,1,7)
  RES<-rnorm(n)
  Z<-alpha+beta_1*X+beta_2*(X^2)+RES
  W<-ordinalize(Z,thrd)
  table(W)
  
  #par(mfrow=c(1,2),oma = c(0,0,3,0))
  par(mfrow=c(1,2))
  #plot(X,Z,main="(a) Latent variable Z")
  
  ################################################################
  ### Model diagnosis when the model is specified correctly
  ###############################################################
  X_1<-X;X_2<-X^2
  model<-vglm(formula=(W-1)~X_1,family = cumulative(link = probit,parallel = TRUE))
  response<-as.ordered(W-1)
  model_c<-clm(response~X_1,link="probit")
  model_l<-orm(response~X_1,x=TRUE,y=TRUE,family=probit)
  #as.numeric(coef(summary(model))[,4][4]) p-value X1
  #as.numeric(coef(summary(model))[,4][5]) p-value X2
  alpha.hat<--coef(model)[1];beta_1.hat<--coef(model)[4];beta_2.hat<--coef(model)[5]
  thrd.hat<-c(0,coef(model)[2]-coef(model)[1],coef(model)[3]-coef(model)[1])

  #####Surrogate residual
  residual.bootstrap<-function(w,x){
    cc<-c(-Inf,thrd.hat,Inf)
    res<-rtmvnorm(1,algorithm="gibbs",mean=(alpha.hat+beta_1.hat*x),sigma=1,lower=cc[w],upper=cc[w+1])-(alpha.hat+beta_1.hat*x)
  }
 
  
  res.boot<-rep(NA,n)
  for(i in 1:n){
  res.boot[i]<-residual.bootstrap(W[i],X[i])
  residfit <- lm(res.boot~X_1)
  #xp_value_sur[[i]]<-anova(residfit)$'Pr(>F)'[2]
  xp_value_sur[[i]]<-anova(residfit)$'Pr(>F)'[1]
  }
  
  
  
  ##### Li-Shepherd residual
  ls_res[[j]]<-residuals(model_l,type="li.shepherd")
  # width<-0.45
  # res.LS<-residual.LS(W,X)
  # ls_res[[j]]<-residual.LS(W,X)
  # residual.LS<-function(w,x){
  #   cc<-c(-Inf,thrd.hat,Inf)
  #   res<-pnorm(cc[w+1]-(alpha.hat+beta_1.hat*x+beta_2.hat*(x^2)))+pnorm(cc[w]-(alpha.hat+beta_1.hat*x+beta_2.hat*(x^2)))-1
  #   return(res)
  # }
  residfit_ls[[j]] <- lm(ls_res[[j]]~X_1)
  #xp_value_ls[[j]]<-anova(residfit_ls[[j]])$'Pr(>F)'[2]
  xp_value_ls[[j]]<-anova(residfit_ls[[j]])$'Pr(>F)'[1]
  
  
  clm.residuals = function(obj) {
    preds = predict(obj, type="cum.prob")
    residuals = runif(length(preds$cprob1))*(preds$cprob1-preds$cprob2) + preds$cprob2
    return(qnorm(residuals))}
  
  clm_res[[j]]<-clm.residuals(model_c)
  residfit_ds[[j]]<- lm(clm_res[[j]]~X_1)
  #xp_value_ds[[j]]<-anova(residfit_ds[[j]])$'Pr(>F)'[2]
  xp_value_ds[[j]]<-anova(residfit_ds[[j]])$'Pr(>F)'[1]
  
  ##### Figure 1: SBS and surrogate residual when the model is correct
  # par(mfrow=c(3,3))
  # # 
  # plot(X_1,ls_res[[j]], ylim=c(-1,1), xlab="X",ylab="L-S residuals",main="(a)",cex.lab=1.5)
  # abline(h=0,lty=2,lwd=1)
  # # 
  # plot(X_2,ls_res[[j]], ylim=c(-1,1), xlab=expression(X^2),ylab="L-S residuals",main="(b)",cex.lab=1.5)
  # abline(h=0,lty=2,lwd=1)
  # # 
  # sample.ref<-runif(10000,min=-1,max=1)
  # qqplot(sample.ref,ls_res[[j]],main="(c)",ylab="L-S residuals",xlab="U(-1,1) distribution",cex.lab=1.5)
  # abline(0,1,col="red",lwd=1)
  # # 
  # plot(clm.residuals(model_c)~X_1,ylab="D-S residuals",cex.lab=1.5,main="(d)",xlab="X")
  # abline(h=0,col="black",lty=2,lwd=1)
  # plot(clm.residuals(model_c)~X_2,ylab="D-S residuals",cex.lab=1.5,main="(e)",xlab=expression(X^2))
  # abline(h=0,col="black",lty=2,lwd=1)
  # qqnorm(clm.residuals(model_c),ylab="D-S residuals",xlab="Normal distribution",cex.lab=1.5,main="(f)")
  # qqline(clm.residuals(model_c),col="red",lwd=1)
  # # 
  # plot(X_1,res.boot, ylim=c(-3,3),xlab="X",ylab="Surrogate residuals",main="(g)",cex.lab=1.5)
  # abline(h=0,lty=2,lwd=1)
  # #
  # plot(X_1,res.boot,ylim=c(-3,3),lxlab=expression(X^2),ylab="Surrogate residuals",main="(h)",cex.lab=1.5)
  # abline(h=0,lty=2,lwd=1)
  # #
 #index<-which(prob<0.8)
  qqplot(RES,res.boot, xlab="Normal distribution",ylab="Surrogate residuals",main="(a) Cumulative probit model",cex.lab=1.5)
  abline(0,1,col="red",lwd=1)
  
  #par(mfrow=c(3,2))
  # 
  # hist(unlist(xp_value_ls),xlab="p-values X term",main="",ylim=c(0,140),xlim=c(0,1),breaks=c(0,0.8,0.9,1.0),freq=TRUE,cex.lab=1.5)
  # hist(unlist(x2p_value_ls[[j]]), xlab=expression(p~-~values~ X^2~term),main="",ylim=c(0,140),xlim=c(0,1),breaks=c(0,0.8,0.9,1.0),freq=TRUE,cex.lab=1.5)
  # 
  # hist(unlist(xp_value_ds[[j]]),xlab="p-values X term",main="",ylim=c(0,140),xlim=c(0,1),cex.lab=1.5)
  # hist(unlist(x2p_value_ds[[j]]), xlab=expression(p~-~values~ X^2~term),main="",ylim=c(0,140),xlim=c(0,1),cex.lab=1.5)
  # 
  # #surrogate all well
  # hist(unlist(xp_value_sur),xlab="p-values X term",main="",ylim=c(0,140),xlim=c(0,1),cex.lab=1.5,freq=TRUE)
  # hist(unlist(x2p_value_sur), xlab=expression(p~-~values~ X^2~term),main="",ylim=c(0,140),xlim=c(0,1),cex.lab=1.5,freq=TRUE)
  # 
  # mtext("(a) L-S residuals", side=3,line=-3,outer=TRUE)
  # mtext("(b) D-S residuals", side=3,line=-21,outer=TRUE)
  # mtext("(c) Surrogate residuals", side=3,line=-40,outer=TRUE)
  
  count_ls[[j]]<-length(xp_value_ls[xp_value_ls[[j]]<=0.05])
  count_ds[[j]]<-length(xp_value_ds[xp_value_ds[[j]]<=0.05])
  count_sur[[j]]<-length(xp_value_sur[xp_value_sur[[j]]<=0.05])
  count_ls2[[j]]<-length(x2p_value_ls[x2p_value_ls[[j]]<=0.05])
  count_ds2[[j]]<-length(x2p_value_ds[x2p_value_ds[[j]]<=0.05])
  count_sur2[[j]]<-length(x2p_value_sur[x2p_value_sur[[j]]<=0.05])
}

xp_value_sur<-vector("list",500)
x2p_value_sur<-vector("list",500)

ls_res<-vector("list",500)
xp_value_ls<-vector("list",500)
x2p_value_ls<-vector("list",500)

residfit_ds<-vector("list",500)

clm_res<-vector("list",500)
xp_value_ds<-vector("list",500)
x2p_value_ds<-vector("list",500)

residfit_ls<-vector("list",500)


count_ls<-vector("list",500)
count_ds<-vector("list",500)
count_sur<-vector("list",500)

count_ls2<-vector("list",500)
count_ds2<-vector("list",500)
count_sur2<-vector("list",500)

for(j in 498:498){
  set.seed(j)
  #########################################################################
  ### Simulate latent variable Z from a quadratic function of X plus noise
  ### The ordinal outcome W is obtained by discretizing Z
  ########################################################################
  n<-500
  
  alpha<-16;beta_1<--8;beta_2<-1
  thrd<-c(0,4,8)
  
  #X<-rnorm(n,mean=3,sd=2)
  X<-runif(n,1,7)
  RES<-rnorm(n)
  Z<-alpha+beta_1*X+beta_2*(X^2)+RES
  W<-ordinalize(Z,thrd)
  table(W)
  
  #par(mfrow=c(1,2),oma = c(0,0,3,0))
  #par(mfrow=c(1,2))
  #plot(X,Z,main="(a) Latent variable Z")
  
  ################################################################
  ### Model diagnosis when the model is specified correctly
  ###############################################################
  X_1<-X;X_2<-X^2
  model<-vglm(formula=(W-1)~X_1+X_2,family = cumulative(link = logit,parallel = TRUE))
  response<-as.ordered(W-1)
  model_c<-clm(response~X_1+X_2,link="logit")
  model_l<-lrm(response~X_1+X_2,x=TRUE,y=TRUE)
  #as.numeric(coef(summary(model))[,4][4]) p-value X1
  #as.numeric(coef(summary(model))[,4][5]) p-value X2
  alpha.hat<--coef(model)[1];beta_1.hat<--coef(model)[4];beta_2.hat<--coef(model)[5]
  thrd.hat<-c(0,coef(model)[2]-coef(model)[1],coef(model)[3]-coef(model)[1])
  
  #####Surrogate residual
  residual.bootstrap<-function(w,x){
    cc<-c(-Inf,thrd.hat,Inf)
    res<-rtmvnorm(1,algorithm="gibbs",mean=(alpha.hat+beta_1.hat*x+beta_2.hat*x^2),sigma=1,lower=cc[w],upper=cc[w+1])-(alpha.hat+beta_1.hat*x+beta_2.hat*x^2)
  }
  
  
  res.boot<-rep(NA,n)
  for(i in 1:n){
    res.boot[i]<-residual.bootstrap(W[i],X[i])
    residfit <- lm(res.boot~X_1)
    xp_value_sur[[i]]<-anova(residfit)$'Pr(>F)'[2]
    x2p_value_sur[[i]]<-anova(residfit)$'Pr(>F)'[1]
  }
  
  
  
  ##### Li-Shepherd residual
  ls_res[[j]]<-residuals(model_l,type="li.shepherd")
  # width<-0.45
  # res.LS<-residual.LS(W,X)
  # ls_res[[j]]<-residual.LS(W,X)
  # residual.LS<-function(w,x){
  #   cc<-c(-Inf,thrd.hat,Inf)
  #   res<-pnorm(cc[w+1]-(alpha.hat+beta_1.hat*x+beta_2.hat*(x^2)))+pnorm(cc[w]-(alpha.hat+beta_1.hat*x+beta_2.hat*(x^2)))-1
  #   return(res)
  # }
  residfit_ls[[j]] <- lm(ls_res[[j]]~X_1)
  xp_value_ls[[j]]<-anova(residfit_ls[[j]])$'Pr(>F)'[2]
  x2p_value_ls[[j]]<-anova(residfit_ls[[j]])$'Pr(>F)'[1]
  
  
  clm.residuals = function(obj) {
    preds = predict(obj, type="cum.prob")
    residuals = runif(length(preds$cprob1))*(preds$cprob1-preds$cprob2) + preds$cprob2
    return(qnorm(residuals))}
  
  clm_res[[j]]<-clm.residuals(model_c)
  residfit_ds[[j]]<- lm(clm_res[[j]]~X_1)
  xp_value_ds[[j]]<-anova(residfit_ds[[j]])$'Pr(>F)'[2]
  x2p_value_ds[[j]]<-anova(residfit_ds[[j]])$'Pr(>F)'[1]
  
  ##### Figure 1: SBS and surrogate residual when the model is correct
  # par(mfrow=c(3,3))
  # # 
  # plot(X_1,ls_res[[j]], ylim=c(-1,1), xlab="X",ylab="L-S residuals",main="(a)",cex.lab=1.5)
  # abline(h=0,lty=2,lwd=1)
  # # 
  # plot(X_2,ls_res[[j]], ylim=c(-1,1), xlab=expression(X^2),ylab="L-S residuals",main="(b)",cex.lab=1.5)
  # abline(h=0,lty=2,lwd=1)
  # # 
  # sample.ref<-runif(10000,min=-1,max=1)
  # qqplot(sample.ref,ls_res[[j]],main="(c)",ylab="L-S residuals",xlab="U(-1,1) distribution",cex.lab=1.5)
  # abline(0,1,col="red",lwd=1)
  # # 
  # plot(clm.residuals(model_c)~X_1,ylab="D-S residuals",cex.lab=1.5,main="(d)",xlab="X")
  # abline(h=0,col="black",lty=2,lwd=1)
  # plot(clm.residuals(model_c)~X_2,ylab="D-S residuals",cex.lab=1.5,main="(e)",xlab=expression(X^2))
  # abline(h=0,col="black",lty=2,lwd=1)
  # qqnorm(clm.residuals(model_c),ylab="D-S residuals",xlab="Normal distribution",cex.lab=1.5,main="(f)")
  # qqline(clm.residuals(model_c),col="red",lwd=1)
  # # 
  # plot(X_1,res.boot, ylim=c(-3,3),xlab="X",ylab="Surrogate residuals",main="(g)",cex.lab=1.5)
  # abline(h=0,lty=2,lwd=1)
  # #
  # plot(X_1,res.boot,ylim=c(-3,3),lxlab=expression(X^2),ylab="Surrogate residuals",main="(h)",cex.lab=1.5)
  # abline(h=0,lty=2,lwd=1)
  #
  #index<-which(prob<0.8)
  qqplot(RES,res.boot, xlab="Normal distribution",ylab="Surrogate residuals",main="(b) Cumulative logit model",cex.lab=1.5)
  abline(0,1,col="red",lwd=1)
  
  par(mfrow=c(3,2))
  # 
  # hist(unlist(xp_value_ls),xlab="p-values X term",main="",ylim=c(0,140),xlim=c(0,1),breaks=c(0,0.8,0.9,1.0),freq=TRUE,cex.lab=1.5)
  # hist(unlist(x2p_value_ls[[j]]), xlab=expression(p~-~values~ X^2~term),main="",ylim=c(0,140),xlim=c(0,1),breaks=c(0,0.8,0.9,1.0),freq=TRUE,cex.lab=1.5)
  # 
  # hist(unlist(xp_value_ds[[j]]),xlab="p-values X term",main="",ylim=c(0,140),xlim=c(0,1),cex.lab=1.5)
  # hist(unlist(x2p_value_ds[[j]]), xlab=expression(p~-~values~ X^2~term),main="",ylim=c(0,140),xlim=c(0,1),cex.lab=1.5)
  # 
  # #surrogate all well
  # hist(unlist(xp_value_sur),xlab="p-values X term",main="",ylim=c(0,140),xlim=c(0,1),cex.lab=1.5,freq=TRUE)
  # hist(unlist(x2p_value_sur), xlab=expression(p~-~values~ X^2~term),main="",ylim=c(0,140),xlim=c(0,1),cex.lab=1.5,freq=TRUE)
  # 
  # mtext("(a) L-S residuals", side=3,line=-3,outer=TRUE)
  # mtext("(b) D-S residuals", side=3,line=-21,outer=TRUE)
  # mtext("(c) Surrogate residuals", side=3,line=-40,outer=TRUE)
  
  count_ls[[j]]<-length(xp_value_ls[xp_value_ls[[j]]<=0.05])
  count_ds[[j]]<-length(xp_value_ds[xp_value_ds[[j]]<=0.05])
  count_sur[[j]]<-length(xp_value_sur[xp_value_sur[[j]]<=0.05])
  count_ls2[[j]]<-length(x2p_value_ls[x2p_value_ls[[j]]<=0.05])
  count_ds2[[j]]<-length(x2p_value_ds[x2p_value_ds[[j]]<=0.05])
  count_sur2[[j]]<-length(x2p_value_sur[x2p_value_sur[[j]]<=0.05])
}

#####################################
# Scenario 4. Missing covariate â€“ Figures 5.5, 5.12-5.15
##########################################
library("tmvtnorm")
library("VGAM")
library("sure")
library("ordinal")
clm.residuals = function(obj) {
  preds = predict(obj, type="cum.prob")
  residuals = runif(length(preds$cprob1))*(preds$cprob1-preds$cprob2) + preds$cprob2
  return(qnorm(residuals))}
################################################################
### Model diagnosis for missing covariate / mixed population
###############################################################
#########################################################################
### Simulate latent variable Z from X1 and X2 plus noise
### The ordinal outcome W is obtained by discretizing Z
########################################################################
###########
###########
#PROBIT
###########
###########
set.seed(15)
n<-10000

alpha<-2;beta_1<--1;beta_2<-7
thrd<-c(0,2,4)

#X<-rnorm(n,mean=3,sd=2)
#X_1<-rbinom(n,1,0.8)
#X_1<-runif(n,1,2)
X_1<-rnorm(n,1,0.3)
X_2<-rbinom(n,1,0.3)
RES<-rnorm(n)
#Latent variable
Z<-alpha+beta_1*X_1+beta_2*X_2+RES
#Ordinal variable
ordinalize<-function(z,threshold){ 
  oo<-function(zz){
    ordinal.value<-1;index<-1
    while(index<=length(threshold) && zz>threshold[index]) {ordinal.value<-ordinal.value+1;index<-index+1}
    return(ordinal.value)
  }
  return(sapply(z,oo))
}
W<-ordinalize(Z,thrd)
table(W)
#Plot the response variable
par(mfrow=c(2,2))
thrds<-c(-2,0,2)
thrde<-c(0,2,4)
thrdu<-c(-1,3,4)
Ys<-ordinalize(Z,thrds)
Ye<-ordinalize(Z,thrde)
Yu<-ordinalize(Z,thrdu)
hist(Z,main="",xlab=expression("Y"^'*'),cex=1.5,cex.lab=1.6,cex.axis=1.5,ylim=c(0,2000),xlim=c(-5,15))
barplot(unlist(table(Ys)),xlab="Y symmetric thresholds",cex=1.5,cex.lab=1.6,cex.axis=1.5,ylim=c(0,6000),col="white",xaxt = "n",ylab="Frequency")
axis(side=1,at=c(0.9,1.9,3.1,4.3),label=c("(-3,-2]","(-2,0]","(0,2]","(2,13)"),cex.axis=1.5)
barplot(unlist(table(Ye)),xlab="Y equidistant thresholds",cex=1.5,cex.lab=1.6,cex.axis=1.5,ylim=c(0,6000),col="white",xaxt = "n",ylab="Frequency")
axis(side=1,at=c(0.9,1.9,3.1,4.3),label=c("(-3,0]","(0,2]","(2,4]","(4,13)"),cex.axis=1.5)
barplot(unlist(table(Yu)),xlab="Y unconstrained thresholds",cex=1.5,cex.lab=1.6,cex.axis=1.5,ylim=c(0,6000),col="white",xaxt = "n",ylab="Frequency")
axis(side=1,at=c(0.9,1.9,3.1,4.3),label=c("(-3,-1]","(-1,3]","(3,4]","(4,13)"),cex.axis=1.5)


#########################################
#########################################
#PROBIT
#########################################
#########################################

#Symmetric thresholds
set.seed(15)
n<-10000

alpha<-2;beta_1<--1;beta_2<-7
thrd<-c(0,2,4)

#X<-rnorm(n,mean=3,sd=2)
#X_1<-rbinom(n,1,0.8)
#X_1<-runif(n,1,2)
X_1<-rnorm(n,1,0.3)
X_2<-rbinom(n,1,0.3)
RES<-rnorm(n)
#Latent variable
Z<-alpha+beta_1*X_1+beta_2*X_2+RES
W<-ordinalize(Z,thrds)
#WRONG MODEL
#### Obtain residuals when X_2 is missing 
model<-vglm(formula=(W-1)~X_1,family = cumulative(link = probit,parallel = TRUE))

alpha.hat<--coef(model)[1];beta.hat<--coef(model)[4]
thrd.hat<-c(0,coef(model)[2]-coef(model)[1],coef(model)[3]-coef(model)[1])
model_cw<-clm(as.ordered(W-1)~X_1,link="probit",threshold="symmetric")
#Li-Shepherd residual
residual.LS<-function(w,x){
  cc<-c(-Inf,thrd.hat,Inf)
  res<-pnorm(cc[w+1]-(alpha.hat+beta.hat*x))+pnorm(cc[w]-(alpha.hat+beta.hat*x))-1
  return(res)
}
res.LS.wrong<-residual.LS(W,X_1)

par(mar=c(6,6,2,2))
par(mfrow=c(2,3))
plot(density(res.LS.wrong),ylim=c(0,4),xlim=c(-1.2,1.2),xlab="L-S residual wrong model",main="",cex=2,cex.main=2,cex.axis=2,cex.lab=2)
#plot(density(res.LS),ylim=c(0,2.5),xlim=c(-1,1),main="(b)",xlab="SBS residual")
#abline(v=mean(res.LS.wrong),lty=3)
#lines(density(res.LS.wrong),lty=2,col="red")



plot(density(clm.residuals(model_cw)),main="",xlab="D-S residuals wrong model",cex=2,cex.main=2,cex.axis=2,cex.lab=2)

#####Surrogate residual
#resids from sure package
res.boot.wrong<-resids(model)
plot(density(res.boot.wrong),main="",xlab="Surrogate residuals wrong model",cex=2,cex.main=2,cex.axis=2,cex.lab=2)
####### Plot


####################
#Right model
#### Obtain residuals when the model is right
model<-vglm(formula=(W-1)~X_1+X_2,family = cumulative(link = probit,parallel = TRUE))
model_c<-clm(as.ordered(W-1)~X_1+X_2,link="probit",threshold="symmetric")

#####Li-Shepherd residual
residual.LS<-function(w,x1,x2){
  cc<-c(-Inf,thrd.hat,Inf)
  res<-pnorm(cc[w+1]-(alpha.hat+beta_1.hat*x1+beta_2.hat*x2))+pnorm(cc[w]-(alpha.hat+beta_1.hat*x1+beta_2.hat*x2))-1
  return(res)
}

res.LS.true<-residual.LS(W,X_1,X_2)

# r.lognorm<-exp(rnorm(1000000))-exp(1/2); r.norm<-rnorm(1000000)
# plot(density(r.lognorm),xlim=c(-3,5),xlab="",main="(a) Link function");lines(density(r.norm),lty=2)


####### Density plots

plot(density(res.LS.true),ylim=c(0,35),xlim=c(-0.3,0.3),xlab="L-S residuals right model",main="",cex=2,cex.main=2,cex.axis=2,cex.lab=2)
#plot(density(res.LS),ylim=c(0,2.5),xlim=c(-1,1),main="(b)",xlab="SBS residual")
#abline(v=mean(res.LS.true),lty=3)
#lines(density(res.LS.true),lty=2,col="green")


plot(density(clm.residuals(model_c)),main="",xlab="D-S residuals right model",cex=2,cex.main=2,cex.axis=2,cex.lab=2)

#plot(density(res.boot.true),xlab="Surrogate residuals rigth model",main="",cex=2,cex.main=2,cex.axis=2,cex.lab=2)
#plot(density(res.boot),main="(a)

#####Surrogate residual
#resids from sure package
res.boot.true<-resids(model)
plot(density(res.boot.true),main="",xlab="Surrogate residuals right model",cex=2,cex.main=2,cex.lab=2,cex.axis=2)
#residual.bootstrap<-function(w,x1,x2){
#  cc<-c(-Inf,thrd.hat,Inf)
#  res<-rtmvnorm(1,mean=(alpha.hat+beta_1.hat*x1+beta_2.hat*x2),sigma=1,lower=cc[w],upper=cc[w+1])-(alpha.hat+beta_1.hat*x1+beta_2.hat*x2)
#}

#res.boot.true<-rep(NA,n)
#for(i in 1:n){res.boot.true[i]<-residual.bootstrap(W[i],X_1[i],X_2[i])}



####################

############################
#Equidistant thresholds
############################
set.seed(15)
n<-10000

alpha<-2;beta_1<--1;beta_2<-7
thrd<-c(0,2,4)

#X<-rnorm(n,mean=3,sd=2)
#X_1<-rbinom(n,1,0.8)
#X_1<-runif(n,1,2)
X_1<-rnorm(n,1,0.3)
X_2<-rbinom(n,1,0.3)
RES<-rnorm(n)
#Latent variable
Z<-alpha+beta_1*X_1+beta_2*X_2+RES
W<-ordinalize(Z,thrde)
#WRONG MODEL
#### Obtain residuals when X_2 is missing 
model<-vglm(formula=(W-1)~X_1,family = cumulative(link = probit,parallel = TRUE))

alpha.hat<--coef(model)[1];beta.hat<--coef(model)[4]
thrd.hat<-c(0,coef(model)[2]-coef(model)[1],coef(model)[3]-coef(model)[1])
model_cw<-clm(as.ordered(W-1)~X_1,link="probit",threshold="equidistant")
#Li-Shepherd residual
residual.LS<-function(w,x){
  cc<-c(-Inf,thrd.hat,Inf)
  res<-pnorm(cc[w+1]-(alpha.hat+beta.hat*x))+pnorm(cc[w]-(alpha.hat+beta.hat*x))-1
  return(res)
}
res.LS.wrong<-residual.LS(W,X_1)

par(mar=c(6,6,2,2))
par(mfrow=c(2,3))
plot(density(res.LS.wrong),ylim=c(0,4),xlim=c(-1.2,1.2),xlab="L-S residual wrong model",main="",cex=2,cex.main=2,cex.axis=2,cex.lab=2)
#plot(density(res.LS),ylim=c(0,2.5),xlim=c(-1,1),main="(b)",xlab="SBS residual")
#abline(v=mean(res.LS.wrong),lty=3)
#lines(density(res.LS.wrong),lty=2,col="red")



plot(density(clm.residuals(model_cw)),main="",xlab="D-S residuals wrong model",cex=2,cex.main=2,cex.axis=2,cex.lab=2)

#####Surrogate residual
#resids from sure package
res.boot.wrong<-resids(model)
plot(density(res.boot.wrong),main="",xlab="Surrogate residuals wrong model",cex=2,cex.main=2,cex.axis=2,cex.lab=2)
####### Plot


####################

#Right model
#### Obtain residuals when the model is right
model<-vglm(formula=(W-1)~X_1+X_2,family = cumulative(link = probit,parallel = TRUE))
model_c<-clm(as.ordered(W-1)~X_1+X_2,link="probit",threshold="equidistant")

#####Li-Shepherd residual
residual.LS<-function(w,x1,x2){
  cc<-c(-Inf,thrd.hat,Inf)
  res<-pnorm(cc[w+1]-(alpha.hat+beta_1.hat*x1+beta_2.hat*x2))+pnorm(cc[w]-(alpha.hat+beta_1.hat*x1+beta_2.hat*x2))-1
  return(res)
}

res.LS.true<-residual.LS(W,X_1,X_2)

# r.lognorm<-exp(rnorm(1000000))-exp(1/2); r.norm<-rnorm(1000000)
# plot(density(r.lognorm),xlim=c(-3,5),xlab="",main="(a) Link function");lines(density(r.norm),lty=2)


####### Density plots

plot(density(res.LS.true),ylim=c(0,35),xlim=c(-0.3,0.3),xlab="L-S residuals right model",main="",cex=2,cex.main=2,cex.axis=2,cex.lab=2)
#plot(density(res.LS),ylim=c(0,2.5),xlim=c(-1,1),main="(b)",xlab="SBS residual")
#abline(v=mean(res.LS.true),lty=3)
#lines(density(res.LS.true),lty=2,col="green")


plot(density(clm.residuals(model_c)),main="",xlab="D-S residuals right model",cex=2,cex.main=2,cex.axis=2,cex.lab=2)

#plot(density(res.boot.true),xlab="Surrogate residuals rigth model",main="",cex=2,cex.main=2,cex.axis=2,cex.lab=2)
#plot(density(res.boot),main="(a)

#####Surrogate residual
#resids from sure package
res.boot.true<-resids(model)
plot(density(res.boot.true),main="",xlab="Surrogate residuals right model",cex=2,cex.main=2,cex.lab=2,cex.axis=2)
#residual.bootstrap<-function(w,x1,x2){
#  cc<-c(-Inf,thrd.hat,Inf)
#  res<-rtmvnorm(1,mean=(alpha.hat+beta_1.hat*x1+beta_2.hat*x2),sigma=1,lower=cc[w],upper=cc[w+1])-(alpha.hat+beta_1.hat*x1+beta_2.hat*x2)
#}

#res.boot.true<-rep(NA,n)
#for(i in 1:n){res.boot.true[i]<-residual.bootstrap(W[i],X_1[i],X_2[i])}



####################
#Unconstrained thresholds
####################
set.seed(15)
n<-10000

alpha<-2;beta_1<--1;beta_2<-7
thrd<-c(0,2,4)

#X<-rnorm(n,mean=3,sd=2)
#X_1<-rbinom(n,1,0.8)
#X_1<-runif(n,1,2)
X_1<-rnorm(n,1,0.3)
X_2<-rbinom(n,1,0.3)
RES<-rnorm(n)
#Latent variable
Z<-alpha+beta_1*X_1+beta_2*X_2+RES
W<-ordinalize(Z,thrdu)
#WRONG MODEL
#### Obtain residuals when X_2 is missing 
model<-vglm(formula=(W-1)~X_1,family = cumulative(link = probit,parallel = TRUE))

alpha.hat<--coef(model)[1];beta.hat<--coef(model)[4]
thrd.hat<-c(0,coef(model)[2]-coef(model)[1],coef(model)[3]-coef(model)[1])
model_cw<-clm(as.ordered(W-1)~X_1,link="probit",threshold="flexible")
#Li-Shepherd residual
residual.LS<-function(w,x){
  cc<-c(-Inf,thrd.hat,Inf)
  res<-pnorm(cc[w+1]-(alpha.hat+beta.hat*x))+pnorm(cc[w]-(alpha.hat+beta.hat*x))-1
  return(res)
}
res.LS.wrong<-residual.LS(W,X_1)

par(mar=c(6,6,2,2))
par(mfrow=c(2,3))
plot(density(res.LS.wrong),ylim=c(0,4),xlim=c(-1.2,1.2),xlab="L-S residual wrong model",main="",cex=2,cex.main=2,cex.axis=2,cex.lab=2)
#plot(density(res.LS),ylim=c(0,2.5),xlim=c(-1,1),main="(b)",xlab="SBS residual")
#abline(v=mean(res.LS.wrong),lty=3)
#lines(density(res.LS.wrong),lty=2,col="red")



plot(density(clm.residuals(model_cw)),main="",xlab="D-S residuals wrong model",cex=2,cex.main=2,cex.axis=2,cex.lab=2)

#####Surrogate residual
#resids from sure package
res.boot.wrong<-resids(model)
plot(density(res.boot.wrong),main="",xlab="Surrogate residuals wrong model",cex=2,cex.main=2,cex.axis=2,cex.lab=2)
####### Plot


####################
#Right model
#### Obtain residuals when the model is right
model<-vglm(formula=(W-1)~X_1+X_2,family = cumulative(link = probit,parallel = TRUE))
model_c<-clm(as.ordered(W-1)~X_1+X_2,link="probit",threshold="flexible")

#####Li-Shepherd residual
residual.LS<-function(w,x1,x2){
  cc<-c(-Inf,thrd.hat,Inf)
  res<-pnorm(cc[w+1]-(alpha.hat+beta_1.hat*x1+beta_2.hat*x2))+pnorm(cc[w]-(alpha.hat+beta_1.hat*x1+beta_2.hat*x2))-1
  return(res)
}

res.LS.true<-residual.LS(W,X_1,X_2)

# r.lognorm<-exp(rnorm(1000000))-exp(1/2); r.norm<-rnorm(1000000)
# plot(density(r.lognorm),xlim=c(-3,5),xlab="",main="(a) Link function");lines(density(r.norm),lty=2)


####### Density plots

plot(density(res.LS.true),ylim=c(0,35),xlim=c(-0.3,0.3),xlab="L-S residuals right model",main="",cex=2,cex.main=2,cex.axis=2,cex.lab=2)
#plot(density(res.LS),ylim=c(0,2.5),xlim=c(-1,1),main="(b)",xlab="SBS residual")
#abline(v=mean(res.LS.true),lty=3)
#lines(density(res.LS.true),lty=2,col="green")


plot(density(clm.residuals(model_c)),main="",xlab="D-S residuals right model",cex=2,cex.main=2,cex.axis=2,cex.lab=2)

#plot(density(res.boot.true),xlab="Surrogate residuals rigth model",main="",cex=2,cex.main=2,cex.axis=2,cex.lab=2)
#plot(density(res.boot),main="(a)

#####Surrogate residual
#resids from sure package
res.boot.true<-resids(model)
plot(density(res.boot.true),main="",xlab="Surrogate residuals right model",cex=2,cex.main=2,cex.lab=2,cex.axis=2)
#residual.bootstrap<-function(w,x1,x2){
#  cc<-c(-Inf,thrd.hat,Inf)
#  res<-rtmvnorm(1,mean=(alpha.hat+beta_1.hat*x1+beta_2.hat*x2),sigma=1,lower=cc[w],upper=cc[w+1])-(alpha.hat+beta_1.hat*x1+beta_2.hat*x2)
#}

#res.boot.true<-rep(NA,n)
#for(i in 1:n){res.boot.true[i]<-residual.bootstrap(W[i],X_1[i],X_2[i])}


#################
#Logit
#################
set.seed(15)
n<-10000

alpha<-2;beta_1<--1;beta_2<-7
thrd<-c(0,2,4)

#X<-rnorm(n,mean=3,sd=2)
#X_1<-rbinom(n,1,0.8)
#X_1<-runif(n,1,2)
X_1<-rnorm(n,1,0.3)
X_2<-rbinom(n,1,0.5)
RES<-rnorm(n)
#Latent variable
Z<-alpha+beta_1*X_1+beta_2*X_2+RES
#Ordinal variable
ordinalize<-function(z,threshold){ 
  oo<-function(zz){
    ordinal.value<-1;index<-1
    while(index<=length(threshold) && zz>threshold[index]) {ordinal.value<-ordinal.value+1;index<-index+1}
    return(ordinal.value)
  }
  return(sapply(z,oo))
}
W<-ordinalize(Z,thrd)
table(W)
#Plot the response variable
par(mfrow=c(2,2))
thrds<-c(-2,0,2)
thrde<-c(0,2,4)
thrdu<-c(-1,3,4)
Ys<-ordinalize(Z,thrds)
Ye<-ordinalize(Z,thrde)
Yu<-ordinalize(Z,thrdu)
hist(Z,main="",xlab=expression("Y"^'*'),cex=1.5,cex.lab=1.6,cex.axis=1.5,ylim=c(0,2000),xlim=c(-5,15))
barplot(unlist(table(Ys)),xlab="Y symmetric thresholds",cex=1.5,cex.lab=1.6,cex.axis=1.5,ylim=c(0,6000),col="white",xaxt = "n",ylab="Frequency")
axis(side=1,at=c(0.9,1.9,3.1,4.3),label=c("(-3,-2]","(-2,0]","(0,2]","(2,13)"),cex.axis=1.5)
barplot(unlist(table(Ye)),xlab="Y equidistant thresholds",cex=1.5,cex.lab=1.6,cex.axis=1.5,ylim=c(0,6000),col="white",xaxt = "n",ylab="Frequency")
axis(side=1,at=c(0.9,1.9,3.1,4.3),label=c("(-3,0]","(0,2]","(2,4]","(4,13)"),cex.axis=1.5)
barplot(unlist(table(Yu)),xlab="Y unconstrained thresholds",cex=1.5,cex.lab=1.6,cex.axis=1.5,ylim=c(0,6000),col="white",xaxt = "n",ylab="Frequency")
axis(side=1,at=c(0.9,1.9,3.1,4.3),label=c("(-3,-1]","(-1,3]","(3,4]","(4,13)"),cex.axis=1.5)

#####################
#Symmetric thresholds
#####################
set.seed(15)
n<-10000

alpha<-2;beta_1<--1;beta_2<-7
thrd<-c(0,2,4)

#X<-rnorm(n,mean=3,sd=2)
#X_1<-rbinom(n,1,0.8)
#X_1<-runif(n,1,2)
X_1<-rnorm(n,1,0.3)
X_2<-rbinom(n,1,0.3)
RES<-rnorm(n)
#Latent variable
Z<-alpha+beta_1*X_1+beta_2*X_2+RES
W<-ordinalize(Z,thrds)
#WRONG MODEL
#### Obtain residuals when X_2 is missing 
model<-vglm(formula=(W-1)~X_1,family = cumulative(link = logit,parallel = TRUE))

alpha.hat<--coef(model)[1];beta.hat<--coef(model)[4]
thrd.hat<-c(0,coef(model)[2]-coef(model)[1],coef(model)[3]-coef(model)[1])
model_cw<-clm(as.ordered(W-1)~X_1,link="logit",threshold="symmetric")
#Li-Shepherd residual
residual.LS<-function(w,x){
  cc<-c(-Inf,thrd.hat,Inf)
  res<-pnorm(cc[w+1]-(alpha.hat+beta.hat*x))+pnorm(cc[w]-(alpha.hat+beta.hat*x))-1
  return(res)
}
res.LS.wrong<-residual.LS(W,X_1)

par(mar=c(6,6,2,2))
par(mfrow=c(2,3))
plot(density(res.LS.wrong),ylim=c(0,4),xlim=c(-1.2,1.2),xlab="L-S residual wrong model",main="",cex=2,cex.main=2,cex.axis=2,cex.lab=2)
#plot(density(res.LS),ylim=c(0,2.5),xlim=c(-1,1),main="(b)",xlab="SBS residual")
#abline(v=mean(res.LS.wrong),lty=3)
#lines(density(res.LS.wrong),lty=2,col="red")



plot(density(clm.residuals(model_cw)),main="",xlab="D-S residuals wrong model",cex=2,cex.main=2,cex.axis=2,cex.lab=2)

#####Surrogate residual
#resids from sure package
res.boot.wrong<-resids(model)
plot(density(res.boot.wrong),main="",xlab="Surrogate residuals wrong model",cex=2,cex.main=2,cex.axis=2,cex.lab=2)
####### Plot


####################
#Right model
#### Obtain residuals when the model is right
model<-vglm(formula=(W-1)~X_1+X_2,family = cumulative(link = logit,parallel = TRUE))
model_c<-clm(as.ordered(W-1)~X_1+X_2,link="logit",threshold="symmetric")

#####Li-Shepherd residual
residual.LS<-function(w,x1,x2){
  cc<-c(-Inf,thrd.hat,Inf)
  res<-pnorm(cc[w+1]-(alpha.hat+beta_1.hat*x1+beta_2.hat*x2))+pnorm(cc[w]-(alpha.hat+beta_1.hat*x1+beta_2.hat*x2))-1
  return(res)
}

res.LS.true<-residual.LS(W,X_1,X_2)

# r.lognorm<-exp(rnorm(1000000))-exp(1/2); r.norm<-rnorm(1000000)
# plot(density(r.lognorm),xlim=c(-3,5),xlab="",main="(a) Link function");lines(density(r.norm),lty=2)


####### Density plots

plot(density(res.LS.true),ylim=c(0,35),xlim=c(-0.3,0.3),xlab="L-S residuals right model",main="",cex=2,cex.main=2,cex.axis=2,cex.lab=2)
#plot(density(res.LS),ylim=c(0,2.5),xlim=c(-1,1),main="(b)",xlab="SBS residual")
#abline(v=mean(res.LS.true),lty=3)
#lines(density(res.LS.true),lty=2,col="green")


plot(density(clm.residuals(model_c)),main="",xlab="D-S residuals right model",cex=2,cex.main=2,cex.axis=2,cex.lab=2)

#plot(density(res.boot.true),xlab="Surrogate residuals rigth model",main="",cex=2,cex.main=2,cex.axis=2,cex.lab=2)
#plot(density(res.boot),main="(a)

#####Surrogate residual
#resids from sure package
res.boot.true<-resids(model)
plot(density(res.boot.true),main="",xlab="Surrogate residuals right model",cex=2,cex.main=2,cex.lab=2,cex.axis=2)
#residual.bootstrap<-function(w,x1,x2){
#  cc<-c(-Inf,thrd.hat,Inf)
#  res<-rtmvnorm(1,mean=(alpha.hat+beta_1.hat*x1+beta_2.hat*x2),sigma=1,lower=cc[w],upper=cc[w+1])-(alpha.hat+beta_1.hat*x1+beta_2.hat*x2)
#}

#res.boot.true<-rep(NA,n)
#for(i in 1:n){res.boot.true[i]<-residual.bootstrap(W[i],X_1[i],X_2[i])}



####################

############################
#Equidistant thresholds
############################
set.seed(15)
n<-10000

alpha<-2;beta_1<--1;beta_2<-7
thrd<-c(0,2,4)

#X<-rnorm(n,mean=3,sd=2)
#X_1<-rbinom(n,1,0.8)
#X_1<-runif(n,1,2)
X_1<-rnorm(n,1,0.3)
X_2<-rbinom(n,1,0.3)
RES<-rnorm(n)
#Latent variable
Z<-alpha+beta_1*X_1+beta_2*X_2+RES
W<-ordinalize(Z,thrde)
#WRONG MODEL
#### Obtain residuals when X_2 is missing 
model<-vglm(formula=(W-1)~X_1,family = cumulative(link = logit,parallel = TRUE))

alpha.hat<--coef(model)[1];beta.hat<--coef(model)[4]
thrd.hat<-c(0,coef(model)[2]-coef(model)[1],coef(model)[3]-coef(model)[1])
model_cw<-clm(as.ordered(W-1)~X_1,link="logit",threshold="equidistant")
#Li-Shepherd residual
residual.LS<-function(w,x){
  cc<-c(-Inf,thrd.hat,Inf)
  res<-pnorm(cc[w+1]-(alpha.hat+beta.hat*x))+pnorm(cc[w]-(alpha.hat+beta.hat*x))-1
  return(res)
}
res.LS.wrong<-residual.LS(W,X_1)

par(mar=c(6,6,2,2))
par(mfrow=c(2,3))
plot(density(res.LS.wrong),ylim=c(0,4),xlim=c(-1.2,1.2),xlab="L-S residual wrong model",main="",cex=2,cex.main=2,cex.axis=2,cex.lab=2)
#plot(density(res.LS),ylim=c(0,2.5),xlim=c(-1,1),main="(b)",xlab="SBS residual")
#abline(v=mean(res.LS.wrong),lty=3)
#lines(density(res.LS.wrong),lty=2,col="red")



plot(density(clm.residuals(model_cw)),main="",xlab="D-S residuals wrong model",cex=2,cex.main=2,cex.axis=2,cex.lab=2)

#####Surrogate residual
#resids from sure package
res.boot.wrong<-resids(model)
plot(density(res.boot.wrong),main="",xlab="Surrogate residuals wrong model",cex=2,cex.main=2,cex.axis=2,cex.lab=2)
####### Plot


####################

#Right model
#### Obtain residuals when the model is right
model<-vglm(formula=(W-1)~X_1+X_2,family = cumulative(link = logit,parallel = TRUE))
model_c<-clm(as.ordered(W-1)~X_1+X_2,link="logit",threshold="equidistant")

#####Li-Shepherd residual
residual.LS<-function(w,x1,x2){
  cc<-c(-Inf,thrd.hat,Inf)
  res<-pnorm(cc[w+1]-(alpha.hat+beta_1.hat*x1+beta_2.hat*x2))+pnorm(cc[w]-(alpha.hat+beta_1.hat*x1+beta_2.hat*x2))-1
  return(res)
}

res.LS.true<-residual.LS(W,X_1,X_2)

# r.lognorm<-exp(rnorm(1000000))-exp(1/2); r.norm<-rnorm(1000000)
# plot(density(r.lognorm),xlim=c(-3,5),xlab="",main="(a) Link function");lines(density(r.norm),lty=2)


####### Density plots

plot(density(res.LS.true),ylim=c(0,35),xlim=c(-0.3,0.3),xlab="L-S residuals right model",main="",cex=2,cex.main=2,cex.axis=2,cex.lab=2)
#plot(density(res.LS),ylim=c(0,2.5),xlim=c(-1,1),main="(b)",xlab="SBS residual")
#abline(v=mean(res.LS.true),lty=3)
#lines(density(res.LS.true),lty=2,col="green")


plot(density(clm.residuals(model_c)),main="",xlab="D-S residuals right model",cex=2,cex.main=2,cex.axis=2,cex.lab=2)

#plot(density(res.boot.true),xlab="Surrogate residuals rigth model",main="",cex=2,cex.main=2,cex.axis=2,cex.lab=2)
#plot(density(res.boot),main="(a)

#####Surrogate residual
#resids from sure package
res.boot.true<-resids(model)
plot(density(res.boot.true),main="",xlab="Surrogate residuals right model",cex=2,cex.main=2,cex.lab=2,cex.axis=2)
#residual.bootstrap<-function(w,x1,x2){
#  cc<-c(-Inf,thrd.hat,Inf)
#  res<-rtmvnorm(1,mean=(alpha.hat+beta_1.hat*x1+beta_2.hat*x2),sigma=1,lower=cc[w],upper=cc[w+1])-(alpha.hat+beta_1.hat*x1+beta_2.hat*x2)
#}

#res.boot.true<-rep(NA,n)
#for(i in 1:n){res.boot.true[i]<-residual.bootstrap(W[i],X_1[i],X_2[i])}


####################
#Unconstrained thresholds
####################
set.seed(15)
n<-10000

alpha<-2;beta_1<--1;beta_2<-7
thrd<-c(0,2,4)

#X<-rnorm(n,mean=3,sd=2)
#X_1<-rbinom(n,1,0.8)
#X_1<-runif(n,1,2)
X_1<-rnorm(n,1,0.3)
X_2<-rbinom(n,1,0.3)
RES<-rnorm(n)
#Latent variable
Z<-alpha+beta_1*X_1+beta_2*X_2+RES
W<-ordinalize(Z,thrdu)
#WRONG MODEL
#### Obtain residuals when X_2 is missing 
model<-vglm(formula=(W-1)~X_1,family = cumulative(link = logit,parallel = TRUE))

alpha.hat<--coef(model)[1];beta.hat<--coef(model)[4]
thrd.hat<-c(0,coef(model)[2]-coef(model)[1],coef(model)[3]-coef(model)[1])
model_cw<-clm(as.ordered(W-1)~X_1,link="logit",threshold="flexible")
#Li-Shepherd residual
residual.LS<-function(w,x){
  cc<-c(-Inf,thrd.hat,Inf)
  res<-pnorm(cc[w+1]-(alpha.hat+beta.hat*x))+pnorm(cc[w]-(alpha.hat+beta.hat*x))-1
  return(res)
}
res.LS.wrong<-residual.LS(W,X_1)

par(mar=c(6,6,2,2))
par(mfrow=c(2,3))
plot(density(res.LS.wrong),ylim=c(0,4),xlim=c(-1.2,1.2),xlab="L-S residual wrong model",main="",cex=2,cex.main=2,cex.axis=2,cex.lab=2)
#plot(density(res.LS),ylim=c(0,2.5),xlim=c(-1,1),main="(b)",xlab="SBS residual")
#abline(v=mean(res.LS.wrong),lty=3)
#lines(density(res.LS.wrong),lty=2,col="red")



plot(density(clm.residuals(model_cw)),main="",xlab="D-S residuals wrong model",cex=2,cex.main=2,cex.axis=2,cex.lab=2)

#####Surrogate residual
#resids from sure package
res.boot.wrong<-resids(model)
plot(density(res.boot.wrong),main="",xlab="Surrogate residuals wrong model",cex=2,cex.main=2,cex.axis=2,cex.lab=2)
####### Plot


####################
#Right model
#### Obtain residuals when the model is right
model<-vglm(formula=(W-1)~X_1+X_2,family = cumulative(link = logit,parallel = TRUE))
model_c<-clm(as.ordered(W-1)~X_1+X_2,link="logit",threshold="flexible")

#####Li-Shepherd residual
residual.LS<-function(w,x1,x2){
  cc<-c(-Inf,thrd.hat,Inf)
  res<-pnorm(cc[w+1]-(alpha.hat+beta_1.hat*x1+beta_2.hat*x2))+pnorm(cc[w]-(alpha.hat+beta_1.hat*x1+beta_2.hat*x2))-1
  return(res)
}

res.LS.true<-residual.LS(W,X_1,X_2)

# r.lognorm<-exp(rnorm(1000000))-exp(1/2); r.norm<-rnorm(1000000)
# plot(density(r.lognorm),xlim=c(-3,5),xlab="",main="(a) Link function");lines(density(r.norm),lty=2)


####### Density plots

plot(density(res.LS.true),ylim=c(0,35),xlim=c(-0.3,0.3),xlab="L-S residuals right model",main="",cex=2,cex.main=2,cex.axis=2,cex.lab=2)
#plot(density(res.LS),ylim=c(0,2.5),xlim=c(-1,1),main="(b)",xlab="SBS residual")
#abline(v=mean(res.LS.true),lty=3)
#lines(density(res.LS.true),lty=2,col="green")


plot(density(clm.residuals(model_c)),main="",xlab="D-S residuals right model",cex=2,cex.main=2,cex.axis=2,cex.lab=2)

#plot(density(res.boot.true),xlab="Surrogate residuals rigth model",main="",cex=2,cex.main=2,cex.axis=2,cex.lab=2)
#plot(density(res.boot),main="(a)

#####Surrogate residual
#resids from sure package
res.boot.true<-resids(model)
plot(density(res.boot.true),main="",xlab="Surrogate residuals right model",cex=2,cex.main=2,cex.lab=2,cex.axis=2)
#residual.bootstrap<-function(w,x1,x2){
#  cc<-c(-Inf,thrd.hat,Inf)
#  res<-rtmvnorm(1,mean=(alpha.hat+beta_1.hat*x1+beta_2.hat*x2),sigma=1,lower=cc[w],upper=cc[w+1])-(alpha.hat+beta_1.hat*x1+beta_2.hat*x2)
#}

#res.boot.true<-rep(NA,n)
#for(i in 1:n){res.boot.true[i]<-residual.bootstrap(W[i],X_1[i],X_2[i])}



#Comparison D-S structure specified and not specified
set.seed(15)
n<-10000

alpha<-2;beta_1<--1;beta_2<-7
thrd<-c(0,2,4)

#X<-rnorm(n,mean=3,sd=2)
#X_1<-rbinom(n,1,0.8)
#X_1<-runif(n,1,2)
X_1<-rnorm(n,1,0.3)
X_2<-rbinom(n,1,0.3)
RES<-rnorm(n)
#Latent variable
Z<-alpha+beta_1*X_1+beta_2*X_2+RES
W<-ordinalize(Z,thrdu)

model_e_w_sp<-clm(as.ordered(W-1)~X_1,link="logit",threshold="equidistant")
model_e_w_nsp<-clm(as.ordered(W-1)~X_1,link="logit")
model_e_r_sp<-clm(as.ordered(W-1)~X_1+X_2,link="logit",threshold="equidistant")
model_e_r_nsp<-clm(as.ordered(W-1)~X_1+X_2,link="logit")

par(mfrow=c(2,2))
plot(density(clm.residuals(model_e_w_sp)),main="",xlab="D-S residuals wrong model eq.",cex=2,cex.main=2,cex.axis=2,cex.lab=2)
plot(density(clm.residuals(model_e_w_nsp)),main="",xlab="D-S residuals wrong model",cex=2,cex.main=2,cex.axis=2,cex.lab=2)
plot(density(clm.residuals(model_e_r_sp)),main="",xlab="D-S residuals right model eq.",cex=2,cex.main=2,cex.axis=2,cex.lab=2)
plot(density(clm.residuals(model_e_r_nsp)),main="",xlab="D-S residuals right model",cex=2,cex.main=2,cex.axis=2,cex.lab=2)

############################
#Scenario 5. Heteroscedasticity
############################
# Code adapted from Liu & Zhang (2018)
library(rms)
library(PResiduals)
library(sure)
library(ggplot2)
library(ordinal)
#Detecting heteroscedasticity

#Cumulative probit model
fit.orm<-orm(y~x,data=df2,family="probit",x=TRUE)

#Residual-vs-covariate plot for L-S and Surrogate residuals
set.seed(123)
#L-S residuals
p2<-ggplot(data.frame(x=df2$x,y=presid(fit.orm)),aes(x,y))+geom_point(color="#444444",shape=19,size=2,alpha=0.25)+geom_smooth(col="red",se=FALSE)+ylab("X")+ylab("L-S residuals")+geom_point(shape = 21, colour = "black", fill = "white", size = 1, stroke = 1)

p2+theme_bw()+theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),strip.background = element_blank(),panel.border = element_rect(fill=NA,colour = "black"))+theme(axis.text.x = element_text(size=15),axis.text.y = element_text(size=15),axis.title=element_text(size=15))

#Surrogate residuals

smoothingSpline = smooth.spline(df2$x, resids(fit.orm), spar=0.8)

plot(resids(fit.orm)~df2$x,xlab="X",ylab="Surrogate residuals",cex.axis=1.2,cex.lab=1.2,ylim=c(-4,4))
lines(smoothingSpline,col="red",lwd=3)
#D-S residuals
clm.residuals = function(obj) {
  preds = predict(obj, type="cum.prob")
  residuals = runif(length(preds$cprob1))*(preds$cprob1-preds$cprob2) + preds$cprob2
  return(qnorm(residuals))}
clm_fit<-clm(y~x,data=df2,link="probit")
plot(clm.residuals(clm_fit)~df2$x,ylab="D-S residuals",cex.lab=1.2,cex.axis=1.2,xlab="X",ylim=c(-4,4))
smoothingSpline2 = smooth.spline(df2$x, clm.residuals(fit.orm), spar=0.8)
lines(smoothingSpline2,col="red",lwd=3)


#Cumulative logit model
set.seed(123)
fit.lorm<-orm(y~x,data=df2,family="logistic",x=TRUE)
#L-S residuals

#Fig 5.19.

p2<-ggplot(data.frame(x=df2$x,y=presid(fit.lorm)),aes(x,y))+geom_point(color="#444444",shape=19,size=2,alpha=0.25)+geom_smooth(col="red",se=FALSE)+ylab("X")+ylab("L-S residuals")+geom_point(shape = 21, colour = "black", fill = "white", size = 1, stroke = 1)

p2+theme_bw()+theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),strip.background = element_blank(),panel.border = element_rect(fill=NA,colour = "black"))+theme(axis.text.x = element_text(size=15),axis.text.y = element_text(size=15),axis.title=element_text(size=15))
                                                                                                                                                                                           

#D-S residuals
clm.residuals = function(obj) {
  preds = predict(obj, type="cum.prob")
  residuals = runif(length(preds$cprob1))*(preds$cprob1-preds$cprob2) + preds$cprob2
  return(qnorm(residuals))}
clm_lfit<-clm(y~x,data=df2,link="logit")
plot(clm.residuals(clm_lfit)~df2$x,ylab="D-S residuals",cex.lab=1.2,xlab="X",ylim=c(-7,7),cex.axis=1.2)
smoothingSpline2 = smooth.spline(df2$x, clm.residuals(clm_lfit), spar=0.8)
lines(smoothingSpline2,col="red",lwd=3)
#Surrogate residuals

smoothingSpline = smooth.spline(df2$x, resids(fit.lorm), spar=0.8)

plot(resids(fit.lorm)~df2$x,xlab="X",ylab="Surrogate residuals",cex.axis=1.2,cex.lab=1.2,ylim=c(-7,7))
lines(smoothingSpline,col="red",lwd=3)
